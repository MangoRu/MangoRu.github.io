<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>算法</title>
      <link href="/posts/b7e144d1.html"/>
      <url>/posts/b7e144d1.html</url>
      
        <content type="html"><![CDATA[<h2 id="算法简介"><a href="#算法简介" class="headerlink" title="算法简介"></a>算法简介</h2><p>算法是指解决问题的方法或过程（步骤），算法的四个性质：<font color=red>输入、输出、确定性和有限性</font>。</p><p>常用的描述算法的形式：自然语言、程序流程图、伪代码。</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">算法归类：</span><br><span class="line"></span><br><span class="line"><span class="bullet">-</span> 递归：汉诺塔</span><br><span class="line"><span class="bullet">-</span> 分治：二分查找、归并排序、快速排序</span><br><span class="line"><span class="bullet">-</span> 动态规划：0-1背包、矩阵连乘、最长公共子序列</span><br><span class="line"><span class="bullet">-</span> 贪心：Dijkstra算法、Kruskal算法、Prim算法、背包问题</span><br><span class="line"><span class="bullet">-</span> 回溯：0-1背包、N皇后、旅行售货员、m着色</span><br><span class="line">……</span><br></pre></td></tr></table></figure><h3 id="算法复杂性分析"><a href="#算法复杂性分析" class="headerlink" title="算法复杂性分析"></a>算法复杂性分析</h3><p><strong>几个概念</strong></p><p> <font color=orange>算法复杂性 &#x3D; 算法所需要的计算机资源</font>，用N、I 来表示算法要解决问题的规模和算法的输入，用C表示算法的复杂性，有：<font color=orange>C &#x3D;F(N,I)</font></p><p> <font color=orange>算法的时间复杂性T(n)</font>：如果问题的规模为n，在算法输入为I时算法所需的时间资源为T(N,I) ，T(N,I)称为算法的时间复杂性</p><p> <font color=orange>算法的空间复杂性S(n)</font>：如果问题的规模为n，在算法输入为I时算法所需的空间资源为S(N,I) ，S(N,I)称为算法的空间复杂性</p><p> 算法分析：分析算法复杂性的过程</p><p> 空间复杂性分析相对比较简单，通常主要分析时间复杂性</p><p><strong>时间复杂性渐进表示法</strong></p><p>【符号O的运算规则】</p><p>• (1)<strong>O(f)+O(g)&#x3D;O(max(f,g))</strong></p><p>• (2)<strong>O(f)+O(g)&#x3D;O(f+g)</strong></p><p>• (3)<strong>O(f)O(g)&#x3D;O(fg)</strong></p><p>• (4)如果g(N)&#x3D;O(f(N))，则O(f)+O(g)&#x3D;O(f)</p><p>• (5)O(Cf(N))&#x3D;O(f(N))，其中C是一个正的常数</p><p>• (6)f&#x3D;O(f)</p><blockquote><p>思考练习：求下列函数的渐进表达式</p></blockquote><p>(1) 5$n^2$ + 10n &#x3D;O($n^2$)</p><p>(2) n + nlog$n^2$&#x3D;O(nlogn)  (<strong>log$_a$$M^n$&#x3D;nlog$_a$M</strong>)</p><p>(3) $n^2$ &#x2F;100 + $3^n$ &#x3D;O($3^n$) ???</p><p>(4) 20 log$3^n$ &#x3D;O(n)  </p><p>(5) 1&#x2F;$n^2$ + 1 &#x3D; O(1)</p><p>(6) log$n^5$ + $n^(1&#x2F;2)$ &#x3D; O(logn)</p><p><strong>常见的算法复杂度的大O阶</strong></p><p>√ O(1): 表示算法的运行时间为常量时间</p><p>√ O(logn): 二分查找等算法</p><p>√ O(n): 线性算法，例如线性查找</p><p>√ O(nlogn): 快速排序、归并排序等算法</p><p>√ O(n^2): 对数组进行排序的简单算法，例如冒泡排序等</p><p>√ O(n^3): 做两个n阶矩阵的乘法运算</p><p>√ O(2^n): 求具有n个元素集合的所有子集的算法</p><p>√ O(n!): 求具有n个元素的全排列的算法</p><p><strong>O(1)&lt;O(logn)&lt;O(n)&lt; O(nlogn) &lt;O($n^2$)&lt;O($2^n$)&lt;O(n!)</strong></p><h2 id="算法——递归算法"><a href="#算法——递归算法" class="headerlink" title="算法——递归算法"></a>算法——递归算法</h2><p><code>递归</code>：在调用一个函数的过程中又出现直接或间接调用该函数本身，称为函数的递归调用，这种函数称为<strong>递归函数</strong>。</p><ul><li><strong>直接递归</strong>：p函数定义中调用p函数</li><li><strong>间接递归</strong>：p函数定义中调用q函数，而q函数定义中又调用p函数</li><li>尾递归：一个递归过程或递归函数中的递归调用语句是最后一条执行语句</li></ul><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 递归实例</span></span><br><span class="line"></span><br><span class="line">1-100求和：f(n) = f(n-1) + n &#123;n&gt;1&#125;, f(1) = 1</span><br><span class="line">铺地板(2xn过道铺地板方案)：f(n) = f(n-1) + f(n-2) &#123;n&gt;2&#125;, f(1)=1,f(2)=2</span><br><span class="line">【求阶乘】：f(n) = n<span class="emphasis">*f(n-1) &#123;n&gt;0&#125;, f(0)=1</span></span><br><span class="line"><span class="emphasis">【Fibonacci数列】/兔子数列 =&gt; 蜂房问题：f(n) = f(n-1) + f(n-2) &#123;n&gt;2&#125;, f(1)=1,f(2)=1</span></span><br><span class="line"><span class="emphasis">青蛙跳台阶：f(n) = f(n-1) + f(n-2) &#123;n&gt;2&#125;, f(1)=1,f(2)=2</span></span><br></pre></td></tr></table></figure><p><strong>递归特点</strong></p><p>能够用递归解决的问题应该满足以下3个条件：</p><ul><li><ol><li>需要解决的问题可以转化为<strong>一个或多个子问题来求解</strong>，而这些子问题的<strong>求解方法与原问题完全相同</strong>，只是在数量规模上不同</li></ol></li><li><ol start="2"><li>递归调用的<strong>次数</strong>必须是<strong>有限</strong>的</li></ol></li><li><ol start="3"><li>必须有<strong>结束递归的条件</strong>来终止递归</li></ol></li></ul><p>递归两要素：<font color=green>递归表达式 + 递归结束条件</font></p><p><strong>何时使用递归？</strong></p><ul><li><ol><li><strong>定义</strong>是递归的（<u>阶乘</u>、<u>斐波那契数列</u>等）</li></ol></li><li><ol start="2"><li><strong>数据结构</strong>是递归的（<u>单链表</u>、<u>二叉树</u>等）</li></ol></li><li><ol start="3"><li><strong>问题的求解方法</strong>是递归的（<u>汉诺塔</u>、<u>回溯法</u>等）</li></ol></li></ul><p><strong>递归优缺点</strong>：</p><ul><li><p>优点：<strong>结构清晰，可读性强</strong>，而且容易用<em>数学归纳法来证明算法的正确性</em>，因此它为设计算法、调试程序带来很大方便。</p></li><li><p>缺点：递归算法的<strong>运行效率较低</strong>，无论是耗费的计算时间还是占用的存储空间都比非递归算法要多。</p></li><li><p>解决方法：在某些递归算法中可消除递归调用，使其<u>转化为非递归算法</u>。</p></li></ul><p><strong>【递归扩展实例】</strong></p><h3 id="Ackerman函数"><a href="#Ackerman函数" class="headerlink" title="Ackerman函数"></a>Ackerman函数</h3><blockquote><p><strong>Ackerman函数</strong></p></blockquote><p>当一个函数及它的一个变量（参数）是由函数自身定义时，称这个函数是<font color=orange>双递归函数</font>。</p><p>Ackerman函数 A(n，m) 定义如下：<br>$$<br>\begin{cases}<br>A(1,0)&#x3D;2\<br>A(0,m)&#x3D;1, \quad m\geq0\<br>A(n,0)&#x3D;n+2, \quad n\geq2\<br>A(n,m)&#x3D;A(A(n-1,m),m-1), \quad m\geq1\<br>\end{cases}<br>$$</p><h3 id="全排列问题"><a href="#全排列问题" class="headerlink" title="全排列问题"></a>全排列问题</h3><blockquote><p><strong>全排列问题</strong></p></blockquote><p>设计一个递归算法生成n个元素{r$_1$,r$_2$,…,r$_n$}的全排列。</p><p>设R&#x3D;{r$_1$,r$_2$,…,r$_n$}是要进行排列的n个元素，R$_i$ &#x3D;R-{r$_i$}。</p><p>集合X中元素的全排列记为perm(X)。</p><p>(r$_i$)perm(X)表示在全排列perm(X)的每一个排列前加上前缀得到的排列。R的全排列可归纳定义如下：</p><ul><li><p><font color=orange>当n&#x3D;1时，perm(R)&#x3D;(r)，其中r是集合R中唯一的元素；</font></p></li><li><p><font color=orange>当n&gt;1时，perm(R)由(r$_1$)perm(R$_1$)，(r$_2$)perm(R$_2$)，…，(r$_n$)perm(R$_n$)构成。</font></p></li></ul><p>&#x3D;&gt;</p><p>{1, 2, 3}的全排列如下：</p><p><strong>(1,2,3)，(1,3,2)，(2,1,3)，(2,3,1)，(3,1,2)，(3,2,1)</strong></p><p>【全排列问题】：</p><p> 分析：• 由排列组合的知识可知，<font color=orangedark>n个元素的全排列共有n!种。</font></p><p> 解决方案：</p><p>• 方案1：可以采用n层循环嵌套的方式 -&gt; 代码冗长</p><p>• 方案2：n!可分解为n*(n-1)!种，而(n-1)!又分解为(n-1)(n-2)!种，依次类推。 </p><p>(1) 可以用循环重复执行“<font color=orangedark>交换位置，后面再接剩余序列的所有排列</font>”；</p><p>(2) 对剩余的序列再使用该方法，直至没有剩余序列——递归调用。</p><p> 递归分析：</p><p>• 用一个数组a[n]来保存1<del>n之间的n个自然数，对于i&#x3D;1 ~ n，<font color=orange>每次用a[1]与a[i]交换后，对a[2]</del>a[n]中的n-1个元素进行全排列，然后再交换a[1]与a[i]的值，使它恢复到此次排列前的状态</font></p><p>• 对于<font color=orange>a[3]~a[n]区间内的n-2个元素进行全排列，然后再把交换的元素交换回来</font>；</p><p>• 依次类推，<font color=orange>直到对a[n]进行全排列时，输出整个数组的值，即得到一种排列结果。</font></p><p> <strong>算法设计</strong>：</p><p>对于n个元素a&#x3D;(a$_1$, a$_2$, ……a$_k$, ……a$_n$)，设过程 <strong>perm(a, k, n)</strong> 是<strong>求a的第k到第n个元素的全排列</strong>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">procedure <span class="title function_">perm</span>(a,k,n)</span><br><span class="line"><span class="keyword">if</span> k=n then</span><br><span class="line"><span class="title function_">print</span>(a)</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">for</span> i ← k to n <span class="keyword">do</span></span><br><span class="line">&#123; </span><br><span class="line">    a[k] &lt;--&gt; a[i];</span><br><span class="line">    call <span class="title function_">perm</span>(a,k+<span class="number">1</span>,n);</span><br><span class="line">    a[k]  &lt;--&gt; a[i];</span><br><span class="line">&#125;</span><br><span class="line">endif</span><br><span class="line">end</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 主程序：perm(a, k, n) 求a的第k到第n个元素的全排列</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 注意：a是数组Array，k、n为整数Number</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">perm</span>(<span class="params">a, k, n</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (k === n) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(a.<span class="title function_">join</span>(<span class="string">&quot;&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = k; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="comment">// 第一次交换 将元素换到打头位置</span></span><br><span class="line">        <span class="title function_">swap</span>(a,k,i);</span><br><span class="line">        <span class="title function_">perm</span>(a, k+<span class="number">1</span>, n);</span><br><span class="line">        <span class="comment">// 第二次交换 将两个元素再次换回，序列保持原状，防止重复</span></span><br><span class="line">        <span class="title function_">swap</span>(a,k,i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">swap</span>(<span class="params">a, k, i</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> t = a[k];</span><br><span class="line">    a[k] = a[i];</span><br><span class="line">    a[i] = t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>全排列问题应用：</p><ul><li><p>使用1-9这9个数字，每个数字各出现一次，如何组成如下数学公式：<strong>□□□</strong> <strong>+</strong> <strong>□□□</strong> <strong>&#x3D;</strong> <strong>□□□</strong></p></li><li><p>即：组成三个三位数，其中两个数之和等于第三个数。</p></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 提示</span></span><br><span class="line">int a = list[<span class="number">0</span>]*<span class="number">100</span> + list[<span class="number">1</span>]*<span class="number">10</span> + list[<span class="number">2</span>];</span><br><span class="line">int b = list[<span class="number">3</span>]*<span class="number">100</span> + list[<span class="number">4</span>]*<span class="number">10</span> + list[<span class="number">5</span>];</span><br><span class="line">int c = list[<span class="number">6</span>]*<span class="number">100</span> + list[<span class="number">7</span>]*<span class="number">10</span> + list[<span class="number">8</span>];</span><br><span class="line"><span class="keyword">if</span>(a + b == c) <span class="variable language_">console</span>.<span class="title function_">log</span>(a, b ,c);</span><br></pre></td></tr></table></figure><h3 id="整数划分问题"><a href="#整数划分问题" class="headerlink" title="整数划分问题"></a><strong>整数划分问题</strong></h3><blockquote><p><strong>整数划分问题</strong></p></blockquote><p>将正整数n表示成一系列正整数之和：n&#x3D;n$_1$+n$_2$+…+n$_k$，• 其中，n$_1$≥n$_2$≥…≥n$_k$≥1，k≥1。正整数n的这种表示称为<strong>正整数n的划分</strong>。</p><ul><li><p>例如正整数6有如下11种不同的划分：</p></li><li><ul><li><p>6</p><p>5+1</p><p>4+2，4+1+1</p><p>3+3，3+2+1，3+1+1+1</p><p>2+2+2，2+2+1+1，2+1+1+1+1</p><p>1+1+1+1+1+1</p></li></ul></li></ul><p>【<strong>整数划分问题</strong>】</p><p> 设p(n)为正整数n的划分数，难以找到递归关系</p><p> 考虑增加一个自变量：<font color=orange>将n的最大加数n$_1$不大于的m划分个数记作q(n,m)</font></p><p> 可建立q(n,m)的如下递归关系：</p><ul><li><p><strong>(1) q(n,1)&#x3D;1, n$\geq$1;</strong></p></li><li><ul><li>当最大加数n$_1$不大于1时，任何正整数n只有一种划分形式，即</li></ul></li></ul><p>$$<br>n &#x3D; \overbrace{1+1+\cdots+1}^{n}<br>$$</p><ul><li><p><strong>(2) q(n,m)&#x3D;q(n,n), m$\geq$n;</strong></p></li><li><ul><li>最大加数n$_1$实际上不能大于n。因此，q(1,m)&#x3D;1。</li></ul></li><li><p><strong>(3) q(n,n)&#x3D;1+q(n,n-1);</strong></p></li><li><ul><li>正整数n的划分由n$_1$&#x3D;n的划分和n$_1$≤n-1的划分组成。</li></ul></li><li><p><strong>(4) q(n,m)&#x3D;q(n,m-1)+q(n-m,m), n&gt;m&gt;1;</strong></p></li><li><ul><li>正整数n的最大加数n$_1$不大于m的划分由n$_1$&#x3D;m的划分和n$_1$≤n-1 的划分组成。</li></ul></li></ul><p>递推公式如下：<br>$$<br>q(n,m) &#x3D;<br>\begin{cases}<br>1 &amp; \quad n&#x3D;1,m&#x3D;1\<br>q(n,n) &amp;\quad n&lt;m\<br>1+q(n,n-1) &amp;\quad n&#x3D;m\<br>q(n,m-1)+q(n-m,m) &amp;\quad n&gt;m&gt;1\<br>\end{cases}<br>$$<br>正整数n的划分数p(n)&#x3D;q(n,n)</p><h3 id="汉诺塔问题O-2-n"><a href="#汉诺塔问题O-2-n" class="headerlink" title="汉诺塔问题O(2$^n$)"></a>汉诺塔问题O(2$^n$)</h3><blockquote><p><strong>汉诺塔问题（梵塔问题, Tower of Hanoi）</strong></p></blockquote><p>问题描述：</p><p>设A, B, C是3个塔座。开始时，在塔座A上有一叠共n个圆盘，这些圆盘自下而上，由大到小地叠在一起。</p><p>各圆盘从小到大编号为1,2,…,n，现要求将塔座A上的这一叠圆盘移到塔座C上，并仍按同样顺序叠置。在</p><p>移动圆盘时应遵守以下移动规则：</p><p>• 规则1：<font color=orange>每次只能移动1个圆盘</font>；</p><p>• 规则2：<font color=orange>任何时刻都不允许将较大的圆盘压在较小的圆盘之上</font>；</p><p>• 规则3：在满足移动规则1和2的前提下，可将圆盘移至A,B,C中任一塔座上。</p><p><strong>设计思路</strong>：</p><p>将n个圆盘从A-&gt;C，可以分解为3个步骤：</p><ul><li><p>(1) 将n-1个圆盘从A-&gt;B</p></li><li><p>(2) 将1个圆盘从A-&gt;C</p></li><li><p>(3) 将n-1个圆盘从B-&gt;C</p></li></ul><p>时间复杂度：<strong>T(n) &#x3D; O(2$^n$)</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 实现代码 </span></span><br><span class="line"></span><br><span class="line"><span class="comment">// n个圆盘Number ABC塔座String</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">hanoi</span>(<span class="params">n, A, B, C</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span>(n &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="title function_">hanoi</span>(n-<span class="number">1</span>, A, C, B);</span><br><span class="line">        <span class="title function_">move</span>(n, A, C);</span><br><span class="line">        <span class="title function_">hanoi</span>(n-<span class="number">1</span>, B, A, C);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">move</span>(<span class="params">n, a, c</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;move &#x27;</span> + n + <span class="string">&quot; from &quot;</span> + a + <span class="string">&#x27; to &#x27;</span> + c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>思考：四个柱子的汉诺塔问题？</p></blockquote><h2 id="算法——分治算法"><a href="#算法——分治算法" class="headerlink" title="算法——分治算法"></a>算法——分治算法</h2><p><strong>分治法的基本思想</strong>：</p><p>将一个难以直接解决的大问题，分割成一些规模较小的相同问题，以便各个击破，<strong>分</strong>而<strong>治</strong>之</p><ul><li><p>将待求解的较大规模的问题 <u>分割成k个更小规模的子问题</u></p></li><li><p>对这 <u>k个子问题分别求解</u></p></li><li><p>如果子问题的规模仍然不够小，则再划分为k个子问题，如此递归进行下去，直到问题规模足够小、很容易求出其解为止</p></li><li><p>将求出的小规模的问题的解合并为一个更大规模的问题的解，<font color=orange>自底向上</font>逐步求出原来问题的解</p></li></ul><p><strong>分治法的适用条件</strong>：</p><p>分治法所能解决的问题一般具有以下几个特征：</p><ul><li><ol><li>该问题的 <u>规模缩小到一定的程度就可以容易地解决</u></li></ol></li><li><ol start="2"><li>该问题可以分解为若干个规模较小的相同问题，即该问题具有<strong>最优子结构</strong>性质</li></ol></li><li><ol start="3"><li>利用该问题分解出的 <u>子问题的解可以合并为该问题的解</u>【如果具备了前两条特征，而不具备第三条特征，则可以考虑<strong>贪心算法或动态规划</strong>】</li></ol></li><li><ol start="4"><li>该问题所分解出的 <u>各个子问题是相互独立的</u>，即子问题之间不包含公共的子问题【重复地解公共的子问题用<strong>动态规划</strong>较好】</li></ol></li></ul><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 典型实例</span></span><br><span class="line"></span><br><span class="line">二分查找</span><br><span class="line">归并排序</span><br><span class="line">快速排序</span><br><span class="line"></span><br><span class="line">线性时间选择</span><br><span class="line">棋盘覆盖</span><br><span class="line">大整数乘法</span><br><span class="line">Strassen矩阵乘法</span><br></pre></td></tr></table></figure><p>分治法的<strong>时间复杂度</strong>：</p><p> 一个分治法将规模为n的问题 <font color=orange>分成a个规模为n&#x2F;b的子问题去解</font></p><p> 设阀值n$_0$&#x3D;1，且<font color=orange>adhoc解（直接可以求解）</font>规模为1的问题耗费1个单位时间</p><p> 设将原问题分解为a个子问题以及用merge将a个子问题的解<strong>合并</strong>为原问题的解需用f(n)个单位时间</p><p> 用T(n)表示该分治法解规模为|P|&#x3D;n的问题所需的计算时间，则有：<br>$$<br>T(n)&#x3D;<br>\begin{cases}<br>O(1) &amp;\quad n&#x3D;1 \<br>aT(n&#x2F;b)+f(n) &amp;\quad n&gt;1<br>\end{cases}<br>$$</p><p>递推求解得：</p><p>当f(n)为常数时，即f(n)&#x3D;c<br>$$<br>T(n)&#x3D;<br>\begin{cases}<br>O(n^{log_b a}) &amp;\quad a≠1 \<br>O(log_bn)&amp;\quad a&#x3D;1<br>\end{cases}<br>$$</p><p>当f(n)&#x3D;cn，c为常数时<br>$$<br>T(n)&#x3D;<br>\begin{cases}<br>O(n) &amp;\quad a&lt;b \<br>O(log_bn)&amp;\quad a&#x3D;b\<br>O(n^{log_b a}) &amp;\quad a&gt;b<br>\end{cases}<br>$$</p><h3 id="二分查找O-logn"><a href="#二分查找O-logn" class="headerlink" title="*二分查找O(logn)"></a>*二分查找O(logn)</h3><p>**二分查找(Binary Search)**又称为折半查找，它是一种高效的查找方法，但是二分查找要求<font color=orange>待查找列表中的<u>元素是有序</u>的</font>，是典型的分治算法实例之一。</p><p><strong>设计思路</strong>：</p><p> 设A[low..high]为当前查找区间，首先 <font color=orange>确定区间的中点位置mid&#x3D;⌊(low + high)&#x2F;2⌋；然后将待查的key值与A[mid]进行比较</font></p><ul><li><ol><li>若key&#x3D;&#x3D;A[mid]，则查找成功并返回该元素的下标</li></ol></li><li><ol start="2"><li>若key&lt;A[mid]，则查找左子表A[low..mid-1]</li></ol></li><li><ol start="3"><li>若key&gt;A[mid]，则查找右子表A[mid+1..high]</li></ol></li></ul><p> <font color=orange>对新的查找区间重复上述查找过程</font>，直到找到关键字为key的元素为止，或者满足当前查找空间为空（即查找失败）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 伪代码形式 </span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 1 非递归算法 BinarySearch(A[0...n-1], key)</span></span><br><span class="line"><span class="comment">//实现非递归的二分查找</span></span><br><span class="line"><span class="comment">//输入：一个升序数组A[0..n-1]和一个查找键key</span></span><br><span class="line"><span class="comment">//输出：一个数组元素的下标，该元素等于Key；如果没有找到，则返回-1</span></span><br><span class="line">low &lt;- <span class="number">0</span>, high -&gt; n-<span class="number">1</span></span><br><span class="line"><span class="keyword">while</span> low ≤ high</span><br><span class="line">mid &lt;- ⌊(low + high)/<span class="number">2</span>⌋</span><br><span class="line"><span class="keyword">if</span> key = A[mid] <span class="keyword">return</span> mid</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> key &lt; A[mid] high &lt;- mid - <span class="number">1</span></span><br><span class="line"><span class="keyword">else</span> low &lt;- mid + <span class="number">1</span></span><br><span class="line"><span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2 递归算法 BinarySearch(A[0...n-1], key, low, high)</span></span><br><span class="line"><span class="comment">//实现递归的二分查找</span></span><br><span class="line"><span class="comment">//输入：一个升序数组A[0..n-1]和一个查找键key</span></span><br><span class="line"><span class="comment">//输出：一个数组元素的下标，该元素等于Key；如果没有找到，则返回-1</span></span><br><span class="line"><span class="keyword">if</span> low&gt;high <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">mid &lt;- ⌊(low + high)/<span class="number">2</span>⌋</span><br><span class="line"><span class="keyword">if</span> key = A[mid] <span class="keyword">return</span> mid</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> key &lt; A[mid] <span class="keyword">return</span> <span class="title class_">BinarySearch</span>(A, key, low, mid-<span class="number">1</span>)</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">return</span> <span class="title class_">BinarySearch</span>(A, key, mid+<span class="number">1</span>, high)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>二分查找的时间复杂度</strong>：T(n)&#x3D;O(logn)</p><p>每执行一次while循环或一次迭代，<u>待搜索数组的大小将减少一半</u>。因此，在最坏情况下，程序被执行了<strong>O(logn)</strong> 次，循环体或递归函数内运算需要O(1) 时间，因此整个算法在最坏情况下的时间复杂度为O(logn) 。</p><h3 id="归并排序O-nlogn"><a href="#归并排序O-nlogn" class="headerlink" title="*归并排序O(nlogn)"></a>*归并排序O(nlogn)</h3><p><strong>基本思想</strong>：</p><p>将两个或两个以上的有序子序列“<strong>归并</strong>(Merge)”为一个有序序列。</p><p>在内部排序中，通常采用的是<strong>二路归并排序</strong>。即：将两个位置相邻的有序子序列归并为一个有序序列。</p><p><strong>算法原理</strong>：</p><p>假设初始序列含有n个记录，则可看成n个有序的子序列，每个子序列长度为1。然后两两归并，得到 <strong>[n&#x2F;2]</strong> 个长度为2或1的有序子序列；再两两归并，……如此重复，直至得到一个长度为n的有序序列为止。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 二路归并 Merge</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">Merge</span> <span class="params">(<span class="type">int</span> SR[ ], <span class="type">int</span> TR[ ], <span class="type">int</span> s, <span class="type">int</span> m, <span class="type">int</span> t )</span></span><br><span class="line">&#123; <span class="comment">/***将有序列SR[s..m]和SR[m+1..t]两路归并为TR[ ]***/</span></span><br><span class="line">    <span class="type">int</span> i=s, j=m+<span class="number">1</span>, k=s;</span><br><span class="line">    <span class="keyword">while</span> (i&lt;=m &amp;&amp; j&lt;=t) &#123; <span class="comment">//两序列中元素逐个比较</span></span><br><span class="line">        <span class="keyword">if</span> (SR[i]&lt;=SR[j]) TR[k++]=SR[i++];</span><br><span class="line">        <span class="keyword">else</span> TR[k++]=SR[j++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (i&lt;=m) TR[k++]=SR[i++]; <span class="comment">//前一个子序列剩下的</span></span><br><span class="line">    <span class="keyword">while</span> (j&lt;=t) TR[k++]=SR[j++]; <span class="comment">//后一个子序列剩下的</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 归并排序 MergeSort</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">MergeSort</span><span class="params">(<span class="type">int</span> SR[], <span class="type">int</span> s, <span class="type">int</span> t )</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (s &lt; t) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> (s+t)/<span class="number">2</span>; <span class="comment">// 将SR[s..t]分割</span></span><br><span class="line">        MergeSort(SR, s, m); <span class="comment">// 递归地排序子序列SR[s..m]</span></span><br><span class="line">        MergeSort(SR, m+<span class="number">1</span>, t); <span class="comment">//递归地排序子序列SR[m+1..t]</span></span><br><span class="line">        Merge(SR, TR, s, m, t); <span class="comment">//归并</span></span><br><span class="line">        Copy(TR, SR, s, t); </span><br><span class="line">        <span class="comment">//将数组TR复制回数组SR =&gt; for(int i=s;i&lt;=t;i++) SR[i] = TR[i];</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>归并排序的时间复杂度</strong>：<strong>T(n)&#x3D;O(nlogn)</strong></p><p>一趟归并操作是将r[1]~r[n]中相邻的长度为<em>h</em>的有序序列进行两两归并，这需要<em>O</em>(<em>n</em>)时间。整个归并排序需要进行log$_2$<em>n</em>趟，因此，时间复杂度为<em>O</em>(<em>n</em>log$_2$<em>n</em>)。</p><p><strong>归并排序的空间复杂度</strong>：O(n)</p><p>算法在执行时，需要占用与原始记录序列同样数量的存储空间，因此，空间复杂度为O(n)</p><blockquote><p>思考：k路归并排序???</p></blockquote><h3 id="快速排序O-nlogn"><a href="#快速排序O-nlogn" class="headerlink" title="*快速排序O(nlogn)"></a>*快速排序O(nlogn)</h3><p><strong>基本思想</strong>：</p><p>通过一趟排序将 <u>要排序的数据分割为独立的两部分</u>，其中一部分的所有数据比另一部分的所有数据小，再按这种方法对两部分数据分别进行快速排序，<u>整个排序过程可以递归进行</u>，使整个数据变成有序序列。</p><p>快排的基本步骤：</p><ul><li>从数组中选择一个元素作为基准</li><li>排序数组：比基准值小的放左边，大的放右边，这样每一次分割结束后基准值会插入到中间</li><li>利用递归，将摆放在左边的数组和右边的数组重复上述操作</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 分区函数：Partition(A,p,q) A代表数组 p起始下标 q结束下标</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">quickSort</span>(<span class="params">A, p=<span class="number">0</span>, q</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span>(A.<span class="property">length</span> &lt;= <span class="number">1</span>) &#123; <span class="keyword">return</span> A &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(p &lt; q) &#123;</span><br><span class="line">        <span class="keyword">let</span> r = <span class="title function_">partition</span>(A, p, q);</span><br><span class="line">        <span class="title function_">quickSort</span>(A, p, r-<span class="number">1</span>);</span><br><span class="line">        <span class="title function_">quickSort</span>(A, r+<span class="number">1</span>, q);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> A;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">exchange</span>(<span class="params">A, i, j</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> t = A[i];</span><br><span class="line">    A[i] = A[j];</span><br><span class="line">    A[j] = t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">partition</span>(<span class="params">A, p, q</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> x = A[p];</span><br><span class="line">    <span class="keyword">let</span> i = p;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> j = p+<span class="number">1</span>; j &lt;= q; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(A[j] &lt;= x) &#123;</span><br><span class="line">            i++;</span><br><span class="line">            <span class="title function_">exchange</span>(A, i, j);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">exchange</span>(A, p, i);</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>快排不同情况下的算法复杂度</strong></p><p>(1) 最坏情况：O(n^2^)</p><p>(2) 最好情况 &#x2F; 一般情况 &#x2F; 好坏交替：O(nlogn)</p><p><strong>算法改进</strong>：&#x3D;&gt; 【<u>随机化快速排序</u>】T(n) &#x3D; <strong>O(nlogn)</strong></p><ul><li><p>通过修改算法partition，可以设计出采用<strong>随机选择策略</strong>的快速排序算法</p></li><li><p>在A[p..q]中<font color=orange>随机选出一个元素作为划分基准</font></p></li><li><p>可以使划分基准的选择是随机的，从而可以期望划分是较对称的</p></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// RandomizedPartition (A, p , q) </span></span><br><span class="line"></span><br><span class="line">r &lt;- <span class="title function_">random</span>(p,q) <span class="comment">// [p,q]之间的随机数</span></span><br><span class="line">A[r] &lt;--&gt; A[p] <span class="comment">//随机值与第一个交换</span></span><br><span class="line">i &lt;- <span class="title class_">Partition</span>(A, p, q) </span><br><span class="line"><span class="keyword">return</span> i</span><br></pre></td></tr></table></figure><h3 id="线性时间选择O-n"><a href="#线性时间选择O-n" class="headerlink" title="线性时间选择O(n)"></a>线性时间选择O(n)</h3><p>问题：给定线性序集中<strong>n个元素</strong>和一个<strong>整数k</strong>，1≤k≤n，要求找<strong>出这n个元素中第k小（或第k大）的元素</strong></p><p>例如：2, 5, 6, 1, 8, 7, 9，请找出<strong>第2小</strong>的元素</p><p>排序后查找，T(n)&#x3D;O(nlogn)，能不能不排序？？？</p><p>• 快速排序的分区思想</p><p>• 统计比基准元素（例如以第1个为基准）小的元素个数，如果个数大于等于k，则第k最小元素在前半部分，否则在后半部分</p><p><strong>算法设计</strong>：</p><p>对于无序序列a[s..t]，在其中查找第k小的元素的过程：</p><p>• 若s&#x3D;t，即其中只有一个元素，返回a[s]</p><p>• 若s!&#x3D;t，表示该序列中有两个或两个以上元素，以基准为中心将其划分为a[s..i]和a[i+1..t]，<strong>a[s..i]中所有元素均小于等于a[i]，a[i+1..t]中所有元素均大于a[i]</strong></p><ul><li>j &#x3D; i-s+1，统计小于等于a[i]的元素个数</li><li>j&gt;&#x3D;k，第k小元素在a[s..i]中，递归在a[s..i]中寻找第k小元素</li><li>j &lt; k，第k小元素在a[i+1..t]中，递归在a[i+1..t]中寻找第k-j小元素</li></ul><p><img src="D:\PersonalData\Mango\NEW\Blog\Hexo-blog\blog-mango\source\images\article\算法\线性时间选择算法设计.png" alt="image-20230315170056006"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 线性时间选择的算法实现</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">quickSelect</span><span class="params">(<span class="type">int</span> a[], <span class="type">int</span> s, <span class="type">int</span> t, <span class="type">int</span> k)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (s==t) <span class="keyword">return</span> a[s];</span><br><span class="line">    <span class="type">int</span> i= partition(s,t),</span><br><span class="line">        j=i-s+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (k&lt;=j) <span class="keyword">return</span> quickSelect(a, s, i, k);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> quickSelect(a, i+<span class="number">1</span>, t, k-j); </span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 改进</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">randomizedSelect</span><span class="params">(<span class="type">int</span> a[], <span class="type">int</span> s, <span class="type">int</span> t, <span class="type">int</span> k)</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (s==t) <span class="keyword">return</span> a[s];</span><br><span class="line">    <span class="type">int</span> i=randomizedpartition(s,t),</span><br><span class="line">        j=i-s+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (k&lt;=j) <span class="keyword">return</span> randomizedSelect(a, s, i, k);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> randomizedSelect(a, i+<span class="number">1</span>, r, k-j);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="棋盘覆盖"><a href="#棋盘覆盖" class="headerlink" title="棋盘覆盖"></a>棋盘覆盖</h3><p>问题：</p><p>在一个2$^k$×2$^k$ 个方格组成的棋盘中，恰有一个方格与其他方格不同，称该方格为一特殊方格，且称该棋盘为一特殊棋盘。在棋盘覆盖问题中，要用以下4种不同形态的L型骨牌 <font color=orange>覆盖给定的特殊棋盘上除特殊方格以外的所有方格，且任何2个L型骨牌不得重叠覆盖</font>。</p><p><img src="D:\PersonalData\Mango\NEW\Blog\Hexo-blog\blog-mango\source\images\article\算法\棋盘覆盖骨牌.png" alt="image-20230315170846608"></p><p><strong>问题分析</strong>：</p><ul><li><p>当k&gt;0时，将2$^k$×2$^k$棋盘分割为4个2$^{k-1}$× 2$^{k-1}$子棋盘(a)所示</p></li><li><p>特殊方格必位于4个较小子棋盘之一中，其余3个子棋盘中无特殊方格，为了将这3个无特殊方格的子棋盘转化为特殊棋盘，<font color=orange>可以用一个L型骨牌覆盖这3个较小棋盘的会合处</font>，如 (b)所示</p></li><li><ul><li>将原问题转化为4个较小规模的棋盘覆盖问题</li></ul></li><li><ul><li>递归地使用这种分割，直至棋盘简化为棋盘1×1</li></ul></li></ul><p><img src="D:\PersonalData\Mango\NEW\Blog\Hexo-blog\blog-mango\source\images\article\算法\棋盘覆盖问题分析.png" alt="image-20230315171340222"></p><p><strong>算法设计</strong>：</p><ul><li><p>(1) 每次对分割后的四个小方块进行判断，判断特殊方格是否在其中</p></li><li><p>(2) 判断的方法是每次先记录下整个大方块的左上角方格的行列坐标，然后再与特殊方格坐标进行比较，就可以知道特殊方格是否在该块中</p></li><li><ul><li>如果特殊方块在其中，继续递归即可</li></ul></li><li><ul><li>如果不在，则根据分割的四个方块的不同位置，把右下角、左下角、右上角或者左上角的方格标记为特殊方块，然后继续递归</li></ul></li><li><p>在递归函数中，需要有一个变量s来记录边的方格数，每次对方块进行划分时，边的方格数都会减半，这个变量是为了方便判断特殊方格的位置</p></li></ul><p><strong>复杂度分析</strong>：<br>$$<br>T(k)&#x3D;<br>\begin{cases}<br>O(1) &amp; k&#x3D;0 \<br>4T(k-1)+O(1) &amp; k&gt;0<br>\end{cases}</p><p>\<br>\<br>T(n)&#x3D;O(4^k) 渐进意义下的最优算法<br>$$</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 棋盘覆盖算法实现</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">chessBoard</span><span class="params">(<span class="type">int</span> tr, <span class="type">int</span> tc, <span class="type">int</span> dr, <span class="type">int</span> dc, <span class="type">int</span> size)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (size == <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="type">int</span> t = tile++, <span class="comment">// L型骨牌号</span></span><br><span class="line">        s = size/<span class="number">2</span>; <span class="comment">// 分割棋盘</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 覆盖左上角子棋盘</span></span><br><span class="line">    <span class="keyword">if</span> (dr &lt; tr + s &amp;&amp; dc &lt; tc + s)</span><br><span class="line">        <span class="comment">// 特殊方格在此棋盘中</span></span><br><span class="line">        chessBoard(tr, tc, dr, dc, s);</span><br><span class="line">    <span class="keyword">else</span> &#123;<span class="comment">// 此棋盘中无特殊方格</span></span><br><span class="line">        <span class="comment">// 用 t 号L型骨牌覆盖右下角</span></span><br><span class="line">        board[tr + s - <span class="number">1</span>][tc + s - <span class="number">1</span>] = t;</span><br><span class="line">        <span class="comment">// 覆盖其余方格</span></span><br><span class="line">        chessBoard(tr, tc, tr+s<span class="number">-1</span>, tc+s<span class="number">-1</span>, s);&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 覆盖右上角子棋盘</span></span><br><span class="line">    <span class="keyword">if</span> (dr &lt; tr + s &amp;&amp; dc &gt;= tc + s)</span><br><span class="line">        <span class="comment">// 特殊方格在此棋盘中</span></span><br><span class="line">        chessBoard(tr, tc+s, dr, dc, s);</span><br><span class="line">    <span class="keyword">else</span> &#123;<span class="comment">// 此棋盘中无特殊方格</span></span><br><span class="line">        <span class="comment">// 用 t 号L型骨牌覆盖左下角</span></span><br><span class="line">        board[tr + s - <span class="number">1</span>][tc + s] = t;</span><br><span class="line">        <span class="comment">// 覆盖其余方格</span></span><br><span class="line">        chessBoard(tr, tc+s, tr+s<span class="number">-1</span>, tc+s, s);&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 覆盖左下角子棋盘</span></span><br><span class="line">    <span class="keyword">if</span> (dr &gt;= tr + s &amp;&amp; dc &lt; tc + s)</span><br><span class="line">        <span class="comment">// 特殊方格在此棋盘中</span></span><br><span class="line">        chessBoard(tr+s, tc, dr, dc, s);</span><br><span class="line">    <span class="keyword">else</span> &#123;<span class="comment">// 用 t 号L型骨牌覆盖右上角</span></span><br><span class="line">        board[tr + s][tc + s - <span class="number">1</span>] = t;</span><br><span class="line">        <span class="comment">// 覆盖其余方格</span></span><br><span class="line">        chessBoard(tr+s, tc, tr+s, tc+s<span class="number">-1</span>, s);&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 覆盖右下角子棋盘</span></span><br><span class="line">    <span class="keyword">if</span> (dr &gt;= tr + s &amp;&amp; dc &gt;= tc + s)</span><br><span class="line">        <span class="comment">// 特殊方格在此棋盘中</span></span><br><span class="line">        chessBoard(tr+s, tc+s, dr, dc, s);</span><br><span class="line">    <span class="keyword">else</span> &#123;<span class="comment">// 用 t 号L型骨牌覆盖左上角</span></span><br><span class="line">        board[tr + s][tc + s] = t;</span><br><span class="line">        <span class="comment">// 覆盖其余方格</span></span><br><span class="line">        chessBoard(tr+s, tc+s, tr+s, tc+s, s);&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="大整数乘法"><a href="#大整数乘法" class="headerlink" title="大整数乘法"></a>大整数乘法</h3><p>问题：请设计一个有效的算法，可以进行两个n位大整数的乘法运算</p><h3 id="Strassen矩阵乘法"><a href="#Strassen矩阵乘法" class="headerlink" title="Strassen矩阵乘法"></a><strong>Strassen矩阵乘法</strong></h3><h2 id="算法——动态规划【最优子结构-重叠子问题】"><a href="#算法——动态规划【最优子结构-重叠子问题】" class="headerlink" title="算法——动态规划【最优子结构+重叠子问题】"></a>算法——动态规划【最优子结构+重叠子问题】</h2><h3 id="数字三角形"><a href="#数字三角形" class="headerlink" title="数字三角形"></a><strong>数字三角形</strong></h3><img src="D:\PersonalData\Mango\NEW\Blog\Hexo-blog\blog-mango\source\images\article\算法\dp-小兔子的难题.png" alt="image-20230315172851434" style="zoom:80%;" /><p><strong>经典递归解法</strong> <strong>T(n) &#x3D; O(2$^n$)</strong></p><ul><li><p>计算从第一层到最后一层的所有路径和，然后取最大值</p></li><li><p>二叉树，从顶点到第二层有2条路径，到第三层有4条路径，到第四层有8条路径，到第五层有16条路径，……</p></li><li><p>从顶点到最后一层一共有<strong>2$^{n-1}$条路径</strong></p></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a[<span class="number">110</span>][<span class="number">110</span>],n;</span><br><span class="line"><span class="type">int</span> <span class="title function_">solve</span><span class="params">(<span class="type">int</span> i,<span class="type">int</span> j)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(i==n+<span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> a[i][j]+max(solve(i+<span class="number">1</span>,j),solve(i+<span class="number">1</span>,j+<span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line">……</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,solve(<span class="number">1</span>,<span class="number">1</span>)); <span class="comment">//(1,1)到最后一层的最大路径和</span></span><br></pre></td></tr></table></figure><p><strong>记忆化搜索(备忘录法)</strong></p><img src="D:\PersonalData\Mango\NEW\Blog\Hexo-blog\blog-mango\source\images\article\算法\dp-数字三角形备忘录.png" alt="image-20230315173649153" style="zoom:70%;" /><ul><li>设(i, j)到达最后一层的最大路径和为p[i][j]【很多人将其取名为**dp[i][j]**】</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> p[<span class="number">105</span>][<span class="number">105</span>],a[<span class="number">105</span>][<span class="number">105</span>],n;</span><br><span class="line"><span class="type">int</span> <span class="title function_">solve</span><span class="params">(<span class="type">int</span> i,<span class="type">int</span> j)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(p[i][j]&gt;=<span class="number">0</span>) <span class="keyword">return</span> p[i][j]; <span class="comment">//引入备忘录保存子问题的解</span></span><br><span class="line">    <span class="keyword">if</span>(i==n+<span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> p[i][j]=a[i][j]+max(solve(i+<span class="number">1</span>,j),solve(i+<span class="number">1</span>,j+<span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line">……</span><br><span class="line"><span class="built_in">memset</span>(p,<span class="number">-1</span>,<span class="keyword">sizeof</span>(p)); <span class="comment">//初始化备忘录</span></span><br><span class="line">solve(<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line"><span class="built_in">printf</span>(“%d\n”,p[<span class="number">1</span>][<span class="number">1</span>]); <span class="comment">//p[1][1]即为所求解</span></span><br></pre></td></tr></table></figure><p><strong>动态规划法</strong></p><p><strong>思路一</strong>：<strong>T(n) &#x3D; O(n$^2$)</strong></p><p>p[i][j]表示(i, j)的达到最后一层的最大路径和，那么p[i][j]的最优解包含了子问题p[i+1][j]或p[i+1][j+1]的最优解</p><p>状态转移方程（递归方程）：<br>$$<br>p[i][j]&#x3D;<br>\begin{cases}<br>a[i][j] &amp; i&#x3D;n \<br>max{  p[i+1][j],p[i+1][j+1]} + a[i][j] &amp; 1\leq i&lt;n<br>\end{cases}</p><p>\<br>result &#x3D; p[1][1]<br>$$<br><img src="D:\PersonalData\Mango\NEW\Blog\Hexo-blog\blog-mango\source\images\article\算法\dp-数字三角形动态规划法1.png" alt="image-20230315175020780" style="zoom:80%;" /></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> p[<span class="number">105</span>][<span class="number">105</span>],a[<span class="number">105</span>][<span class="number">105</span>],n;</span><br><span class="line"><span class="type">int</span> <span class="title function_">solve</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++) p[n][j]=a[n][j];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=n<span class="number">-1</span>;i&gt;=<span class="number">1</span>;i--) <span class="comment">//自底向上DP</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=i;j++)<span class="comment">//对行遍历</span></span><br><span class="line">            p[i][j]=a[i][j]+max(p[i+<span class="number">1</span>][j],p[i+<span class="number">1</span>][j+<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line">……</span><br><span class="line">solve();</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,p[<span class="number">1</span>][<span class="number">1</span>]);</span><br></pre></td></tr></table></figure><p><strong>思路二</strong>：</p><p>p[i][j]表示从(1,1)到达(i, j) 的最大路径和，那么p[i][j]的最优解包含了子问题p[i-1][j-1]或p[i-1][j]的最优解</p><p>状态转移方程（递归方程）：<br>$$<br>p[i][j]&#x3D;<br>\begin{cases}<br>a[1][1] &amp; i&#x3D;1 \<br>max{  p[i-1][j-1],p[i-1][j]} + a[i][j] &amp; 1&lt; i\leq n<br>\end{cases}</p><p>\<br>result &#x3D; max {p[n][j]}<br>$$<br><img src="D:\PersonalData\Mango\NEW\Blog\Hexo-blog\blog-mango\source\images\article\算法\dp-数字三角形动态规划法2.png" alt="image-20230315175607613" style="zoom:80%;" /></p><hr><p>&#x3D;&#x3D;动态规划（Dynamic Programming, DP）&#x3D;&#x3D;</p><p><strong>总体思想</strong></p><ul><li><p>动态规划算法与分治法类似，其基本思想也是 <strong>将待求解问题分解成若干个子问题</strong></p></li><li><p>经分解得到的<strong>子问题往往不是互相独立</strong>的，有些子问题被重复计算多次</p></li><li><p>如果能够<strong>保存已解决的子问题的答案</strong>，而在需要时再找出已求得的答案，就可以<u>避免大量重复计算</u>，从而得到<u>多项式时间算法</u></p></li></ul><p><strong>基本步骤</strong>：</p><p><img src="D:\PersonalData\Mango\NEW\Blog\Hexo-blog\blog-mango\source\images\article\算法\dp-基本步骤.png" alt="image-20230315180351822"></p><p><strong>基本要素</strong>：</p><table><thead><tr><th>最优子结构</th><th>重叠子问题</th></tr></thead><tbody><tr><td>一个问题的最优解包含着其子问题的最优解，这种性质称为<font color=orange>最优子结构性质</font></td><td>递归算法求解问题时，每次产生的子问题并不总是新问题，有些子问题被反复计算多次，这种性质称为<font color=orange>子问题的重叠性质</font></td></tr><tr><td>分析问题的最优子结构性质：首先<font color=orange>假设由问题的最优解导出的子问题的解不是最优的，然后再设法说明在这个假设下可构造出比原问题最优解更好的解，从而导致矛盾</font></td><td>动态规划算法，对每一个子问题只解一次，而后<font color=orange>将其解保存在一个表格中</font>，当再次需要解此子问题时，只是简单地<font color=orange>用常数时间查看一下结果</font></td></tr><tr><td>利用问题的最优子结构性质，以<strong>自底向上</strong>的方式递归地从子问题的最优解逐步构造出整个问题的最优解</td><td>通常不同的子问题个数随问题的大小呈多项式增长，用动态规划算法只需要多项式时间，从而获得较高的解题效率</td></tr><tr><td>最优子结构是一个问题能用动态规划算法求解的前提</td><td></td></tr></tbody></table><p><strong>备忘录法</strong>：</p><ul><li><p>记忆化搜索</p></li><li><p>备忘录方法的控制结构与直接递归方法的控制结构相同</p></li><li><p>区别在于备忘录方法为每个解过的子问题建立了备忘录以备需要时查看，避免相同子问题的重复求解</p></li><li><p>查表法</p></li></ul><img src="D:\PersonalData\Mango\NEW\Blog\Hexo-blog\blog-mango\source\images\article\算法\dp-递归问题整体结构.png" alt="image-20230315181036987" style="zoom: 67%;" /><h3 id="矩阵连乘O-n-3"><a href="#矩阵连乘O-n-3" class="headerlink" title="矩阵连乘O(n$^3$)"></a>矩阵连乘O(n$^3$)</h3><p><strong>完全加括号的矩阵连乘积</strong>：</p><p>完全加括号的矩阵连乘积可递归地定义为：</p><p>• <font color=orange>单个矩阵是完全加括号的</font></p><p>• 矩阵连乘积A是完全加括号的，则<font color=orange>A可表示为2个完全加括号的矩阵连乘积B和C的乘积并加括号，即A&#x3D;(BC)</font></p><img src="D:\PersonalData\Mango\NEW\Blog\Hexo-blog\blog-mango\source\images\article\算法\dp-矩阵连乘-完全加括号的矩阵连乘积.png" alt="image-20230316015248789" style="zoom: 80%;" /><blockquote><p>矩阵A和B可乘的条件： 矩阵A的列数等于矩阵B的行数。</p><p>设A是<strong>p×q</strong>的矩阵, B是<strong>q×r</strong>的矩阵, 乘积是<strong>p×r</strong>的矩阵;计算量是 <strong>pqr</strong>。</p><p>完全加括号方式的计算工作量的计算【以(A((BC)D))为例】:<br>(A((BC)D))可拆解为下面的步骤来计算工作量<br>BC: 10×40×30 &#x3D; 12000,<br>(BC)D: 10×30×5 &#x3D; 1500,<br>(A((BC)D)): 50×10×5 &#x3D; 2500  &#x3D;&gt; 12000 + 1500 + 2500 &#x3D; 16000</p></blockquote><p><strong>矩阵连乘问题</strong></p><p>给定n个矩阵{A$_1$,A$_2$,…,A$_n$} ，其中A$<em>i$与A$</em>{i+1}$是可乘的，i&#x3D;1,2,…,n-1，考察n个矩阵的连乘积 A$_1$A$_2$…A$_n$，如何确定计算矩阵连乘积的计算次序，使得依此次序计算矩阵连乘积 <font color=orange>需要的数乘次数最少</font></p><ul><li><p><font color=orange>矩阵乘法满足结合律</font>-&gt;计算矩阵的连乘可以有许多不同的计算次序-&gt;计算次序可以用<u>加括号的方式</u>来确定</p></li><li><p>若一个矩阵连乘积的计算次序完全确定（该连乘积已完全加括号）-&gt;可依此次序<font color=orange>反复调用2个矩阵相乘的标准算法</font>计算出矩阵连乘积</p></li></ul><p>&#x3D;&#x3D;穷举法&#x3D;&#x3D;</p><p>列举出所有可能的计算次序，并计算出每一种计算次序相应需要的数乘次数，从中找出一种数乘次数最少的计算次序</p><p><img src="D:\PersonalData\Mango\NEW\Blog\Hexo-blog\blog-mango\source\images\article\算法\dp-矩阵连乘-穷举.png" alt="image-20230316015628342"></p><p>&#x3D;&#x3D;动态规划法&#x3D;&#x3D;</p><p>将矩阵连乘积 A$<em>i$A$</em>{i+1}$…A$_j$ 简记为<strong>A[i:j]</strong> ，i≤j</p><p>考察计算A[i:j]的最优计算次序：设这个计算次序在矩阵A$<em>k$和A$</em>{k+1}$之间将矩阵链断开，i≤k&lt;j，则其相应完全加括号方式为 <strong>(A$<em>i$A$</em>{i+1}$…A$<em>k$ )(A$</em>{k+1}$A$_{k+2}$…A$_j$)</strong></p><p><u>计算量</u>：<strong>A[i:k]的计算量</strong>加上<strong>A[k+1:j]的计算量</strong>，再加上<strong>A[i:k]和A[k+1:j]相乘的计算量</strong>（三部分组成）</p><p><u>分析最优解的结构</u></p><p>• 特征：计算A[i:j]的最优次序所 <u>包含的计算矩阵子链 A[i:k]和A[k+1:j]的次序也是最优的</u></p><p>• 矩阵连乘计算次序问题的最优解包含着其子问题的最优解 -&gt; <font color=grgreen>最优子结构</font></p><p>• 问题的最优子结构性质是该问题可用动态规划算法求解的显著特征</p><p>**<u>建立递归关系</u>**：</p><p>• 计算A[i:j]，1≤i≤j≤n，<font color=orange>所需要的最少数乘次数m[i,j]</font>，则原问题的最优值为m[1,n] </p><p>• 当i&#x3D;j时，A[i:j]&#x3D;A$_i$ ，因此，m[i,i]&#x3D;0，i&#x3D;1,2,…,n</p><p>• 当i&lt;j时，<br>$$<br>m[i,j]&#x3D; m[i,k] + m[k+1,j] + p_{i-1}p_kp_j<br>$$<br>• A$<em>i$ 的维数为 p$</em>{i-1}$ × p$_k$    <strong>k的位置只有j-1种可能</strong></p><p>• 可以递归地定义m[i,j]为：<br>$$<br>m[i][j]&#x3D;<br>\begin{cases}<br>0 &amp; i&#x3D;j \<br>min { m[i,k]+m[k+1,j]+p_{i-1}p_kp_j } &amp; i&lt;j; {i \leq k&lt;j}<br>\end{cases}<br>$$<br><strong>计算最优值</strong>：</p><p>• 对于1≤i≤j≤n不同的有序对(i,j)对应于不同的子问题。不同子问题的个数最多只有：<br>$$<br>\left(<br>\begin{matrix}<br>2\<br>n\<br>\end{matrix}<br>\right)<br>+n&#x3D;\Theta(n^2)<br>$$<br>• 在递归计算时，许多子问题被重复计算多次 -&gt; <font color=grgreen>重叠子问题</font></p><p>• 用动态规划算法解此问题，可依据其递归式以 <strong>自底向上</strong> 的方式进行计算</p><p>• 在计算过程中，<strong>保存已解决的子问题答案</strong></p><p>• 每个子问题只计算一次，而在后面需要时只要简单查一下，从而避免大量的重复计算，最终得到多项式时间的算法</p><img src="D:\PersonalData\Mango\NEW\Blog\Hexo-blog\blog-mango\source\images\article\算法\dp-矩阵连乘-求最优解.png" alt="image-20230316022511310" style="zoom:80%;" /><p><strong>算法复杂度</strong>分析：</p><p>主要计算量取决于算法中对r，i和k的3重循环。循环体内的计算量为O(1)，而3重循环的总次数为O(n$^3$)。因</p><p>此<strong>算法的计算时间上界为O(n$^3$)。算法所占用的空间显然为O(n$^2$)。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">matrixChain</span><span class="params">(<span class="type">int</span> [] p, <span class="type">int</span> [][] m, <span class="type">int</span> [][] s)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> n=p.length-<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n; i++) m[i][i] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> <span class="number">2</span>; r &lt;= n; r++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n - r+<span class="number">1</span>; i++) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> j=i+r-<span class="number">1</span>;</span><br><span class="line">            m[i][j] = m[i+<span class="number">1</span>][j]+ p[i-<span class="number">1</span>]*p[i]*p[j];</span><br><span class="line">            s[i][j] = i;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> i+<span class="number">1</span>; k &lt; j; k++) </span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">t</span> <span class="operator">=</span> m[i][k] + m[k+<span class="number">1</span>][j] + p[i-<span class="number">1</span>]*p[k]*p[j];</span><br><span class="line">                <span class="keyword">if</span> (t &lt; m[i][j]) </span><br><span class="line">                &#123;</span><br><span class="line">                    m[i][j] = t;</span><br><span class="line">                    s[i][j] = k; &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>构造最优解</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//回溯构造最优解</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">traceback</span><span class="params">(<span class="type">int</span> [][] s, <span class="type">int</span> i, <span class="type">int</span> j)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(i==j) <span class="keyword">return</span>;</span><br><span class="line">    traceback(s, i, s[i][j]);</span><br><span class="line">    traceback(s, s[i][j]+<span class="number">1</span>, j);</span><br><span class="line">    System.out.println(“Multiply A” + i + “,“ + s[i][j] + “ and A “ + (s[i][j]</span><br><span class="line">+ <span class="number">1</span>) + “,“ + j);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 备忘录法</span></span><br><span class="line">m&lt;-<span class="number">0</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">lookupChain</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (m[i][j] &gt; <span class="number">0</span>) <span class="keyword">return</span> m[i][j];</span><br><span class="line">    <span class="keyword">if</span> (i == j) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">u</span> <span class="operator">=</span> lookupChain(i+<span class="number">1</span>,j) + p[i-<span class="number">1</span>]*p[i]*p[j];</span><br><span class="line">    s[i][j] = i;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> i+<span class="number">1</span>; k &lt; j; k++) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">t</span> <span class="operator">=</span> lookupChain(i,k) + lookupChain(k+<span class="number">1</span>,j) + p[i-<span class="number">1</span>]*p[k]*p[j];</span><br><span class="line">        <span class="keyword">if</span> (t &lt; u) &#123; u = t; s[i][j] = k; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    m[i][j] = u;</span><br><span class="line">    <span class="keyword">return</span> u;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="LCS最长公共子序列O-mn"><a href="#LCS最长公共子序列O-mn" class="headerlink" title="LCS最长公共子序列O(mn)"></a>LCS最长公共子序列O(mn)</h3><p><strong>基本定义</strong>：</p><p>一个给定序列的 <u>子序列</u> 是在该序列中删去若干元素后得到的序列</p><p>给定2个序列X和Y，当另一序列Z既是X的子序列又是Y的子序列时，称Z是序列X和Y的 <strong>公共子序列</strong></p><p>公共子序列中长度最长的公共子序列叫做<strong>最长公共子序列</strong></p><p>最长公共子序列(Longest Common Subsequence, <code>LCS</code>)问题可以叙述为：</p><p>• 给定2个序列X&#x3D;{x$_1$，…，x$_m$}和Y&#x3D;{y$_1$，…，y$_n$}，要求找出X和Y的一个最长公共子序列</p><p><strong>算法详解</strong>：</p><p>&#x3D;&#x3D;穷举搜索&#x3D;&#x3D; T(n)&#x3D;O(n$\bullet$2$^m$)</p><p> 对X的每一个子序列，检查它是否也是Y的子序列，即是否为X和Y的公共子序列</p><p> 在检查过程中遴选出最长的公共子序列</p><p> X的所有子序列都检查过后即可求出X和Y的最长公共子序列</p><p> X的一个子序列相应于下标序列{1，2，…，m}的一个子序列，故X共有<strong>2$^m$个</strong>不同子序列</p><p> 穷举搜索法需要<u>指数时间</u></p><p>&#x3D;&#x3D;动态规划&#x3D;&#x3D;</p><p><strong>状态表示</strong>：<font color=grblue>用C[i,j]记录序列X(i)和Y(j)的最长公共子序列的长度</font>，其中X(i)&#x3D;{x$_1$，…，x$_i$ }, Y(j)&#x3D;{y$_1$，…，y$_j$ }。<font color=grblue>原问题最优解的长度为C[m,n]</font>。</p><p><strong>最优子结构性质</strong>：设序列X&#x3D;{x$_1$，…，x$_m$}和Y&#x3D;{y$_1$，…，y$_n$}的一个最长公共子序列为Z&#x3D;{z$_1$，…，z$_k$}，则下述结论成立：</p><p>• (1) 若<font color=grblue>x$_m$ &#x3D; y$_n$</font>，则z$_k$ &#x3D; x$_m$ &#x3D; y$_n$ 且Z(k-1) &#x3D; {z$<em>1$，…，z$</em>{k-1}$}是X(m-1)和Y(n-1)的最长公共子序列</p><p>• (2) 若<font color=grblue>x$_m$  ≠ y$_n$ 且 z$_k$ ≠ x$_m$</font>，则Z是X(m-1)和Y的最长公共子序列</p><p>• (3) 若<font color=grblue>x$_m$  ≠ y$_n$ 且 z$_k$ ≠ y$_n$</font>，则Z是X和Y(n-1)的最长公共子序列</p><p><strong>结论</strong>：</p><ul><li><p><font color=blue>2个序列的最长公共子序列包含了这2个序列前缀的最长公共子序列</font></p></li><li><p>最长公共子序列问题具有 <strong><u>最优子结构性质</u></strong></p></li></ul><p>由最长公共子序列问题的最优子结构性质可知，要找出X&#x3D;{x$_1$，…，x$_m$}和Y&#x3D;{y$_1$，…，y$_n$}的一个最长公共子序列，可按以下方式递归地进行：</p><p>• 当 <strong>x$_m$ &#x3D; y$_n$</strong> 时，找出<strong>X(m-1)和Y(n-1)的最长公共子序列</strong>，然后在其**尾部加上x$_m$(&#x3D;y$_n$)**即可得X和Y的一个最长公共子序列</p><p>• 当 <strong>x$_m$ ≠ y$_n$</strong> 时，必须解2个子问题，即找出<strong>X(m-1)和Y的一个最长公共子序列</strong>及<strong>X和Y(n-1)的一个最长公共子序列</strong>。这2个公共子序列中较长者即为X和Y的一个最长公共子序列</p><p><strong>建立子问题的最优值C[i, j]的递归关系</strong>，递归方程如下： </p><p>由此递归方程容易看到最长公共子序列问题具有 <strong><u>重叠子问题性质</u></strong><br>$$<br>c[i][j]&#x3D;<br>\begin{cases}<br>0 &amp; i&#x3D;0,j&#x3D;0 \<br>c[i-1][j-1]+1 &amp; i,j&gt;0;x_i&#x3D;y_j \<br>max{c[i][j-1],c[i-1][j]} &amp; i,j&gt;0;x_i\neq y_j<br>\end{cases}<br>$$</p><p><strong>递归实现 【不考虑重叠子问题】</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">LCS(x, y, i, j)</span><br><span class="line"><span class="keyword">if</span> x[i] = y[j]</span><br><span class="line">then c[i, j] &lt;- LCS(x, y, i<span class="number">-1</span>, j<span class="number">-1</span>) + <span class="number">1</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">c[i, j] &lt;- max&#123;LCS(x, y, i<span class="number">-1</span>, j), LCS(x, y, i, j<span class="number">-1</span>)&#125;</span><br><span class="line"><span class="keyword">return</span> c[i, j]</span><br></pre></td></tr></table></figure><img src="D:\PersonalData\Mango\NEW\Blog\Hexo-blog\blog-mango\source\images\article\算法\dp-最长公共子序列递归树.png" alt="image-20230315224732653" style="zoom:80%;" /><p><strong>备忘录法</strong>【增加一个判断语句，自顶向下】<strong>T(n) &#x3D; O(m*n)</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">LCS(x, y, i, j)</span><br><span class="line"><span class="keyword">if</span> c[i, j] = null</span><br><span class="line">then <span class="keyword">if</span> x[i] = y[j]</span><br><span class="line">then c[i, j] &lt;- LCS(x, y, i<span class="number">-1</span>, j<span class="number">-1</span>) + <span class="number">1</span></span><br><span class="line"><span class="keyword">else</span> c[i, j] &lt;- max&#123;LCS(x, y, i<span class="number">-1</span>, j), LCS(x, y, i, j<span class="number">-1</span>)&#125;</span><br><span class="line"><span class="keyword">return</span> c[i, j]</span><br></pre></td></tr></table></figure><p><strong>动态规划法</strong>【自底向上】<strong>T(n) &#x3D; O(m*n)</strong></p><p>根据上面的递归方程绘制表格（制表法）如下：</p><p>逐个排查，自上而下填表，当末尾字母相同即x$_i$&#x3D;y$_j$ 时，填入c[i-1][j-1]+1结果，即斜对角结果+1；当末尾字母不同时，则选择左侧和顶部结果最大的那一个，依次填入即可绘制全表。</p><p><img src="D:\PersonalData\Mango\NEW\Blog\Hexo-blog\blog-mango\source\images\article\算法\dp-最长公共子序列制表.png" alt="image-20230315233216549"></p><p> <strong>T(n) &#x3D; O(m*n)</strong>  <strong>S(n) &#x3D; O(m*n)</strong></p><ul><li>计算最优值</li><li>构造最优解</li><li>构造最长公共子序列</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">Algorithm <span class="title function_">lcsLength</span><span class="params">(x,y,b)</span></span><br><span class="line">m&lt;-x.length-<span class="number">1</span>;</span><br><span class="line">n&lt;-y.length-<span class="number">1</span>;</span><br><span class="line">c[i][<span class="number">0</span>]=<span class="number">0</span>; c[<span class="number">0</span>][i]=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= n; j++) </span><br><span class="line"><span class="keyword">if</span> (x[i]==y[j]) </span><br><span class="line">c[i][j]=c[i-<span class="number">1</span>][j-<span class="number">1</span>]+<span class="number">1</span>;</span><br><span class="line">b[i][j]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (c[i-<span class="number">1</span>][j]&gt;=c[i][j-<span class="number">1</span>]) </span><br><span class="line"> c[i][j]=c[i-<span class="number">1</span>][j];</span><br><span class="line"> b[i][j]=<span class="number">2</span>;</span><br><span class="line"> <span class="keyword">else</span> </span><br><span class="line"> c[i][j]=c[i][j-<span class="number">1</span>];</span><br><span class="line"> b[i][j]=<span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">Algorithm <span class="title function_">lcs</span><span class="params">(<span class="type">int</span> i,<span class="type">int</span> j,<span class="type">char</span> [] x,<span class="type">int</span> [][] b)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (i ==<span class="number">0</span> || j==<span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">if</span> (b[i][j]== <span class="number">1</span>)&#123;</span><br><span class="line">lcs(i-<span class="number">1</span>,j-<span class="number">1</span>,x,b);</span><br><span class="line">System.out.print(x[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (b[i][j]== <span class="number">2</span>) lcs(i-<span class="number">1</span>,j,x,b);</span><br><span class="line"><span class="keyword">else</span> lcs(i,j-<span class="number">1</span>,x,b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>改进(1)：</strong>在算法lcsLength和lcs中，可进一步将数组b省去。<font color=grblue>对于给定的数组元素c[i][j]，可以不借助数组b而仅借助c本身确定 c[i][j]的值是由c[i-1][j-1]，c[i-1][j]和c[i][j-1]中哪一个值所确定的</font>。</p><p><strong>改进(2)：</strong>如果只需要计算最长公共子序列的长度，则算法的空间需求可大大减少。<font color=grblue>在计算c[i][j]时，只用到数组c的第i行和第i-1行</font>。用2行的数组空间就可以计算出最长公共子序列的长度，可将空间需求减至<font color=grblue>O(min(m,n))</font>。</p><h3 id="最大子段和O-n"><a href="#最大子段和O-n" class="headerlink" title="最大子段和O(n)"></a>最大子段和O(n)</h3><p>问题：给定n个整数（可能是负数）组成的序列a[1], a[2], a[3], …, a[n]，求该序列的子段和，例如a[i]+a[i+1]+…+a[j]的最大值。</p><p>当所给的整数均为负数时定义子段和为0，依此定义，所求的最优值为：<font color=orange>max{0, a[i]+a[i+1]+…+a[j]}</font>, 1&lt;&#x3D;i&lt;&#x3D;j&lt;&#x3D;n </p><p> 例如，当（a[1],a[2],a[3],a[4],a[5],a[6]）&#x3D;(-2,11,-4,13,-5,-2)时，最大子段和为20，即 20 &#x3D; 11 + (-4) + 13。</p><p><strong>算法设计</strong>：</p><p><strong>算法1</strong>：<strong>穷举法</strong> ，对所有的(i,j)对，顺序求和a[i]+…+a[j]并比较出最大的和</p><p>以a$_1$开始：{a$_1$}, {a$_1$,a$_2$}, {a$_1$,a$_2$,a$_3$}……{a$_1$,……a$_n$}，共n个</p><p>以a$_2$开始：{a$_2$}, {a$_2$,a$_3$}, {a$_2$,a$_3$,a$_4$}……{a$_2$,……a$_n$}，共n-1个</p><p>…… 以a$_n$开始：{a$_n$}，共1个</p><p>一共(n+1)*n&#x2F;2个连续子段</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 穷举法 T(n) = O(n^3)</span></span><br><span class="line"><span class="type">int</span> a[<span class="number">105</span>], n, maxSum=<span class="number">0</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">solve</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=i; j&lt;n; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> T=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k=i; k&lt;=j; k++)</span><br><span class="line">                T+=a[k];</span><br><span class="line">            <span class="keyword">if</span> (T&gt;maxSum)</span><br><span class="line">            &#123;</span><br><span class="line">                maxSum=T;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    solve();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,maxSum);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**************************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 穷举法 改进 T(n) = O(n^2)</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">solve</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> T=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=i; j&lt;n; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            T+=a[j];</span><br><span class="line">            <span class="keyword">if</span>(T&gt;maxSum)</span><br><span class="line">            &#123;</span><br><span class="line">                maxSum=T;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>算法2</strong>：<strong>分治法</strong> **T(n)&#x3D;O(nlogn)**，将数组分成左右两半，分别计算左边的最大和、右边的最大和、跨边界的最大和，然后比较其中最大者</p><p>将序列a[1:n] 分为长度相等的两段：a[1: n&#x2F;2]和a[n&#x2F;2+1: n]</p><p>分别求出这两段的最大子段和，则a[1:n] 的最大子段和有三种情形：</p><p>• (1) a[1:n]的最大子段和与a[1: n&#x2F;2]的最大子段和相同【在前半部分】</p><p>• (2) a[1:n] 的最大子段和与a[n&#x2F;2+1: n]的最大子段和相同【在后半部分】</p><p>• (3) a[1:n] 的最大子段和为ai +ai+1+…+aj 【在中间部分】</p><p>其中，1≤i ≤ n&#x2F;2，n&#x2F;2+1 ≤ j ≤ n </p><p>情形(1)和(2)可递归求得，情形(3)一定包括元素a[n&#x2F;2]和a[n&#x2F;2+1]</p><p> 在a[1: n&#x2F;2]中，求<strong>s1&#x3D;max{a$<em>i$ +a$</em>{i+1}$+…+a$_{n&#x2F;2}$}</strong>，i&#x3D;1,2,…..,n&#x2F;2</p><p> 在a[n&#x2F;2+1: n]中，求**s2&#x3D;max {a$_{n&#x2F;2+1}$+…+a$_j$ }**，j&#x3D;n&#x2F;2+1, ……,n</p><p> 则s1+s2 即为情形(3)时的最大值<br>$$<br>T(n)&#x3D;<br>\begin{cases}<br>O(1) &amp; n\leq 0 \<br>2T(n&#x2F;2)+O(n) &amp; n&gt;0<br>\end{cases}<br>$$</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a[<span class="number">105</span>], n, maxSum=<span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">solve</span><span class="params">(<span class="type">int</span> a[], <span class="type">int</span> left, <span class="type">int</span> right)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(left==right) </span><br><span class="line">        maxSum=(a[left]&gt;<span class="number">0</span>?a[left]:<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> mid=(left+right)/<span class="number">2</span>;</span><br><span class="line">        <span class="type">int</span> leftSum=solve(a, left, mid);</span><br><span class="line">        <span class="type">int</span> rightSum=solve(a, mid+<span class="number">1</span>, right);</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> s1=<span class="number">0</span>, lefts=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=mid; i&gt;=left; --i )</span><br><span class="line">        &#123;</span><br><span class="line">            lefts+=a[i];</span><br><span class="line">            <span class="keyword">if</span>(lefts&gt;s1) s1=lefts;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="type">int</span> s2=<span class="number">0</span>, rights=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=mid+<span class="number">1</span>; j&lt;=right; ++j )</span><br><span class="line">        &#123;</span><br><span class="line">            rights+=a[j];</span><br><span class="line">            <span class="keyword">if</span>(rights&gt;s2) s2=rights;</span><br><span class="line">        &#125;</span><br><span class="line">        maxSum=s1+s2;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(maxSum&lt;leftSum) maxSum=leftSum;</span><br><span class="line">        <span class="keyword">if</span>(maxSum&lt;rightSum) maxSum=rightSum;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> maxSum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,solve(a,<span class="number">0</span>,n<span class="number">-1</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>算法3</strong>：<strong>动态规划法 T(n)&#x3D;O(n)</strong></p><p>若记b[j]&#x3D;max(a[i]+a[i+1]+..+a[j])，<strong>b[j]表示以a[j]作为最后一个元素的最大子段和</strong>，其中1&lt;&#x3D;i&lt;&#x3D;j，并且1&lt;&#x3D;j&lt;&#x3D;n，则**所求的最大子段和为max{b[j]}**，1&lt;&#x3D;j&lt;&#x3D;n</p><p>由b[j]的定义可易知，当b[j-1]&gt;0时b[j]&#x3D;b[j-1]+a[j]，否则b[j]&#x3D;a[j]。故b[j]的动态规划递归式为:</p><p><strong>b[j]&#x3D;max(b[j-1]+a[j], a[j])，1&lt;&#x3D;j&lt;&#x3D;n</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a[<span class="number">105</span>],b[<span class="number">105</span>],n, maxSum;</span><br><span class="line"><span class="type">void</span> <span class="title function_">solve</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    b[<span class="number">0</span>]=a[<span class="number">0</span>];</span><br><span class="line">    maxSum=b[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(b[i<span class="number">-1</span>]&gt;<span class="number">0</span>)</span><br><span class="line">            b[i]=b[i<span class="number">-1</span>]+a[i];</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            b[i]=a[i];</span><br><span class="line">        <span class="keyword">if</span>(b[i]&gt;maxSum)</span><br><span class="line">            maxSum=b[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    solve();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,maxSum);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="LIS最长递增子序列"><a href="#LIS最长递增子序列" class="headerlink" title="LIS最长递增子序列"></a>LIS最长递增子序列</h3><p>问题：</p><p>**LIS(Longest Increasing Subsequence，最长递增子序列)**：给出一个序列a$_1$,a$_2$,a$_3$,a$_4$,….a$_n$，求它的一个子序列（设为s$_1$,s$_2$,…s$_n$），使得这个子序列满足这样的性质，s$_1$&lt;s$_2$&lt;…&lt;s$_n$并且这个子序列的长度最长。</p><p>• 【任务】输出这个最长子序列的长度</p><p>• 【样例输入】 1 7 3 5 9 4 8 </p><p>• 【样例输出】 长度为4【序列为1 3 5 9或1 3 4 8 】</p><p><strong>算法设计</strong>：</p><p>设b[i]是在a[i]为单调递增子序列最后一个元素时，所得最长单调递增子序列的长度<br>$$<br>b[i]&#x3D;<br>\begin{cases}<br>1 &amp; if(i&#x3D;1) \<br>max(b[j]) + 1 &amp; if( a[j] &lt; a[i] 且 1 \leq j&lt;i)<br>\end{cases}<br>$$</p><ul><li><p>a数组存储原始数据</p></li><li><p>b数组存储对应最长上升子序列长度</p></li><li><ul><li>i&#x3D;3时，a[i]&#x3D;3，在i&lt;3中寻找比3小的元素，有1，则b[3]&#x3D;1+1&#x3D;2</li><li>i&#x3D;5时，a[i]&#x3D;9,在i&lt;5中寻找比9小的元素，有1，3，5，7比较得到这些满足条件中的b[i]最大值，为3，则b[5]&#x3D;3+1&#x3D;4</li></ul></li><li><p><strong>构造最优解</strong> pre数组存储最长上升子序列当前元素的上一个元素的下标</p></li></ul><p><img src="D:\PersonalData\Mango\NEW\Blog\Hexo-blog\blog-mango\source\images\article\算法\dp-LIS算法设计.png" alt="image-20230316024312658"></p><p><img src="D:\PersonalData\Mango\NEW\Blog\Hexo-blog\blog-mango\source\images\article\算法\dp-LIS算法构造最优解.png" alt="image-20230316025231970"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 以下是C语言实现方式</span></span><br><span class="line"><span class="comment">// a数组存储原始数据，pre数组存储前一个数据编号</span></span><br><span class="line"><span class="comment">// b数组存储对应最长上升子序列长度</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, a[<span class="number">105</span>], b[<span class="number">105</span>], c[<span class="number">105</span>], maxLen, lab, pre[<span class="number">105</span>];</span><br><span class="line"><span class="type">void</span> <span class="title function_">solve</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//求最长上升子序列O(n^2)</span></span><br><span class="line">    b[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i++) <span class="comment">//分阶段</span></span><br><span class="line">    &#123;</span><br><span class="line">        maxLen = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = i - <span class="number">1</span>; j &gt;= <span class="number">1</span>; j--) <span class="comment">//枚举每个状态</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (a[j]&lt;a[i]&amp;&amp;b[j]&gt;maxLen)</span><br><span class="line">            &#123;</span><br><span class="line">                maxLen = b[j];</span><br><span class="line">                pre[i]=j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        b[i] = maxLen + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    maxLen = b[<span class="number">1</span>];</span><br><span class="line">    lab = <span class="number">1</span>; <span class="comment">//lab存储最长递增子序列最后一个元素的位置</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (b[i] &gt; maxLen)</span><br><span class="line">        &#123;</span><br><span class="line">            maxLen = b[i];</span><br><span class="line">            lab = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//拷贝数列到c数组</span></span><br><span class="line">    <span class="type">int</span> i = lab;</span><br><span class="line">    <span class="type">int</span> num = maxLen;</span><br><span class="line">    <span class="type">int</span> j = maxLen;</span><br><span class="line">    <span class="keyword">while</span>(num&gt;<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        c[j]=a[i];</span><br><span class="line">        j--;</span><br><span class="line">        i=pre[i];</span><br><span class="line">        num--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memset</span>(b, <span class="number">0</span>, <span class="keyword">sizeof</span>(a));</span><br><span class="line">    <span class="built_in">memset</span>(c, <span class="number">0</span>, <span class="keyword">sizeof</span>(c));</span><br><span class="line">    <span class="built_in">memset</span>(pre, <span class="number">0</span>, <span class="keyword">sizeof</span>(pre));</span><br><span class="line">    solve();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,maxLen);</span><br><span class="line">    <span class="comment">//输出数列O(n)</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=maxLen;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d,&quot;</span>,c[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="0-1背包问题O-nc"><a href="#0-1背包问题O-nc" class="headerlink" title="0-1背包问题O(nc)"></a>0-1背包问题O(nc)</h3><p>问题描述：</p><p>给定n种物品（每种物品只有一件）和一个背包：物品i的重量是w$_i$ ，其价值为v$_i$ ，背包的容量为C。问应如何选择装入背包的物品，使得装入背包中物品的总价值最大?</p><p> 对于每种物品，<font color=orange>只有两种选择：拿(1)或者不拿(0)，不允许拿物品的一部分</font></p><p> 0-1背包问题是一个特殊的整数规划问题<br>$$<br>\begin{aligned}<br> \left { \begin{aligned}<br>       \sum_{i&#x3D;1}^nw_ix_i \leq C \<br>        x_i \in{0,1},1 \leq i \leq n<br>       \end{aligned}<br> \right .%加右}<br> \qquad \text max \sum_{i&#x3D;1}^nv_ix_i<br>\end{aligned}<br>$$<br><strong>问题分析</strong>：</p><p>【第一种分析】</p><ol><li>减少规模</li></ol><p>• 定义m(i，j)是背包容量为j，可选择物品为i，i+1，…，n时0-1背包问题的最优值</p><p>• m(i+1，j)为可选择物品为i+1，…，n时0-1背包问题的最优值</p><p>• …</p><p>• m(n，j)为可选择物品为n时0-1背包问题的最优值，此时，<strong>规模已为1</strong><br>$$<br>m(n,j)&#x3D;<br>\begin{cases}<br>v_n &amp; j \geq w_n \<br>0 &amp; 0 \leq j &lt; w_n<br>\end{cases}<br>$$</p><ol start="2"><li>推导递归式</li></ol><p>判断是否放入第i件？</p><p>• 1）<strong>不放</strong>，背包当前产生价值仍为<strong>m(i+1，j)</strong></p><p>• 2）<strong>放入</strong>，调整背包容量j-w$_i$ ，背包当前产生价值为<strong>m(i+1, j-w$_i$)+v$_i$</strong></p><p>-&gt;判断第i件，由0-1背包问题的最优子结构性质，可以建立计算m(i，j)的递归式如下:<br>$$<br>m(i,j)&#x3D;<br>\begin{cases}<br>max { m(i+1,j), m(i+1,j-w_i)+v_i } &amp; j \geq w_i \<br>m(i+1,j) &amp; 0 \leq j &lt; w_i<br>\end{cases}</p><p>\</p><p>m(n,j)&#x3D;<br>\begin{cases}<br>v_n &amp; j \geq w_n \<br>0 &amp; 0 \leq j &lt; w_n<br>\end{cases}<br>$$<br><strong>实例分析</strong>：</p><p><img src="D:\PersonalData\Mango\NEW\Blog\Hexo-blog\blog-mango\source\images\article\算法\dp-01背包实例分析.png" alt="image-20230316033154179"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">(<span class="type">int</span> v[],<span class="type">int</span> w[],<span class="type">int</span> c,<span class="type">int</span> n,<span class="type">int</span> m[][<span class="number">11</span>])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> jMax=<span class="built_in">min</span>(w[n]<span class="number">-1</span>,c);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">0</span>;j&lt;=jMax;j++) &#123; <span class="comment">//当 0=&lt;j&lt;w[n]时, m(n,j)=0</span></span><br><span class="line">        m[n][j]=<span class="number">0</span>; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j=w[n];j&lt;=c;j++) &#123; <span class="comment">// 当j&gt;=w[n]时, m(n,j)=v[n]</span></span><br><span class="line">        m[n][j]=v[n]; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=n<span class="number">-1</span>;i&gt;=<span class="number">1</span>;i--) &#123; <span class="comment">//DP</span></span><br><span class="line">        <span class="type">int</span> jMax=<span class="built_in">min</span>(w[i]<span class="number">-1</span>,c);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">0</span>;j&lt;=jMax;j++) &#123; <span class="comment">//m(i,j)=m(i+1,j) 当0=&lt;j&lt;w[i]</span></span><br><span class="line">            m[i][j]=m[i+<span class="number">1</span>][j]; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j=w[i];j&lt;=c;j++) &#123; <span class="comment">//m(n,j)=v[n] 当j&gt;=w[n]</span></span><br><span class="line">            m[i][j]=<span class="built_in">max</span>(m[i+<span class="number">1</span>][j],m[i+<span class="number">1</span>][j-w[i]]+v[i]); </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;m[<span class="number">1</span>][c]; <span class="comment">//在c容量可获的最大价值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 从m(i, j)的递归式可以看出，算法需要O(nc)的计算时间，即**T(n)&#x3D;O(nc)**，其中，n为物品数量，c为背包容量</p><p> 当背包容量c很大时，算法需要较多的计算时间，例如，当c&gt;2n时，算法需要的计算时间为Ω(n2n)</p><p> 算法的空间复杂度：<strong>S(n)&#x3D;O(nc)</strong></p><p><strong>构造最优解</strong>：</p><img src="D:\PersonalData\Mango\NEW\Blog\Hexo-blog\blog-mango\source\images\article\算法\dp-01背包构造最优解.png" alt="image-20230316034058367" style="zoom:80%;" /><p>【第二种分析】</p><ol><li>换角度来减少规模</li></ol><p>• 定义m(i，j)是背包容量为j，可选择物品为1,2,3，…，i-1,i时0-1背包问题的最优值</p><p>• m(i-1，j)为可选择物品为1,2,3，…，i-1时0-1背包问题的最优值</p><p>• …</p><p>• m(1，j)为可选择物品为1时0-1背包问题的最优值，此时，<strong>规模已为1</strong><br>$$<br>m(1,j)&#x3D;<br>\begin{cases}<br>v_1 &amp; j \geq w_1 \<br>0 &amp; 0 \leq j &lt; w_1<br>\end{cases}<br>$$</p><ol start="2"><li>推导递归式</li></ol><p>判断是否放入第i件？</p><p>• 1）<strong>不放</strong>，背包当前产生价值仍为<strong>m(i-1，j)</strong></p><p>• 2）<strong>放入</strong>，调整背包容量j-w$_i$ ，背包当前产生价值为<strong>m(i-1, j-w$_i$)+v$_i$</strong></p><p>计算m(i，j)的递归式如下:<br>$$<br>m(i,j)&#x3D;<br>\begin{cases}<br>max { m(i-1,j), m(i-1,j-w_i)+v_i } &amp; j \geq w_i \<br>m(i-1,j) &amp; 0 \leq j &lt; w_i<br>\end{cases}</p><p>\</p><p>m(1,j)&#x3D;<br>\begin{cases}<br>v_1 &amp; j \geq w_1 \<br>0 &amp; 0 \leq j &lt; w_1<br>\end{cases}<br>$$<br><img src="D:\PersonalData\Mango\NEW\Blog\Hexo-blog\blog-mango\source\images\article\算法\dp-01背包实例分析-自上而下.png" alt="image-20230316034635634" style="zoom:80%;" /></p><blockquote><p>思考</p><p> <strong>完全背包问题：</strong>有n种物品和一个容量为C的背包，<strong>每种物品都有无限件可用</strong>。物品i的重量是w[i]，价值为v[i]。求解将哪些物品装入背包可使这些物品的重量总和不超过背包容量，且价值总和最大。</p><p> <strong>多重背包问题：</strong>有n种物品和一个容量为C的背包，<strong>第i种物品最多有n[i]件可用</strong>，物品i的重量是w[i]，价值为v[i]。求解将哪些物品装入背包可使这些物品的重量总和不超过背包容量，且价值总和最大。</p></blockquote><h2 id="算法——贪心算法"><a href="#算法——贪心算法" class="headerlink" title="算法——贪心算法"></a>算法——贪心算法</h2><p>贪心算法概述：</p><p><strong>定义</strong>：贪心算法是指在对问题进行求解时，<font color=orange>在每一步选择中都采取最好或者最优（最有利）的选择，从而希望最终结果是最好或者最优的算法</font>。 &#x3D;&#x3D;局部最优 &#x3D;&gt; 全局最优&#x3D;&#x3D;</p><ul><li><p>有一些问题可以得到整体最优解：<strong>活动安排问题、部分背包问题、最优装载问题、单源最短路径问题、最小生成树</strong>问题等</p></li><li><p>有一些问题不能得到整体最优解 -&gt; <strong>近似最优解</strong>：<u>多机调度问题、0-1背包</u>问题等</p></li></ul><p><strong>贪心算法的基本要素</strong>：</p><ul><li><p><strong>贪心选择性质</strong></p></li><li><ul><li>所求问题的整体最优解可以通过一系列局部最优的选择，即贪心选择来达到</li><li>是贪心算法与动态规划算法的主要区别</li><li>每作一次贪心选择可将所求问题 <u>简化为规模更小的子问题</u></li></ul></li><li><p><strong>最优子结构性质</strong></p></li><li><ul><li>一个问题的最优解 <u>包含其子问题的最优解</u></li></ul></li><li><ul><li>一个问题的最优子结构性质是该问题是否可用动态规划算法或贪心算法求解的关键特征</li></ul></li></ul><h3 id="活动安排问题O-nlogn"><a href="#活动安排问题O-nlogn" class="headerlink" title="活动安排问题O(nlogn)"></a>活动安排问题O(nlogn)</h3><p>问题：</p><p> 设有n个活动的集合E&#x3D;{1,2,…,n}，其中，<font color=orange>每个活动都要求使用同一资源</font>，如演讲会场等，而在<font color=orange>同一时间内只有一个活动能使用这一资源</font>。</p><p> 每个活动i都有一个要求使用该资源的<strong>起始时间s$_i$</strong> 和一个<strong>结束时间f$_i$</strong> ，且s$_i$ &lt;f$_i$ 。如果选择了活动i，则它在半开区间**[s$_i$  , $f_i$ )**内占用资源。</p><p> 若区间[s$_i$  , $f_i$ )与区间[s$_j$ , $f_j$ )不相交，则称活动i与活动j是<font color=orange>相容</font>的。即：当s$_i$ ≥f$_j$ 或s$_j$ ≥f$_i$ 时，活动i与活动j相容。</p><p><strong>活动安排问题：在所给的活动集合中选出最大的相容活动子集</strong>。</p><p><strong>算法设计</strong>：该问题要求高效地安排一系列争用某一公共资源的活动</p><p>设计思路：</p><p>• 按 <u>结束时间的非减序</u> 对活动进行排列</p><p>• 选择一个 <u>结束时间最早</u> 的活动</p><p>• 依次检查后续活动是否与当前已选择的所有活动相容，<font color=orange>若相容则将该活动加入已选择活动集合中</font>，再继续检查下一活动，否则直接检查下一活动</p><p>• 直到所有活动全部检查完毕</p><p>由于输入的活动以其完成时间的非减序排列 -&gt; 算法每次总是<strong>选择具有最早完成时间的相容活动加入集合中</strong></p><p> 贪心选择意义：使剩余的可安排时间段极大化，以便安排尽可能多的相容活动</p><p> 算法效率高：当输入的活动已按结束时间非减序排列，算法只需**O(n)<strong>的时间安排n个活动，使最多的活动能相容地使用公共资源；如果所给出的活动未按非减序排列，需要</strong>O(nlogn)**的时间排序</p><p>时间复杂度（输入活动无序）：<strong>T(n) &#x3D; O(nlogn) + O(n) &#x3D; O(nlogn)</strong></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** 定义数据结构 **/</span></span><br><span class="line"><span class="meta">#include &lt;iostream&gt;</span></span><br><span class="line"><span class="meta">#include &lt;algorithm&gt;</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="title">std</span>;</span><br><span class="line"><span class="comment">//结构体：活动</span></span><br><span class="line"><span class="keyword">struct</span> Activity&#123;</span><br><span class="line">    <span class="built_in">int</span> id; <span class="comment">//活动编号</span></span><br><span class="line"><span class="built_in">int</span> sTime; <span class="comment">//活动开始时间</span></span><br><span class="line"><span class="built_in">int</span> fTime; <span class="comment">//活动结束时间</span></span><br><span class="line"><span class="built_in">bool</span> selected; <span class="comment">//该活动是否选中</span></span><br><span class="line">&#125;;</span><br><span class="line">Activity activities[<span class="number">11</span>];</span><br><span class="line"><span class="built_in">int</span> s[<span class="number">11</span>] = &#123;<span class="number">1</span>,<span class="number">3</span>,<span class="number">0</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">8</span>,<span class="number">2</span>,<span class="number">12</span>&#125;;</span><br><span class="line"><span class="built_in">int</span> f[<span class="number">11</span>] = &#123;<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>,<span class="number">11</span>,<span class="number">12</span>,<span class="number">13</span>,<span class="number">14</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 贪心选择 **/</span></span><br><span class="line"><span class="comment">//比较函数</span></span><br><span class="line"><span class="function"><span class="built_in">int</span> <span class="title">cmp</span>(<span class="params"><span class="keyword">const</span> Activity &amp;a, <span class="keyword">const</span> Activity &amp;b</span>)</span>&#123;</span><br><span class="line"><span class="comment">//按照活动结束时间非减序排列</span></span><br><span class="line"><span class="keyword">return</span> a.fTime &lt; b.fTime;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//贪心选择</span></span><br><span class="line"><span class="function"><span class="built_in">int</span> <span class="title">activitySelect</span>(<span class="params">Activity activities[], <span class="built_in">int</span> n</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">int</span> activityCount = <span class="number">0</span>;</span><br><span class="line">activities[<span class="number">0</span>].selected=<span class="literal">true</span>;</span><br><span class="line"><span class="built_in">int</span> j=<span class="number">0</span>;</span><br><span class="line">activityCount=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="built_in">int</span> i=<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//i的开始时间在j的结束时间之后，则相容</span></span><br><span class="line"><span class="keyword">if</span>(activities[i].sTime&gt;=activities[j].fTime) &#123;</span><br><span class="line">activities[i].selected=<span class="literal">true</span>;</span><br><span class="line">j=i;</span><br><span class="line">activityCount++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> activityCount;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 主函数 **/</span></span><br><span class="line"><span class="function"><span class="built_in">int</span> <span class="title">main</span>()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="built_in">int</span> i=<span class="number">0</span>;i&lt;<span class="number">11</span>;i++) &#123;</span><br><span class="line">activities[i].id = i+<span class="number">1</span>;</span><br><span class="line">activities[i].sTime = s[i];</span><br><span class="line">activities[i].fTime = f[i];</span><br><span class="line">activities[i].selected = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">sort(activities,activities + <span class="number">11</span>,cmp); <span class="comment">//快速排序</span></span><br><span class="line"><span class="built_in">int</span> activityCount = <span class="number">0</span>;</span><br><span class="line">activityCount = activitySelect(activities, <span class="number">11</span>);</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;相容活动数量：&quot;</span> &lt;&lt; activityCount &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;相容活动编号：&quot;</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="built_in">int</span> i=<span class="number">0</span>;i&lt;<span class="number">11</span>;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(activities[i].selected)</span><br><span class="line">&#123;</span><br><span class="line">cout&lt;&lt;activities[i].id&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>实例分析</strong>：</p><p>贪心算法提供了一个简单、漂亮的方法使得尽可能多的活动能兼容地使用公共资源</p><p>例：设待安排的11个活动的开始时间和结束时间按结束时间的非减序排列如下：</p><table><thead><tr><th>i</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th><th>7</th><th>8</th><th>9</th><th>10</th><th>11</th></tr></thead><tbody><tr><td>s[i]</td><td>1</td><td>3</td><td>0</td><td>5</td><td>3</td><td>5</td><td>6</td><td>8</td><td>8</td><td>2</td><td>12</td></tr><tr><td>f[i]</td><td><strong>4</strong></td><td><strong>5</strong></td><td><strong>6</strong></td><td><strong>7</strong></td><td><strong>8</strong></td><td><strong>9</strong></td><td><strong>10</strong></td><td><strong>11</strong></td><td><strong>12</strong></td><td><strong>13</strong></td><td><strong>14</strong></td></tr></tbody></table><p>若<font color=green>被检查的活动i的开始时间s$_i$ 小于最近选择的活动j的结束时间f$_i$ ，则不选择活动i，否则选择活动i</font>加入已选活动集合中</p><table><thead><tr><th>i</th><th>&#x3D;&#x3D;1&#x3D;&#x3D;</th><th>2</th><th>3</th><th>&#x3D;&#x3D;4&#x3D;&#x3D;</th><th>5</th><th>6</th><th>7</th><th>&#x3D;&#x3D;8&#x3D;&#x3D;</th><th>9</th><th>10</th><th>&#x3D;&#x3D;11&#x3D;&#x3D;</th></tr></thead><tbody><tr><td>s[i]</td><td>&#x3D;&#x3D;1&#x3D;&#x3D;</td><td>3</td><td>0</td><td>&#x3D;&#x3D;5&#x3D;&#x3D;</td><td>3</td><td>5</td><td>6</td><td>&#x3D;&#x3D;8&#x3D;&#x3D;</td><td>8</td><td>2</td><td>&#x3D;&#x3D;12&#x3D;&#x3D;</td></tr><tr><td>f[i]</td><td>&#x3D;&#x3D;4&#x3D;&#x3D;</td><td>5</td><td>6</td><td>&#x3D;&#x3D;7&#x3D;&#x3D;</td><td>8</td><td>9</td><td>10</td><td>&#x3D;&#x3D;11&#x3D;&#x3D;</td><td>12</td><td>13</td><td>&#x3D;&#x3D;14&#x3D;&#x3D;</td></tr></tbody></table><p>对于活动安排问题，<font color=green>贪心算法能求得的整体最优解，即它最终所确定的相容活动集合的规模最大</font></p><img src="D:\PersonalData\Mango\NEW\Blog\Hexo-blog\blog-mango\source\images\article\算法\tx-活动安排实例分析.png" alt="image-20230316161326582" style="zoom:80%;" /><h3 id="部分背包问题O-nlogn"><a href="#部分背包问题O-nlogn" class="headerlink" title="部分背包问题O(nlogn)"></a>部分背包问题O(nlogn)</h3><p><strong>贪心算法与动态规划算法的差异</strong></p><ul><li><p><u>贪心算法和动态规划算法都要求问题具有最优子结构性质</u></p></li><li><p>对于具有最优子结构的问题应该选用贪心算法还是动态规划算法求解？</p></li><li><p>是否能用动态规划算法求解的问题也能用贪心算法求解？</p></li></ul><p>差异实例分析：0-1背包、部分背包问题</p><table><thead><tr><th>0-1背包</th><th>部分背包</th></tr></thead><tbody><tr><td>给定n种物品（每种物品一件）和一个背包。物品i的重量是W$_i$ ，其价值为V$_i$ ，背包的容量为C。应如何选择装入背包的物品，使得装入背包中物品的总价值最大？<br><br>在选择装入背包的物品时，对每种物品i<strong>只有2种选择</strong>，即装入背包或不装入背包。不能将物品i装入背包多次，也不能只装入部分的物品i。</td><td>与0-1背包问题类似，所不同的是在选择物品i装入背包时，可以<strong>选择物品i的一部分</strong>，而不一定要全部装入背包，1≤i≤n。</td></tr><tr><td>&#x3D;&#x3D;动态规划求解&#x3D;&#x3D; <br><br>对于0-1背包问题，贪心选择不能得到最优解 -&gt; <strong>无法保证最终能将背包装满</strong>，部分闲置的背包空间降低了每公斤背包空间的价值<br>应比较选择该物品和不选择该物品所导致的最终方案，然后再作出最好选择 -&gt; <font color=orange>重叠子问题</font> -&gt; <strong>动态规划</strong></td><td>可以用&#x3D;&#x3D;贪心算法&#x3D;&#x3D;求解 <br><br>对于部分背包问题，优先选择单位重量下价值最大的物品 -&gt; <font color=orange>贪心选择性质</font> -&gt; <strong>贪心算法</strong></td></tr></tbody></table><img src="D:\PersonalData\Mango\NEW\Blog\Hexo-blog\blog-mango\source\images\article\算法\tx-背包问题差异.png" alt="image-20230316162208657" style="zoom:80%;" /><p><strong>部分背包</strong>问题描述：</p><p>设有编号为1,2,3,……,n的n个物品，它们的重量分别为w$_1$, w$_2$, w$_3$, ……, w$_n$，价值分别为v$_1$, v$_2$, v$_3$, ……, v$_n$，其中w$_i$ 和v$_i$ (1≤i≤n)均为正数。有一个背包可以携带的最大重量不超过W。</p><p> 求解目标：<strong>在不超过背包负重的前提下使背包装入的总价值最大</strong>（即效益最大化），<strong>允许每个物品取一部分装入背包</strong></p><p>问题形式化：</p><p>设x$_i$表示物品i装入背包的情况，0≤x$_i$≤1。寻找一个满足下述约束条件，并使目标函数达到最大的解向量X&#x3D;(x$_1$, x$_2$, x$_3$ ,……, x$<em>n$)。<br>$$<br>约束条件：<br>\begin{aligned}<br>\sum</em>{i &#x3D; 1} ^n w_ix_i \leq W &amp;&amp;&amp; 0 \leq x_i \leq 1(1 \leq i \leq n)<br>\end{aligned}</p><p>\</p><p>目标函数：<br>\begin{aligned}<br>max{ \sum_{i&#x3D;1}^n v_ix_i }<br>\end{aligned}<br>$$<br>如何制定贪心策略？</p><p>• (1) 选择<u>价值最大的物品</u> -&gt; 背包容量可能消耗很快</p><p>• (2) 选择<u>重量最轻</u>的物品 -&gt; 背包价值可能增长很缓慢</p><p>• (3) 选择<u>单位重量下价值最大</u>的物品 -&gt; 在背包价值增长和背包容量消耗之间寻找平衡</p><p><strong>设计思路</strong>：</p><p> 1. 按照单位重量价值对物品进行<strong>降序</strong>排序</p><p> 2. <strong>依次从物品集合中选择单位重量价值最大的物品：如果某物品重量小于背包剩余容量，则将该物品全部装入</strong>，背包总价值加上该物品的价值，背包容量减去该物品的重量，直到所有物品全部装入背包或者背包剩余重量为0为止</p><p> 3. 如果某剩余物品重量大于背包剩余容量，且背包剩余容量&gt;0，则<strong>将该物品的一部分装入背包</strong>，背包总价值加上该物品填满剩余容量所对应的价值</p><p> 4. 返回背包总价值</p><p><strong>实例分析</strong>：</p><p><img src="D:\PersonalData\Mango\NEW\Blog\Hexo-blog\blog-mango\source\images\article\算法\tx-部分背包实例.png" alt="image-20230316164448205"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** 数据结构定义 **/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXN 51</span></span><br><span class="line"><span class="comment">//问题表示</span></span><br><span class="line"><span class="type">int</span> n=<span class="number">5</span>;</span><br><span class="line"><span class="type">double</span> W=<span class="number">100</span>; <span class="comment">//限重</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">NodeType</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="type">double</span> w;</span><br><span class="line"><span class="type">double</span> v;</span><br><span class="line"><span class="type">double</span> p; <span class="comment">//p=v/w</span></span><br><span class="line"><span class="type">bool</span> operator&lt;(<span class="type">const</span> NodeType &amp;s) <span class="type">const</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> p&gt;s.p; <span class="comment">//按p递减排序</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">NodeType A[]=&#123;&#123;<span class="number">0</span>&#125;,&#123;<span class="number">10</span>,<span class="number">20</span>&#125;,&#123;<span class="number">20</span>,<span class="number">30</span>&#125;,&#123;<span class="number">30</span>,<span class="number">66</span>&#125;,&#123;<span class="number">40</span>,<span class="number">40</span>&#125;,&#123;<span class="number">50</span>,<span class="number">60</span>&#125;&#125;; <span class="comment">//下标为0的元素不用</span></span><br><span class="line"><span class="comment">//求解结果表示</span></span><br><span class="line"><span class="type">double</span> value; <span class="comment">//最大价值</span></span><br><span class="line"><span class="type">double</span> x[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 背包问题求解函数 **/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">knapsack</span><span class="params">()</span> <span class="comment">//求解背包问题并返回总价值</span></span><br><span class="line">&#123;</span><br><span class="line">value=<span class="number">0</span>; <span class="comment">//初始化最大价值为0</span></span><br><span class="line"><span class="type">double</span> weight=W; <span class="comment">//背包中能够装入的剩余重量</span></span><br><span class="line"><span class="built_in">memset</span>(x,<span class="number">0</span>,<span class="keyword">sizeof</span>(x)); <span class="comment">//初始化x向量</span></span><br><span class="line"><span class="type">int</span> i=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(A[i].w&lt;weight) <span class="comment">//物品i能够全部装入时循环</span></span><br><span class="line">&#123;</span><br><span class="line">x[i]=<span class="number">1</span>; <span class="comment">//装入物品i</span></span><br><span class="line">weight-=A[i].w; <span class="comment">//减少背包中能装入的剩余重量</span></span><br><span class="line">value+=A[i].v; <span class="comment">//累计总价值</span></span><br><span class="line">i++; <span class="comment">//继续循环</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(weight&gt;<span class="number">0</span>) <span class="comment">//余下重量大于0</span></span><br><span class="line">&#123;</span><br><span class="line">x[i]=weight/A[i].w; <span class="comment">//将物品i的一部分装入</span></span><br><span class="line">value+=x[i]*A[i].v; <span class="comment">//累计总价值</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 输出函数和主函数 **/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">display</span><span class="params">()</span> <span class="comment">//输出结果</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> i;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\tW\tV\tV/W\n&quot;</span>);</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\t%g\t%g\t%3.1f\n&quot;</span>,A[i].w,A[i].v,A[i].p);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;求解过程\n&quot;</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">&#123;</span><br><span class="line">A[i].p=A[i].v/A[i].w; <span class="comment">//求v/w</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;(1)排序前\n&quot;</span>); display();</span><br><span class="line">sort(A+<span class="number">1</span>,A+n+<span class="number">1</span>); <span class="comment">//排序</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;(2)排序后\n&quot;</span>); display();</span><br><span class="line">knapsack();</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;(3)求解结果\n&quot;</span>); <span class="comment">//输出结果</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\tx:[&quot;</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%g,&quot;</span>,x[j]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%g]\n&quot;</span>,x[n]);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\t总价值=%g\n&quot;</span>, value);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>时间复杂度</strong>：</p><p>排序算法sort()的时间复杂度为O(nlogn)，while循环的时间复杂度为O(n)</p><p>算法的总时间复杂度：<strong>T(n) &#x3D; O(nlogn) + O(n) &#x3D; O(nlogn)</strong></p><h3 id="最优装载O-nlogn"><a href="#最优装载O-nlogn" class="headerlink" title="最优装载O(nlogn)"></a>最优装载<strong>O(nlogn)</strong></h3><p>问题描述：</p><p>有一批集装箱要装上一艘载重量为c的轮船，其中集装箱i的重量为w$<em>i$ 。最优装载问题要求在装载体积不受限制的情况下，将尽可能多的集装箱装上轮船。<br>$$<br>\begin{aligned}<br>max\sum</em>{i&#x3D;1}^n x_i \<br>\end{aligned}<br>\ </p><p>\begin{cases}<br>\sum_{i&#x3D;1}^n w_i x_i \leq C \<br>x_i \in { 0,1 } &amp; 1 \leq i \leq n<br>\<br>\end{cases}</p><p>\</p><p>变量x_i&#x3D;0表示不装入集装箱i，x_i&#x3D;1表示装入集装箱i<br>$$<br>采用<strong>重量最轻者先装</strong>的贪心选择策略，可产生最优装载问题的最优解</p><p>实现原理：排序 -&gt; 装载</p><p>• 每次选择时，从剩下的集装箱中，<u>选择重量最小的集装箱</u></p><p>• 可以保证已经选出来的集装箱总重量最小，装载的集装箱数量最多，<u>直到轮船不能再继续装载为止</u></p><p><strong>贪心选择性质</strong>：从局部最优可推导出全局最优</p><p><strong>最优子结构性质</strong>：一个问题的最优解包含其子问题的最优解</p><p>算法的主要计算量在于将集装箱依其重量从小到大排序</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//集装箱结构体</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">box</span>&#123;</span><br><span class="line"><span class="type">int</span> weight;<span class="comment">//集装箱重量</span></span><br><span class="line"><span class="type">int</span> index; <span class="comment">//集装箱编号</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//比较函数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">cmp</span><span class="params">(<span class="type">const</span> box &amp;a, <span class="type">const</span> box &amp;b)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> a.weight &lt; b.weight; <span class="comment">//按照集装箱重量由小到大排序</span></span><br><span class="line">&#125;</span><br><span class="line">box boxes[<span class="number">8</span>];</span><br><span class="line"><span class="type">int</span> weight[<span class="number">8</span>] = &#123;<span class="number">100</span>,<span class="number">200</span>,<span class="number">50</span>,<span class="number">90</span>,<span class="number">150</span>,<span class="number">50</span>,<span class="number">20</span>,<span class="number">80</span>&#125;;</span><br><span class="line"><span class="type">int</span> x[<span class="number">8</span>];</span><br><span class="line"><span class="type">int</span> c = <span class="number">400</span>;</span><br><span class="line"><span class="type">int</span> opt = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//贪心算法实现最优装载</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">loading</span><span class="params">(box boxes[], <span class="type">int</span> x[], <span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> num = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n&amp;&amp;boxes[i].weight&lt;=c;i++)</span><br><span class="line">&#123;</span><br><span class="line">x[boxes[i].index<span class="number">-1</span>]=<span class="number">1</span>; <span class="comment">//记录装载的集装箱编号</span></span><br><span class="line">num++;</span><br><span class="line">c-=boxes[i].weight; <span class="comment">//更新剩余重量</span></span><br><span class="line">opt+=boxes[i].weight; <span class="comment">//更新已装载总重量</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> num;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">8</span>;i++) &#123;</span><br><span class="line">boxes[i].index = i+<span class="number">1</span>;</span><br><span class="line">boxes[i].weight=weight[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">sort</span>(boxes,boxes + <span class="number">8</span>,cmp); <span class="comment">//快速排序</span></span><br><span class="line"><span class="built_in">memset</span>(x,<span class="number">0</span>,<span class="built_in">sizeof</span>(x));</span><br><span class="line"><span class="type">int</span> boxCount = <span class="number">0</span>;</span><br><span class="line">boxCount = <span class="built_in">loading</span>(boxes,x,<span class="number">8</span>);</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;集装箱数量：&quot;</span> &lt;&lt; boxCount &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;集装箱总重量：&quot;</span> &lt;&lt; opt &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;集装箱编号：&quot;</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">8</span>;i++) &#123;</span><br><span class="line"><span class="keyword">if</span>(x[i]==<span class="number">1</span>) &#123;</span><br><span class="line">cout&lt;&lt;i+<span class="number">1</span>&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="MST最小生成树"><a href="#MST最小生成树" class="headerlink" title="MST最小生成树"></a>MST最小生成树</h3><img src="D:\PersonalData\Mango\NEW\Blog\Hexo-blog\blog-mango\source\images\article\算法\tx-最小生成树-畅通工程.png" alt="image-20230316170408585" style="zoom:88%;" /><p><strong>最小生成树 Minimal Spanning Trees (MST)</strong></p><p>任何只由图G的边构成，并包含G的所有顶点的树称为 <u>G的生成树</u></p><p>加权无向图G的生成树的代价（权重）是该<u>生成树的所有边的代价（权重）的和</u></p><p>最小生成树是其所有生成树中代价（权重）最小的生成树</p><p>N个顶点，选取N-1条边，构建一个连通图，且这N-1条边的权重之和最小</p><h4 id="最小生成树——Prim算法O-V-2"><a href="#最小生成树——Prim算法O-V-2" class="headerlink" title="最小生成树——Prim算法O(V$^2$)"></a>最小生成树——Prim算法O(V$^2$)</h4><p>普里姆算法 具有贪心选择性质 -&gt; 贪心算法经典实例</p><p>Prim算法是一种<strong>基于贪心思想求解加权无向图的最小生成树</strong>的算法</p><p>Prim算法的时间复杂度为T(n)&#x3D; O(V$^2$)，适合于处理稠密图；如果使用小根堆优化，时间复杂度为T(n)&#x3D;O(ElogV)</p><p><strong>实例分析</strong>：</p><p><img src="D:\PersonalData\Mango\NEW\Blog\Hexo-blog\blog-mango\source\images\article\算法\tx-prim实例分析.png" alt="image-20230316180441431"></p><p>设计思路：</p><p>(1) 任意选定一点s，设集合S&#x3D;{s}</p><p>(2) 从<strong>不在集合S的点</strong>中<strong>选出一个点j使得其与S内的某点i的距离最短</strong>，则(i，j)就是生成树上的一条边，同时将j点加入S</p><p>(3) 转到(2)继续进行，直至所有点都己加入S集合</p><p><strong>公路造价问题描述</strong>：</p><p>现有一张城市地图，图中的顶点为城市，无向边代表两个城市间的连通关系，边上的权代表公路造价。在分析了这张图后发现，任一对城市都是连通的。现在要求用公路把所有城市联系起来，如何设计可使得工程的总造价最少？</p><p><img src="D:\PersonalData\Mango\NEW\Blog\Hexo-blog\blog-mango\source\images\article\算法\tx-prim公路造价图.png" alt="image-20230316180745830"></p><p>【输入格式】：第一行两个数v(v&lt;&#x3D;200)和e分别代表城市数和边数，以下e行，每行为两个顶点和它们之间的边权w(w&lt;1000)。<br>【输出格式】：v-1行，每行为两个城市的序号，表明这两个城市间建一条公路，再加该公路的造价。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** 数据结构定义和初始化 **/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span> </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std; </span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXN 2005</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INF 1000000</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> G[MAXN][MAXN]; <span class="comment">//存储图</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span> ; i &lt; n ; i++)&#123; </span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span> ; j &lt; n ; j++) </span><br><span class="line">G[i][j] = INF; <span class="comment">//初始化图中两点间距离为无穷大</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/** 贪心选择 **/</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">prim</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="type">int</span> closeset[n], <span class="comment">//记录不在S中的顶点在S中的最近邻接点</span></span><br><span class="line">lowcost[n], <span class="comment">//记录不在S中的顶点到S的最短距离，即到最近邻接点的权值</span></span><br><span class="line">used[n]; <span class="comment">//标记顶点是否被访问，访问过的顶点标记为1 </span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//初始化，S中只有第1个点(0)</span></span><br><span class="line">lowcost[i] = G[<span class="number">0</span>][i]; <span class="comment">//获取其他顶点到第1个点(0)的距离，不直接相邻的顶点距离为无穷大</span></span><br><span class="line">closeset[i] = <span class="number">0</span>; <span class="comment">//初始情况下所有点的最近邻接点都为第1个点(0) </span></span><br><span class="line">used[i] = <span class="number">0</span>; <span class="comment">//初始情况下所有点都没有被访问过</span></span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">used[<span class="number">0</span>] = <span class="number">1</span>; <span class="comment">//访问第1个点(0)，将第1个点加到S中</span></span><br><span class="line">    <span class="comment">//每一次循环找出一个到S距离最近的顶点</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> j = <span class="number">0</span>; </span><br><span class="line"><span class="comment">//每一次循环计算所有没有使用的顶点到当前S的距离，得到在没有使用的顶点中到S的最短距离以及顶点号</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; n; k++)</span><br><span class="line">            <span class="comment">//如果顶点k没有被使用，且到S的距离小于j到S的距离，将k赋给j </span></span><br><span class="line"><span class="keyword">if</span> ((!used[k]) &amp;&amp; (lowcost[k] &lt; lowcost[j])) j = k; </span><br><span class="line">        <span class="comment">//输出S中与j最近邻点，j，以及它们之间的距离</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d %d %d\n&quot;</span>,closeset[j] + <span class="number">1</span>, j + <span class="number">1</span>, lowcost[j]); </span><br><span class="line">used[j] = <span class="number">1</span>; <span class="comment">//将j增加到S中</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//每一次循环用于在j加入S后，重新计算不在S中的顶点到S的距离，修改与j相邻的边到S的距离，即更新lowcost和closeset</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; n; k++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> ((!used[k]) &amp;&amp; (G[j][k] &lt; lowcost[k])) <span class="comment">//松弛操作，如果k没有被使用，且k到j的距离比原来k到S的距离小</span></span><br><span class="line">&#123; </span><br><span class="line">lowcost[k] = G[j][k]; <span class="comment">//将k到j的距离作为新的k到S之间的距离</span></span><br><span class="line">closeset[k] = j; <span class="comment">//将j作为k在S中的最近邻点</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度：</p><p><strong>T(n)&#x3D; O(V$^2$)</strong> 【邻接矩阵】-&gt; <strong>稠密图</strong></p><p>堆优化（小根堆）：<strong>T(n) &#x3D; O(VlogV)+O(ElogV) &#x3D; O(ElogV)</strong></p><p>堆优化（斐波那契堆）：<strong>T(n) &#x3D; O(E+VlogV)</strong></p><h4 id="最小生成树——Kruskal算法-O-ElogE"><a href="#最小生成树——Kruskal算法-O-ElogE" class="headerlink" title="最小生成树——Kruskal算法 O(ElogE)"></a>最小生成树——Kruskal算法 O(ElogE)</h4><p>克鲁斯卡尔算法，一种用来查找最小生成树的算法</p><p><strong>并查集 -&gt; 最小生成树 -&gt; Kruskal算法</strong></p><p>&#x3D;&#x3D;并查集&#x3D;&#x3D;<strong>Union-Find Set</strong></p><p>一种<u>树型数据结构</u>，用于处理一些<font color=orange>不相交集合的合并及查询问题</font></p><p>在使用中常常以<strong>森林</strong>来表示，可以把<font color=orange>图中每个连通分量看成一个集合</font>，该集合包含了连通分量中的所有点，图的所有连通分量可以用若干个不相交的集合来表示</p><p>将编号分别为1…N的N个对象划分为不相交集合，在每个集合中，选择其中某个元素代表所在集合</p><p> 常见操作：</p><p>• <strong>合并</strong>两个集合</p><p>• <strong>查找</strong>某元素属于哪个集合</p><p>• <strong>判断</strong>两个元素是否属于同一个集合</p><p><strong>基本操作</strong>：</p><ul><li><p><code>make_set(x)</code>：把每一个元素初始化为一个集合【将每个元素的父结点初始化为自己】</p></li><li><p><code>find_set(x)</code>：查找一个元素所在的集合。在执行查找操作时，要沿着父结点指针一直找下去，直到找到树根为止</p></li><li><p><code>union_set(x, y)</code>：利用find_set()找到其中两个集合的祖先，将一个集合的祖先指向另一个集合的祖先</p></li></ul><p>判断两个元素是否属于同一集合，只要<strong>判断它们所在集合的祖先是否相同</strong>即可</p><p>合并两个集合，也是<strong>将一个集合的祖先作为另一个集合的祖先</strong></p><p><img src="D:\PersonalData\Mango\NEW\Blog\Hexo-blog\blog-mango\source\images\article\算法\tx-kruskal并查集基本操作.png" alt="image-20230316182352753"></p><p><strong>启发式策略优化</strong></p><p>两种启发式策略（<strong>按秩合并</strong>和<strong>路径压缩</strong>）</p><p>• **秩(Rank)**：表示结点高度的一个上界，树根的秩为0</p><p>• <code>union_set(x,y)</code><strong>时按秩合并</strong>，合并的时候将元素少的集合合并到元素多的集合中，这样合并之后树的高度会相对较小，即每个元素的秩相对较小</p><p>• <code>find_set(x)</code><strong>时路径压缩</strong>，当经过“递推”找到祖先结点后，“回溯”的时候顺便将它的子孙结点都直接指向祖先，以后再次find_set(x)时复杂度为O(1)</p><img src="D:\PersonalData\Mango\NEW\Blog\Hexo-blog\blog-mango\source\images\article\算法\tx-kruskal并查集启发式策略优化.png" alt="image-20230316182712283" style="zoom:80%;" /><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">100</span>; <span class="comment">/*结点数目上线*/</span></span><br><span class="line"><span class="type">int</span> pa[MAXN]; <span class="comment">/*pa[x]表示x的父结点*/</span></span><br><span class="line"><span class="type">int</span> rank[MAXN]; <span class="comment">/*rank[x]是x的高度的一个上界*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*创建一个单元集*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">make_set</span><span class="params">(<span class="type">int</span> x)</span></span><br><span class="line">&#123;</span><br><span class="line">pa[x] = x;</span><br><span class="line">rank[x] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*带路径压缩的查找*/</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">find_set</span><span class="params">(<span class="type">int</span> x)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(x != pa[x])</span><br><span class="line">pa[x] = find_set(p[x]); <span class="comment">//将所有结点的父结点回溯为根结点</span></span><br><span class="line"><span class="keyword">return</span> pa[x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*按秩合并x，y所在的集合*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">union_set</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span><br><span class="line">&#123;</span><br><span class="line">x = find_set(x); <span class="comment">//返回x的根结点</span></span><br><span class="line">y = find_set(y); <span class="comment">//返回y的根结点</span></span><br><span class="line"><span class="keyword">if</span>(rank[x] &gt; rank[y])<span class="comment">/*让rank比较高的作为父结点*/</span></span><br><span class="line">pa[y] = x;</span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line">&#123;</span><br><span class="line">pa[x] = y;</span><br><span class="line"><span class="keyword">if</span>(rank[x] == rank[y]) rank[y]++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&#x3D;&#x3D;Kruskal算法&#x3D;&#x3D;</p><p><strong>基本思想</strong>：<font color=orange>以边为主导地位</font>，始终<font color=orange>选择当前可用</font>（所选的边不能构成回路）<font color=orange>的最小权植边</font>，共选取(V-1)条边（V为顶点数）</p><p><strong>设计思路</strong>：</p><p>(1) 将<font color=orange>边按权值从小到大排序</font>后逐个判断，如果当前的边加入以后不会产生环，那么就把当前边作为生成树的一条边</p><p>(2) 最终得到的结果就是最小生成树</p><p>并查集</p><p><strong>问题描述</strong>：</p><p>某个热带岛屿上村与村之间通过一些丛林小道连接，这些丛林小道需要花费高昂的费用来维护。为了降低维护成本，首席长老决定召开会议，他要长老会的成员估算出每一条丛林小道每月的维护成本（如图所示），然后在这些丛林小道中选取若干条，<font color=skyblue>在保证所有村庄都连接的前提下使得每月所花费的总维护金额最小</font>。请编写一个程序计算维护连接所有村庄的道路系统每月所需最低成本。</p><p><img src="D:\PersonalData\Mango\NEW\Blog\Hexo-blog\blog-mango\source\images\article\算法\tx-kruskal丛林小道.png" alt="image-20230316184025290"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** 数据结构定义和初始化 **/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 定义边(x,y)，权为w */</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">edge</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> x, y;</span><br><span class="line"><span class="type">int</span> w;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAX = <span class="number">26</span>;</span><br><span class="line">edge e[MAX * MAX];</span><br><span class="line"><span class="type">int</span> rank[MAX];<span class="comment">/* rank[x]表示x的秩 */</span></span><br><span class="line"><span class="type">int</span> father[MAX];<span class="comment">/* father[x]表示x的父节点 */</span></span><br><span class="line"><span class="type">int</span> sum; <span class="comment">/*存储最小生成树的总权重 */</span> </span><br><span class="line"></span><br><span class="line"><span class="comment">/* 比较函数，按权值非降序排序 */</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(<span class="type">const</span> edge a, <span class="type">const</span> edge b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> a.w &lt; b.w;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 并查集 **/</span></span><br><span class="line"><span class="comment">/* 初始化集合 */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">make_set</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">father[x] = x;</span><br><span class="line">rank[x] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 查找x元素所在的集合,回溯时压缩路径 */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find_set</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (x != father[x])</span><br><span class="line">&#123;</span><br><span class="line">father[x] = <span class="built_in">find_set</span>(father[x]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> father[x];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 合并x,y所在的集合 */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">union_set</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> w)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (x == y) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (rank[x] &gt; rank[y])</span><br><span class="line">&#123;</span><br><span class="line">father[y] = x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (rank[x] == rank[y])</span><br><span class="line">&#123;</span><br><span class="line">rank[y]++;</span><br><span class="line">&#125;</span><br><span class="line">father[x] = y;</span><br><span class="line">&#125;</span><br><span class="line">sum += w; <span class="comment">//记录权重</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 主函数 **/</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> i, j, k, m, n, t;</span><br><span class="line"><span class="type">char</span> ch;</span><br><span class="line"><span class="keyword">while</span>(cin &gt;&gt; m &amp;&amp; m != <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">k = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; m; i++) <span class="built_in">make_set</span>(i); <span class="comment">//初始化集合，m为顶点个数</span></span><br><span class="line"><span class="comment">//对后m-1进行逐行处理</span></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; m - <span class="number">1</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">cin &gt;&gt; ch &gt;&gt; n; <span class="comment">//获取字符（顶点）</span></span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">&#123;</span><br><span class="line">cin &gt;&gt; ch &gt;&gt; e[k].w; <span class="comment">//获取权重</span></span><br><span class="line">e[k].x = i;</span><br><span class="line">e[k].y = ch - <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line">k++;</span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br><span class="line"><span class="built_in">sort</span>(e, e + k, cmp); <span class="comment">//STL中的函数，直接对数组进行排序</span></span><br><span class="line">sum = <span class="number">0</span>; </span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; k; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> result = <span class="built_in">union_set</span>(<span class="built_in">find_set</span>(e[i].x), <span class="built_in">find_set</span>(e[i].y), e[i].w);</span><br><span class="line"><span class="keyword">if</span>(result) cout&lt;&lt; e[i].x + <span class="number">1</span>&lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; e[i].y + <span class="number">1</span> &lt;&lt;endl;</span><br><span class="line">&#125; </span><br><span class="line">cout &lt;&lt; sum &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>时间复杂度</strong>：</p><p>边排序所需时间：T(n) &#x3D; O(ElogE)</p><p>Kruskal算法的实现通常使用并查集来快速判断两个顶点是否属于同一个集合。<strong>最坏的情况可能要枚举完所有的边，此时要循环|E|次</strong>，所以这一步的时间复杂度为**O(Eα(V))**【采用路径压缩后，每一次查询所用的时间复杂度为增长极为缓慢的Ackerman函数的反函数——α(x) 】，其增长非常慢，可以视为常数</p><p><strong>T(n)&#x3D; O(Eα(V)) + O(ElogE) &#x3D; O(ElogE)</strong> -&gt; <strong>稀疏图</strong></p><h4 id="最小生成树——Dijkstra算法O-V-2"><a href="#最小生成树——Dijkstra算法O-V-2" class="headerlink" title="最小生成树——Dijkstra算法O(V$_2$)"></a>最小生成树——Dijkstra算法O(V$_2$)</h4><p><strong>快递员路线规划</strong>：</p><img src="D:\PersonalData\Mango\NEW\Blog\Hexo-blog\blog-mango\source\images\article\算法\tx-dijkstra快递员路线规划.png" alt="image-20230316184851141" style="zoom:80%;" /><h4 id="单源最短路径问题"><a href="#单源最短路径问题" class="headerlink" title="单源最短路径问题"></a>单源最短路径问题</h4><p><strong>最短路径问题类型</strong></p><p> <strong>单源最短路径</strong>问题（<code>Dijkstra算法</code>、Bellman-Ford算法、SPFA算法……）</p><p> <strong>单终点最短路径</strong>问题 (<code>Dijkstra算法</code>……)</p><p> <strong>单对顶点最短路径</strong>问题 (<code>Dijkstra算法</code>……)</p><p> <strong>每对顶点间最短路径</strong>问题（<code>Dijkstra算法</code>、Floyd-Warshall算法……）</p><p><strong>最短路径</strong>定义：</p><ul><li><strong>非网图</strong>：最短路径是指两顶点之间经历的<font color=orange>边数最少</font>的路径</li><li><strong>网图</strong>：最短路径是指两顶点之间经历的<font color=orange>边上权值之和最小</font>的路径</li></ul><img src="D:\PersonalData\Mango\NEW\Blog\Hexo-blog\blog-mango\source\images\article\算法\tx-dijkstra-最短路径.png" alt="image-20230316185519630" style="zoom:80%;" /><p>&#x3D;&#x3D;单源最短路径&#x3D;&#x3D;问题描述：给定带权有向图G＝(V, E)和源点v∈V，求从v到G中其余各顶点的最短路径</p><p><strong>基本思想</strong>：</p><p> Dijkstra算法：一个 <u>按路径长度递增的次序</u> 产生最短路径的算法，它用于求解<font color=orange>单源最短路径问题</font>，所求解的图中<font color=orange>不能包含负权边</font></p><p> <font color=orange>每次新扩展一个距离最短的点，更新与其相邻的点的距离</font></p><p> 当<font color=orange>所有边权都为正</font>时，由于<font color=orange>不会存在一个距离更短的没扩展过的点</font>，所以这个点的距离永远不会再被改变，保证了算法的正确性</p><p> 有向图和无向图都可以使用本算法，无向图中的每条边可以看成相反的两条边</p><p> 用来求最短路径的<font color=orange>图中不能存在负权边</font></p><p> 引入了<strong>松弛(Relaxation)操作</strong>：先让源点s到顶点i的距离d[i]取一个很大的值，然后不断减小d[i]，当所有的d[i]不能再减小时，就求出了s到所有点的最短路径。<font color=orange>松弛操作的目的是减小d[i]的值，如果从s到达i有更优的路径则更新d[i]</font></p><p><strong>算法流程</strong> 及演示：</p><table><thead><tr><th>s为源，w[u,v]为点u和v之间的边的长度，结果保存在dist[]中</th></tr></thead><tbody><tr><td>(1) <strong>初始化</strong>：源的距离dist[s]设为0，其他的点距离设为无穷大，同时把所有的点的状态都设置为没有扩展过。<br>(2) <strong>循环n-1次</strong>：<br> &amp;nbsp;(2.1) 在没有扩展过的点中取一距离最小的点u，并将其状态设为已扩展。<br>&amp;nbsp; (2.2) 对于每个与u相邻的点v，执行relax(u,v)，也就是说，如果dist[u]+w[u,v]&lt;dist[v]，那么把dist[v]更新成更短的距离dist[u]+w[u,v]。此时到点v的最短路径上，前一个节点即为u。<br>(3) <strong>结束</strong>：此时对于任意的u，dist[u]就是s到u的距离。</td></tr></tbody></table><p><img src="D:\PersonalData\Mango\NEW\Blog\Hexo-blog\blog-mango\source_posts\2023\20230304-算法.assets\image-20230316191251816.png" alt="image-20230316191251816"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 求1到N的最短路,dis[i]表示第i个点到第一个点的最短路 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">dijkstra</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="comment">//初始化距离数组</span></span><br><span class="line">dis[i] = <span class="built_in">map</span>[<span class="number">1</span>][i]; </span><br><span class="line"><span class="type">int</span> k;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line"><span class="type">int</span> tmin = maxint;</span><br><span class="line"><span class="comment">//找出未访问点中距离值最小的点k，标记其为访问过</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line"><span class="keyword">if</span>( !used[j] &amp;&amp; dis[j] &lt; tmin)&#123;</span><br><span class="line">tmin = dis[j];</span><br><span class="line">k = j; </span><br><span class="line">&#125; </span><br><span class="line">used[k] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line"><span class="comment">//对找出的点的相邻边进行松弛操作</span></span><br><span class="line"><span class="keyword">if</span>( dis[k] + <span class="built_in">map</span>[k][j] &lt; dis[j]) </span><br><span class="line">dis[j] = dis[k] + <span class="built_in">map</span>[k][j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编写一个程序实现Dijkstra算法</p><img src="D:\PersonalData\Mango\NEW\Blog\Hexo-blog\blog-mango\source\images\article\算法\tx-dijkstra.png" alt="image-20230316191856347" style="zoom:80%;" /><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX 100</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INF 100000</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Graph</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> edges[MAX][MAX]; <span class="comment">//邻接矩阵</span></span><br><span class="line"><span class="type">int</span> n; <span class="comment">//顶点数</span></span><br><span class="line"><span class="type">int</span> e; <span class="comment">//边数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> visited[MAX]; <span class="comment">//标记顶点是否被访问过</span></span><br><span class="line"><span class="type">int</span> dis[MAX]; <span class="comment">//dis[i]存储结点0到i的最短距离</span></span><br><span class="line">Graph G;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">creatGraph</span><span class="params">()</span> <span class="comment">//用引用作参数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> i,j;</span><br><span class="line"><span class="type">int</span> s,t; <span class="comment">//存储顶点编号</span></span><br><span class="line"><span class="type">int</span> v; <span class="comment">//存储边的权值</span></span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;G.n;i++) <span class="comment">//初始化</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;G.n;j++)</span><br><span class="line">&#123;</span><br><span class="line">G.edges[i][j]=INF; <span class="comment">//注意：初始值为无穷大 ！！！</span></span><br><span class="line">&#125;</span><br><span class="line">visited[i]=<span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;G.e;i++) <span class="comment">//对矩阵相邻的边赋权值</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d&quot;</span>,&amp;s,&amp;t,&amp;v); <span class="comment">//输入边的顶点编号以及权值</span></span><br><span class="line">G.edges[s<span class="number">-1</span>][t<span class="number">-1</span>] = v;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Dijkstra</span><span class="params">()</span> <span class="comment">//求最短路径</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; G.n; i++)</span><br><span class="line">&#123;</span><br><span class="line">dis[i] = INF;</span><br><span class="line">&#125; </span><br><span class="line">    </span><br><span class="line">dis[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; G.n; i++)</span><br><span class="line">&#123;<span class="comment">//每次在还未确定最短路的点中，取一个当前已得到的所有可能的路径长度中最短的那个点，设此点为mark，然后对所有与mark相连的点进行松弛操作</span></span><br><span class="line"><span class="type">int</span> mark = <span class="number">-1</span>, mindis = INF;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; G.n; j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (!visited[j] &amp;&amp; dis[j] &lt; mindis)</span><br><span class="line">&#123;</span><br><span class="line">mindis = dis[j];</span><br><span class="line">mark = j; </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">        </span><br><span class="line">visited[mark] = <span class="literal">true</span>;</span><br><span class="line">        </span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; G.n; k++)</span><br><span class="line">&#123;</span><br><span class="line">dis[k] = <span class="built_in">min</span>(dis[k], dis[mark] + G.edges[mark][k]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> n,e; <span class="comment">//建立的图的顶点数和边数</span></span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>,&amp;n,&amp;e)==<span class="number">2</span>&amp;&amp;n&gt;<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">G.n=n;</span><br><span class="line">G.e=e;</span><br><span class="line"><span class="built_in">creatGraph</span>();</span><br><span class="line"><span class="built_in">Dijkstra</span>();</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">0</span>; k &lt; G.n; k++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, dis[k]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>时间复杂度</strong>：</p><p> T(n) &#x3D; O(V$_2$)</p><p> 如果用<strong>二叉堆</strong>(Binary Heap)优化可以达到<strong>O((E+V)logV)</strong></p><p> 用<strong>斐波那契堆</strong>(Fibonacci Heap)可以优化到<strong>O(VlogV+E)</strong> </p><h2 id="算法——回溯法【DFS-剪枝】"><a href="#算法——回溯法【DFS-剪枝】" class="headerlink" title="算法——回溯法【DFS+剪枝】"></a>算法——回溯法【DFS+剪枝】</h2><p>&#x3D;&#x3D;<strong>DFS+剪枝</strong>&#x3D;&#x3D; 回溯法将问题的解空间转化成<strong>图或者树的结构表示</strong>，然后以<strong>深度优先</strong>的方式搜索解</p><p>空间，并且在搜索过程中用<strong>剪枝函数</strong>避免无效搜索</p><p><u>牧羊人过河问题</u>：</p><p>有一个牧羊人带着一头羊、一只狼和一颗大白菜准备过河，他找到一只很小的船，每次只能带一样东西过去，可是如果让狼与羊单独在一起，狼会吃羊；让羊与白菜单独在一起，羊会吃白菜，牧羊人应如何过河？请设计一个过河方案。</p><p><img src="D:\PersonalData\Mango\NEW\Blog\Hexo-blog\blog-mango\source\images\article\算法\hs-牧羊人过河.png" alt="image-20230316193650570"></p><p><strong>一个可行解：</strong></p><p>• (1) 牧羊人带羊从河西到河东</p><p>• (2) 牧羊人不带任何东西从河东到河西</p><p>• (3) 牧羊人带狼从河西到河东</p><p>• (4) 牧羊人带羊从河东到河西</p><p>• (5) 牧羊人带白菜从河西到河东</p><p>• (6) 牧羊人不带任何东西从河东到河西</p><p>• (7) 牧羊人带羊从河西到河东</p><p>&#x3D;&#x3D;迷宫问题&#x3D;&#x3D;</p><p>输入一个n×n的迷宫，定义左上角为起点，右下角为终点，寻找一条从起点到终点的路径。</p><p><img src="D:\PersonalData\Mango\NEW\Blog\Hexo-blog\blog-mango\source\images\article\算法\hs-迷宫问题.png" alt="image-20230316194046592"></p><p><strong>回溯法基本思想</strong>：</p><p><strong>回溯法：</strong>“<u>通用解题法</u>”，又称为<strong>试探法</strong></p><p>从问题的<font color=orange>某一种状态（初始状态）</font>出发，搜索从这种状态出发所能达到的所有“状态”，当一条路<font color=orange>走到“尽头”</font>的时候（不能再前进），再<font color=orange>后退一步或若干步</font>，从另一种可能“状态”出发，继续搜索，直到所有的“路径”（状态）都试探过。这种<font color=orange>不断“前进”、不断“回溯”寻找解</font>的方法，就称为“回溯法”。</p><p><strong>回溯法的应用步骤</strong></p><p>(1) 针对所给问题，<u>定义问题的解空间</u></p><p>(2) 确定易于搜索的<u>解空间结构</u></p><p>(3) 以<u>深度优先</u>的方式搜索解空间，并且在搜索过程中用<u>剪枝函数</u>避免无效搜索</p><p><strong>常用剪枝函数</strong></p><ul><li><p>用<code>约束(Constraint)函数</code>在扩展结点处剪去不满足约束的子树</p></li><li><p>用<code>限界(Bound)函数</code>剪去得不到最优解的子树</p></li></ul><p><strong>问题的解空间</strong></p><p> <strong>定义</strong>问题的解空间</p><p>• 例：0-1 背包问题——对于有n种物品的，其解空间由长度为n的0-1向量组成，该解空间包含了对变量的所有可能的0-1赋值</p><p>• 当 n&#x3D;3 时，其解空间为{ (0, 0, 0), (0, 0, 1), (0, 1, 0), (0, 1, 1), (1, 0, 0), </p><p>(1, 0, 1), (1, 1, 0), (1, 1, 1) }</p><p> <strong>组织</strong>问题的解空间</p><p>• 通常将解空间组织成<strong>树或图</strong>的形式</p><p>• 例：对于n&#x3D; 3的0-1背包问题，其解空间可以用一棵<code>完全二叉树</code>表示</p><p>• <font color=orange>从树根到叶子结点的任意一条路径可表示解空间中的一个元素</font>，例如某一条路径为(1, 0, 1)，该路径对应解空间中的元素(1, 0, 1)</p><p><strong>回溯法解题的关键要素</strong></p><ul><li><p>回溯法将从<font color=orange>开始结点(根结点)</font>出发，以<font color=orange>深度优先</font>的方式搜索整个解空间</p></li><li><p>开始结点成为<font color=orange>活结点</font>，同时也成为<font color=orange>扩展结点</font></p></li><li><p>在当前的扩展结点处，<strong>向纵深方向搜索并移至一个新结点，这个新结点就成为一个新的活结点</strong>，并成为当前的扩展结点</p></li><li><p>如果<strong>在当前的扩展结点处不能再向纵深方向移动，则当前的扩展结点就成为死结点</strong>，此时应往回移动<font color=orange>（回溯）至最近的一个活结点</font>处，并使其成为当前的扩展结点</p></li><li><p>回溯法以上述工作方式递归地在解空间中搜索，<strong>直至找到所要求的解或解空间中已无活结点时为止</strong></p></li></ul><p>&#x3D;&#x3D;搜索框架&#x3D;&#x3D;</p><p>回溯法对解空间开展<strong>深度优先</strong>搜索；在一般情况下用<code>递归(DFS)</code>方法实现回溯法</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">backtrack</span> <span class="params">(<span class="type">int</span> t)</span> <span class="comment">// t：递归深度</span></span><br><span class="line">&#123; </span><br><span class="line"><span class="keyword">if</span> (t&gt;n) output(x); <span class="comment">//当搜索到叶结点，输出可行解</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i=f(n,t); i&lt;=g(n,t); i++) <span class="comment">//从下界 to 上界</span></span><br><span class="line">&#123; </span><br><span class="line">x[t]=h(i);</span><br><span class="line"><span class="keyword">if</span> (Constraint(t) &amp;&amp; Bound(t)) <span class="comment">//满足约束条件和限界函数</span></span><br><span class="line">backtrack(t+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&#x3D;&#x3D;子集树&#x3D;&#x3D;：从n个元素的集合找出满足某种性质的子集，相应的解空间树称为子集树</p><img src="D:\PersonalData\Mango\NEW\Blog\Hexo-blog\blog-mango\source\images\article\算法\hs-子集树.png" alt="image-20230316195355236" style="zoom:80%;" /><p>&#x3D;&#x3D;排列树&#x3D;&#x3D;：确定n个元素满足某种性质的排列，相应的解空间树称为排列树</p><img src="D:\PersonalData\Mango\NEW\Blog\Hexo-blog\blog-mango\source\images\article\算法\hs-排列树.png" alt="image-20230316195519776" style="zoom:80%;" /><p>回溯法<strong>主要用途</strong>：</p><ul><li><p><font color=orange>求问题所有解</font>：要回溯到根，且根结点的所有子树都已被搜索才结束</p></li><li><p><font color=orange>求问题的最优解</font>：在所有解中找出具有最优值的解，所有子树都已被搜索才结束</p></li><li><p><font color=orange>求任一解</font>：只要搜索到问题的一个解就可结束</p></li></ul><h3 id="油田问题"><a href="#油田问题" class="headerlink" title="油田问题"></a>油田问题</h3><p>输入一个m行n列的字符矩阵，统计字符“@”组成多少个八连块。如果两个字符“@”所在的格子相邻（横、竖或者对角线方向），即属于同一个八连块。例如：下图有两个八连块</p><table><thead><tr><th>搜索策略</th><th></th></tr></thead><tbody><tr><td>从每个“@”格子出发，递归遍历它周围的“@”格子</td><td><img src="D:\PersonalData\Mango\NEW\Blog\Hexo-blog\blog-mango\source_posts\2023\20230304-算法.assets\hs-油田.png" alt="image-20230316200202672"></td></tr><tr><td>每次访问一个格子时就给它写上一个“连通分量编号idx”</td><td></td></tr><tr><td>可以在访问之前检查它是否已经有了编号，从而避免同一个格子访问多次</td><td></td></tr></tbody></table><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">105</span>;</span><br><span class="line"><span class="type">char</span> pic[maxn][maxn] = &#123;<span class="string">&quot;****@&quot;</span>,<span class="string">&quot;*@@*@&quot;</span>,<span class="string">&quot;*@**@&quot;</span>,<span class="string">&quot;@@@*@&quot;</span>,<span class="string">&quot;@@**@&quot;</span>&#125;;</span><br><span class="line"><span class="type">int</span> m = <span class="number">5</span>, n = <span class="number">5</span>,idx[maxn][maxn];</span><br><span class="line"><span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">slove</span><span class="params">(<span class="type">int</span> r, <span class="type">int</span> c, <span class="type">int</span> id)</span> &#123;</span><br><span class="line"><span class="keyword">if</span>(r&lt;<span class="number">0</span>||r&gt;=m||c&lt;<span class="number">0</span>||c&gt;=n) <span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">if</span>(idx[r][c]&gt;<span class="number">0</span> || pic[r][c]!=<span class="string">&#x27;@&#x27;</span>) <span class="keyword">return</span>;</span><br><span class="line">idx[r][c] = id;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> dr=<span class="number">-1</span>; dr&lt;=<span class="number">1</span>; dr++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> dc=<span class="number">-1</span>;dc&lt;=<span class="number">1</span>;dc++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(dr!=<span class="number">0</span>||dc!=<span class="number">0</span>) slove(r+dr, c+dc, id);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="built_in">memset</span>(idx,<span class="number">0</span>,<span class="keyword">sizeof</span>(idx));</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;m;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;n;j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(idx[i][j]==<span class="number">0</span>&amp;&amp;pic[i][j]==<span class="string">&#x27;@&#x27;</span>) slove(i,j,++cnt);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,cnt);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="马的遍历问题"><a href="#马的遍历问题" class="headerlink" title="马的遍历问题"></a>马的遍历问题</h3><p>在n*m的棋盘中，马只能走斜“日”字。马从位置(x, y)处出发，把棋盘的每一格都走一次，且只走一次，请找出所有路径。</p><p><strong>算法设计</strong>：</p><p><strong>问题解的搜索空间：</strong>棋盘的规模是n*m，搜索空间是整个棋盘上的n*m个点，用n*m的二维数组记录马行走的过程，初值为0表示未经过</p><p><strong>在寻找路径过程中，活结点的扩展规则：</strong></p><p><img src="D:\PersonalData\Mango\NEW\Blog\Hexo-blog\blog-mango\source\images\article\算法\hs-马的遍历.png" alt="image-20230316221214376"></p><p><strong>扩展的约束条件：</strong></p><p>• <font color=orange>不出边界</font></p><p>• <font color=orange>每个点只经过一次</font></p><p>• 函数check()，检查当前状态是否合理</p><p>棋盘点对应的数组元素初值为0，对走过的棋盘点的值置为所走步数，<font color=orange>起点存储“1” ，终点存储“n*m”</font></p><p><strong>搜索解空间：</strong></p><p>• 搜索过程是从任一点(x, y)出发，按深度优先的原则，从8个方向中尝试一个可以走的棋盘点，直到走过棋盘上所有n*m个点</p><p>• 用一个<font color=orange>变量dep记录递归深度</font>，也就是走过的点数，当dep&#x3D;&#x3D;n*m时，找到一组解</p><p>• 用<font color=orange>n*m的二维数组记录马行走的过程</font>，初始值为0表示未经过。搜索完毕后，起点存储的是“1”，终点存储的是“n*m”</p><p>• 可使用<font color=orange>递归</font>实现</p><p>• <strong>注意：</strong>问题要求找出全部可能的解，需注意回溯过程的清理现场工作，即置当前位置为未经过</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> n=<span class="number">5</span>,m=<span class="number">4</span>;</span><br><span class="line"><span class="type">int</span> fx[<span class="number">8</span>]=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">-1</span>,<span class="number">-2</span>,<span class="number">-2</span>,<span class="number">-1</span>&#125;;</span><br><span class="line"><span class="type">int</span> fy[<span class="number">8</span>]=&#123;<span class="number">2</span>,<span class="number">1</span>,<span class="number">-1</span>,<span class="number">-2</span>,<span class="number">-2</span>,<span class="number">-1</span>,<span class="number">1</span>,<span class="number">2</span>&#125;;</span><br><span class="line"><span class="type">int</span> A[n+<span class="number">1</span>][m+<span class="number">1</span>]; <span class="comment">//下标从1开始</span></span><br><span class="line"><span class="type">int</span> dep,x,y,numbers=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(x&gt;=<span class="number">1</span> &amp;&amp; x&lt;=n &amp;&amp; y&gt;=<span class="number">1</span> &amp;&amp; y&lt;=m &amp;&amp;(!A[x][y]) )</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">output</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> x=<span class="number">1</span>;x&lt;=n;x++)</span><br><span class="line">&#123;</span><br><span class="line">cout&lt;&lt;endl;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> y=<span class="number">1</span>;y&lt;=m;y++)</span><br><span class="line">cout&lt;&lt;A[x][y]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;endl;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;----------------------------&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y,<span class="type">int</span> dep)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> i,xx,yy;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;=<span class="number">7</span>;i++) <span class="comment">//加上方向增量，形成新的坐标</span></span><br><span class="line">&#123;</span><br><span class="line">xx=x+fx[i];</span><br><span class="line">yy=y+fy[i];</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">check</span>(xx,yy)) <span class="comment">//判断新坐标是否出界，是否已走过</span></span><br><span class="line">&#123;</span><br><span class="line">A[xx][yy]=dep;</span><br><span class="line"><span class="keyword">if</span>(dep==n*m)</span><br><span class="line">&#123;</span><br><span class="line">numbers++;</span><br><span class="line"><span class="built_in">output</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">solve</span>(xx,yy,dep+<span class="number">1</span>);</span><br><span class="line">A[xx][yy]=<span class="number">0</span>; <span class="comment">//回溯，恢复未走</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> i,j;</span><br><span class="line">dep=<span class="number">1</span>;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;Please input x,y&quot;</span>&lt;&lt;endl;</span><br><span class="line">cin&gt;&gt;x&gt;&gt;y;</span><br><span class="line"><span class="keyword">if</span>(x&gt;n||y&gt;m||x&lt;<span class="number">1</span>||y&lt;<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;Input error!&quot;</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line"><span class="keyword">for</span>(j=<span class="number">1</span>;j&lt;=m;j++)</span><br><span class="line">A[i][j]=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    A[x][y]=<span class="number">1</span>;</span><br><span class="line"><span class="built_in">solve</span>(x,y,<span class="number">2</span>);</span><br><span class="line"><span class="keyword">if</span>(numbers==<span class="number">0</span>) cout&lt;&lt;<span class="string">&quot;No solution!&quot;</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">cout&lt;&lt;endl;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;Number of solution(s)=&quot;</span>&lt;&lt;numbers&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="N皇后问题"><a href="#N皇后问题" class="headerlink" title="N皇后问题"></a>N皇后问题</h3><p>在Ｎ*Ｎ的棋盘上放置Ｎ个皇后，要求每一行、每一列、每一条对角线上均只能放置一个皇后，求可能的方案及方案数。</p><p>• 问题的状态即棋盘的布局状态，<font color=greenblue>状态空间树的根为空棋盘</font>，每个布局的下一步可能布局为该布局结点的子结点</p><p>• <font color=greenblue>任意两个王后不放在同一行或同一列或同一斜线</font></p><p>• 为了简化状态空间树，采用<font color=greenblue>逐行布局</font>的方式，即每个布局有n个子结点</p><p><img src="D:\PersonalData\Mango\NEW\Blog\Hexo-blog\blog-mango\source\images\article\算法\hs-N皇后问题.png" alt="image-20230316222322363"></p><p><strong>回溯过程分析</strong>：</p><img src="D:\PersonalData\Mango\NEW\Blog\Hexo-blog\blog-mango\source\images\article\算法\hs-N皇后-回溯过程.png" alt="image-20230316222443555" style="zoom:70%;" /><p><strong>数据结构分析</strong>：</p><p>二维数组**A[N][N]**存储皇后位置</p><p>• 若第i行第j列放有皇后，则A[i][j]为非0值，否则值为0</p><p>一维数组**M[k]、L[k]、R[k]**分别表示竖列、左斜线、右斜线是否放有皇后，有则值为1，否则值为0</p><p><img src="D:\PersonalData\Mango\NEW\Blog\Hexo-blog\blog-mango\source\images\article\算法\hs-N皇后-数据结构分析1.png" alt="image-20230316224739861"></p><p><img src="D:\PersonalData\Mango\NEW\Blog\Hexo-blog\blog-mango\source\images\article\算法\hs-N皇后-数据结构分析2.png" alt="image-20230316224939690"></p><p><img src="D:\PersonalData\Mango\NEW\Blog\Hexo-blog\blog-mango\source\images\article\算法\hs-N皇后-数据结构分析3.png" alt="image-20230316225140618"></p><img src="D:\PersonalData\Mango\NEW\Blog\Hexo-blog\blog-mango\source\images\article\算法\hs-N皇后-数据结构分析4.png" alt="image-20230316225227651" style="zoom:80%;" /><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"># 算法描述</span><br><span class="line"></span><br><span class="line">初始化</span><br><span class="line"><span class="keyword">for</span>(某一行的每个位置)</span><br><span class="line"><span class="keyword">if</span> (安全检测通过)</span><br><span class="line">&#123;</span><br><span class="line">放皇后;</span><br><span class="line"><span class="keyword">if</span> (已到最后一行) &#123; 输出; &#125;</span><br><span class="line"><span class="keyword">else</span> 试探下一行;</span><br><span class="line">去皇后;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">安全检测算法：!M[j] &amp;&amp; !R[i-j+N] &amp;&amp; !L[i+j];</span><br><span class="line">放皇后：A[i][j] = M[j] = R[i-j+N] = L[i+j] = <span class="number">1</span>;   </span><br><span class="line">去皇后：A[i][j] = M[j] = R[i-j+N] = L[i+j] = <span class="number">0</span>;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*****************核心代码**********************/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 4 <span class="comment">/*N为皇后个数*/</span></span></span><br><span class="line"><span class="type">int</span> count=<span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> M[N]=&#123;<span class="number">0</span>&#125;,L[<span class="number">2</span>*N]=&#123;<span class="number">0</span>&#125;,R[<span class="number">2</span>*N]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="type">int</span> A[N][N]=&#123;<span class="number">0</span>&#125;; <span class="comment">/*皇后位置*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">int</span> A[N][N])</span> <span class="comment">/*输出*/</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> i,j;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;N;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;N;j++)</span><br><span class="line">cout&lt;&lt;A[i][j]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">cout&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*试探每一行皇后的位置*/</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">solve</span><span class="params">(<span class="type">int</span> i,<span class="type">int</span> M[N],<span class="type">int</span> L[<span class="number">2</span>*N],<span class="type">int</span> R[<span class="number">2</span>*N],<span class="type">int</span> A[N][N])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>; j&lt;N;j++) <span class="comment">//放置在i行j列</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(!M[j]&amp;&amp;!L[i-j+N]&amp;&amp;!R[i+j]) <span class="comment">//安全检查</span></span><br><span class="line">&#123;</span><br><span class="line">A[i][j]=i+<span class="number">1</span>; <span class="comment">//放皇后</span></span><br><span class="line">M[j]=L[i-j+N]=R[i+j]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(i==N<span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">print</span>(A); cout&lt;&lt;endl; count++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">solve</span>(i+<span class="number">1</span>,M,L,R,A); <span class="comment">//试探下一行</span></span><br><span class="line">A[i][j]=<span class="number">0</span>; <span class="comment">//去皇后</span></span><br><span class="line">M[j]=L[i-j+N]=R[i+j]=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> n=<span class="built_in">solve</span>(<span class="number">0</span>,M,L,R,A); <span class="comment">//代表从0行开始试探</span></span><br><span class="line">cout&lt;&lt;<span class="string">&quot;\n count=&quot;</span>&lt;&lt;n; <span class="comment">//n可行解数目</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>素数环问题：</strong>将从1到n这n个整数围成一个圆环，若其中任意2个相邻的数字相加，结果均为素数，那么这个环就成为素数环。</p><p>输入一个正整数n(n&lt;&#x3D;16)，输出所有的素数环。</p></blockquote><h3 id="图的m着色问题O-m-n"><a href="#图的m着色问题O-m-n" class="headerlink" title="图的m着色问题O(m$^n$)"></a>图的m着色问题O(m$^n$)</h3><p><code>四色问题</code>又称<code>四色猜想、四色定理</code>，是世界近代三大数学难题之一。四色问题的内容是“任何一张地图只用四种颜色就能使具有共同边界的国家着上不同的颜色。”</p><p>图的m着色问题 &#x3D;&gt; 研究如何用m种颜色为地图着色</p><p>问题描述：</p><p>给定<strong>无向连通图G</strong>和<strong>m种不同的颜色</strong>，用这些颜色为图G的各顶点着色，每个顶点着一种颜色。</p><p><font color=orange>如果有一种着色方案使G中每条边的两个顶点着不同颜色，则称这个图是m可着色的</font>。</p><p>图的m着色问题是对于给定图G和m种颜色，找出所有不同的着色方案，使得图G中任意一条边的两个顶点着不同的颜色。</p><img src="D:\PersonalData\Mango\NEW\Blog\Hexo-blog\blog-mango\source\images\article\算法\hs-图的m着色.png" alt="image-20230316230243776" style="zoom:80%;" /><p><strong>设计思路</strong>:</p><p>【数据结构设计】</p><ul><li>邻接矩阵（二维数组）：存储图graph[N+1][N+1]</li><li>一维数组：存储每个节点的颜色colors[N+1]，colors[t]&#x3D;i表示节点t的颜色为i</li></ul><img src="D:\PersonalData\Mango\NEW\Blog\Hexo-blog\blog-mango\source\images\article\算法\hs-图的m着色数据结构设计.png" alt="image-20230316230605847" style="zoom: 67%;" /><p>【解空间树】</p><p><img src="D:\PersonalData\Mango\NEW\Blog\Hexo-blog\blog-mango\source\images\article\算法\hs-图的m着色-解空间树.png" alt="image-20230316230757911"></p><p>【剪枝函数设计】</p><p>如何判断是否能够着色？新加入的节点t取某一种颜色i时，依次和上层的每一个节点j(j&lt;t)比较。如果graph[t][j]&#x3D;1并且colors[j]&#x3D;i，那么它是不可着色的。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">check</span><span class="params">(<span class="type">int</span> t,<span class="type">int</span> i)</span> <span class="comment">//剪枝函数</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> j;</span><br><span class="line"><span class="keyword">for</span>( j=<span class="number">1</span>;j&lt;t;j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(graph[t][j]&amp;&amp;colors[j]==i)</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="D:\PersonalData\Mango\NEW\Blog\Hexo-blog\blog-mango\source\images\article\算法\hs-图的m着色-搜索函数设计.png" alt="image-20230316231254219" style="zoom:70%;" /><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/******************核心代码********************/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">backtrace</span><span class="params">(<span class="type">int</span> t,<span class="type">int</span> m)</span> <span class="comment">//递归函数</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> i;</span><br><span class="line"><span class="keyword">if</span>(t&gt;N)<span class="comment">//算法搜索至叶子节点</span></span><br><span class="line">&#123;</span><br><span class="line">sum++;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;第%d种方案：\n&quot;</span>,sum);</span><br><span class="line"><span class="keyword">for</span>( i=<span class="number">1</span>;i&lt;=N;i++)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,colors[i]);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=m;i++) &#123;</span><br><span class="line"><span class="keyword">if</span>(check(t,i)) &#123;</span><br><span class="line">colors[t]=i;</span><br><span class="line">backtrace(t+<span class="number">1</span>,m);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> <span class="comment">//主函数</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> m;</span><br><span class="line"><span class="type">int</span> i;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;请输入颜色种类：\n&quot;</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;m);</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=m;i++) <span class="comment">//初始化</span></span><br><span class="line">colors[i]=<span class="number">0</span>;</span><br><span class="line">backtrace(<span class="number">1</span>,m);</span><br><span class="line"><span class="keyword">if</span>(sum==<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;不是%d可着色的!\n&quot;</span>,m);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>时间复杂度分析</strong></p><p>对于算法中的每个顶点可试探<strong>1-m种颜色</strong>，一共有<strong>n个顶点</strong></p><p>对应的解空间树是<strong>一颗高为n的m叉树</strong>（子集树）</p><p>时间复杂度为：<strong>T(n) &#x3D; O(m$^n$)</strong></p><p><img src="D:\PersonalData\Mango\NEW\Blog\Hexo-blog\blog-mango\source\images\article\算法\hs-图的m着色-T.png" alt="image-20230316231710993"></p><h3 id="0-1背包问题O-n2-n"><a href="#0-1背包问题O-n2-n" class="headerlink" title="0-1背包问题O(n2$^n$)"></a>0-1背包问题O(n2$^n$)</h3><p>0-1背包问题 物品重量可能不是正整数? 背包容量可能不是正整数?</p><p>给定n种物品（每种物品只有一件）和一个背包：物品i的重量是w$_i$ ，其价值为v$_i$ ，背包的容量为C。问应如何选择装入背包的物品，使得装入背包中物品的总价值最大?</p><p> 对于每种物品，<font color=orange>只有两种选择：拿(1)或者不拿(0)，不允许拿物品的一部分</font></p><p> 物品重量和背包容量可为<font color=orange>正整数或小数</font><br>$$<br>\begin{aligned}<br> \left { \begin{aligned}<br>       \sum_{i&#x3D;1}^nw_ix_i \leq C \<br>        x_i \in{0,1},1 \leq i \leq n<br>       \end{aligned}<br> \right .%加右}<br> \qquad \text max \sum_{i&#x3D;1}^nv_ix_i<br>\end{aligned}<br>$$<br><strong>算法设计</strong>：</p><p>解空间：</p><p><img src="D:\PersonalData\Mango\NEW\Blog\Hexo-blog\blog-mango\source_posts\2023\20230304-算法.assets\hs-01背包解空间-子集树.png"></p><p>基本思想：</p><p>按贪心算法的思路，优先装入<font color=orange>价值&#x2F;重量比</font>大的物品</p><p>当剩余容量装不下后续考虑的物品时，再用回溯法修改先前的装入方案</p><p>直到求得全局最优解为止</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 核心代码</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*数据结构*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 5 <span class="comment">//物品数目</span></span></span><br><span class="line"><span class="type">int</span> v[]=&#123;<span class="number">6</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">5</span>,<span class="number">4</span>&#125;,w[]=&#123;<span class="number">2</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">5</span>&#125;;</span><br><span class="line"><span class="type">int</span> C=<span class="number">10</span>; <span class="comment">//背包容量</span></span><br><span class="line"><span class="type">int</span> cv; <span class="comment">//当前价值</span></span><br><span class="line"><span class="type">int</span> bestv=<span class="number">0</span>; <span class="comment">//最优价值</span></span><br><span class="line"><span class="type">int</span> x[N]; <span class="comment">//当前解</span></span><br><span class="line"><span class="type">int</span> bestx[N]; <span class="comment">//当前最优解</span></span><br><span class="line"><span class="type">int</span> cw=<span class="number">0</span>; <span class="comment">//当前重量</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//输出</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">display</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;物品放入背包状态为：&quot;</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;N;i++)</span><br><span class="line">cout&lt;&lt;<span class="built_in">setw</span>(<span class="number">5</span>)&lt;&lt;x[i];</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;，获得的价值=&quot;</span>&lt;&lt;cv;</span><br><span class="line">cout&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 搜索函数</span></span><br><span class="line"><span class="comment">//回溯</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">backtrack</span><span class="params">(<span class="type">int</span> t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(t&gt;=N)&#123;</span><br><span class="line"><span class="keyword">if</span>(bestv&lt;cv) &#123;</span><br><span class="line">bestv=cv; <span class="comment">//保存最优解</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">0</span>;j&lt;N;j++)</span><br><span class="line">bestx[j]=x[j];</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">display</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">//搜索左枝</span></span><br><span class="line"><span class="keyword">if</span>(cw+w[t]&lt;=C) &#123;</span><br><span class="line">x[t]=<span class="number">1</span>; cv+=v[t]; cw+=w[t];</span><br><span class="line"><span class="built_in">backtrack</span>(t+<span class="number">1</span>); <span class="comment">//继续向下深度搜索</span></span><br><span class="line">x[t]=<span class="number">0</span>; cv-=v[t]; cw-=w[t]; <span class="comment">//回退</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//搜索右枝</span></span><br><span class="line">x[t]=<span class="number">0</span>;</span><br><span class="line"><span class="built_in">backtrack</span>(t+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//按物品价值重量比排降序（此处省略）</span></span><br><span class="line"><span class="built_in">backtrack</span>(<span class="number">0</span>);</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;最优价值:&quot;</span>&lt;&lt;bestv&lt;&lt;<span class="string">&quot;\t&quot;</span>;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;此时放入背包物品:&quot;</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;N;j++)</span><br><span class="line"><span class="keyword">if</span>(bestx[j]==<span class="number">1</span>)</span><br><span class="line">cout&lt;&lt;j+<span class="number">1</span>&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">cout&lt;&lt;endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>改进思路：</p><p>前述算法完全搜索解空间树：</p><p>• <font color=orange>用约束条件确定是否搜索其左子树</font></p><p>• <font color=blue>对右子树没有任何判断，一定进入右子树</font> -&gt; 耗时</p><p>改进后搜索解空间树策略：</p><p>• 只要其左子结点是一个可行结点，搜索就进入其左子树 <strong>— 约束函数</strong> （是否可行解）左子树剪枝</p><p>• 当右子树有可能包含最优解时才进入右子树搜索，否则将右子树剪去 <strong>— 限界函数</strong>（是否更优解）右子树剪枝</p><p>剪枝方法：</p><ul><li><p><code>r：当前剩余物品价值总和</code></p></li><li><p><code>cv：当前获得价值</code></p></li><li><p><code>bestv：当前最优价值</code></p></li><li><p><font color=orange>当cv+r &lt;&#x3D; bestv时，可剪去右子树</font> -&gt; <font color=greensky>当前价值与剩余物品价值之和小于等于已求最优价值，即无法得到更优解</font></p></li></ul><p>计算右子树上界的方法【<strong>贪心求得上界</strong>】：</p><p>• 将剩余物品依其 <strong>单位重量价值排序，然后依次装入物品</strong>，直至装不下时，再装入该物品的一部分而装满背包。<strong>此时得到的价值是右子树中解的上界</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">bound</span><span class="params">(<span class="type">int</span> i)</span> <span class="comment">//计算当前结点处上界</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> left=C-cw; <span class="comment">//剩余容量</span></span><br><span class="line"><span class="type">int</span> b=cv; <span class="comment">//cv当前价值</span></span><br><span class="line"><span class="keyword">while</span>(w[i]&lt;=left &amp;&amp; i&lt;=N)</span><br><span class="line">&#123;</span><br><span class="line">b+=v[i];</span><br><span class="line">left-=w[i];</span><br><span class="line">i++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*装满背包*/</span></span><br><span class="line"><span class="keyword">if</span>(i&lt;=N)</span><br><span class="line">b+=left*v[i]/w[i];</span><br><span class="line"><span class="keyword">return</span> b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//回溯</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">backtrack</span><span class="params">(<span class="type">int</span> t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(t&gt;=N)&#123;<span class="comment">//代码省略&#125;</span></span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">//搜索左枝</span></span><br><span class="line"><span class="keyword">if</span>(cw+w[t]&lt;=C)</span><br><span class="line">&#123;</span><br><span class="line">x[t]=<span class="number">1</span>; cv+=v[t]; cw+=w[t];</span><br><span class="line"><span class="built_in">backtrack</span>(t+<span class="number">1</span>); <span class="comment">//继续向下深度搜索</span></span><br><span class="line">x[t]=<span class="number">0</span>; cv-=v[t]; cw-=w[t];<span class="comment">//回退</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//搜索右枝</span></span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">bound</span>(t+<span class="number">1</span>)&gt;bestv)</span><br><span class="line">&#123;</span><br><span class="line">x[t]=<span class="number">0</span>;</span><br><span class="line"><span class="built_in">backtrack</span>(t+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="D:\PersonalData\Mango\NEW\Blog\Hexo-blog\blog-mango\source\images\article\算法\hs-01背包实例.png" alt="image-20230317011838047"></p><p><strong>时间复杂度分析</strong></p><p>在最坏情况下，所搜索的结果是一个满二叉树 -&gt; <strong>穷举法</strong></p><p>时间复杂度为<strong>O(2$^n$)</strong></p><p>计算上界函数bound()需要**O(n)**时间</p><p>在最坏情况下有O(2$^n$)个右子结点需要计算上界函数</p><p>最坏情况下时间复杂度：<strong>T(n) &#x3D; O(n2$^n$)</strong></p><h3 id="TSP旅行售货员问题-O-n"><a href="#TSP旅行售货员问题-O-n" class="headerlink" title="TSP旅行售货员问题 O(n!)"></a>TSP旅行售货员问题 <strong>O(n!)</strong></h3><p><img src="D:\PersonalData\Mango\NEW\Blog\Hexo-blog\blog-mango\source\images\article\算法\hs-旅行售货员-哈密顿图.png" alt="image-20230317012616519"></p><p>问题描述：</p><p><strong>旅行售货员问题</strong>(Traveling Salesman Problem, <strong>TSP</strong>)：某售货员要到若干城市去推销商品，下图显示了各城市之间的路程，他要选定一条从驻地出发，经过每个城市一遍，最后回到出发地的路线，使总的路程最短。（假设售货员的驻地为1）</p><p>&#x3D;&gt; 在图中寻找总权重最小的哈密顿回路，即通过图的每个顶点一次，且仅一次的最小回路</p><img src="D:\PersonalData\Mango\NEW\Blog\Hexo-blog\blog-mango\source\images\article\算法\hs-旅行售货员问题.png" alt="image-20230317012854039" style="zoom:80%;" /><p><strong>中国邮递员问题</strong>(Chinese Postman Problem, <strong>CPP</strong>)：一个邮递员从邮局出发，到所辖街道投邮件，最后返回邮局，如果他必须走遍所辖的每条街道至少一次，那么他应该如何选择投递路线，使所走的路程最短？</p><hr><p>给定一个连通图G，每条边e的权重均为非负数，要求找出一条回路经过每条边至少一次，且满足总权重最小 -&gt; &#x3D;&#x3D;欧拉回路&#x3D;&#x3D;</p><p><strong>算法设计</strong>：</p><p>&#x3D;&#x3D;解空间树&#x3D;&#x3D;</p><p>其解空间可以组织成一棵树；从树的根结点到任一结点的路径定义了图G的一条周游路线</p><p> 旅行售货员问题的解空间是一棵<font color=orange>排列树</font>，叶节点个数（周游线路）&#x3D;<strong>(n-1)!</strong></p><p> 对于排列树的回溯搜索与生成1，2，…，n的全排列的递归算法类似</p><p> 开始时x&#x3D;[1,2,…,n]，相应的排列树由x[1:n]的所有排列构成</p><p><img src="D:\PersonalData\Mango\NEW\Blog\Hexo-blog\blog-mango\source_posts\2023\20230304-算法.assets\hs-TSP解空间树.png"></p><p>算法步骤：</p><p>在递归过程中，当<code>i=n</code>时，当前的扩展结点是排列树的<strong>叶结点的父结点</strong></p><p>• 检测图G<strong>是否存在一条从顶点x[n-1]到顶点x[n]的边和从顶点x[n]到顶点1的边</strong></p><p>• 如果这两条边都存在，则找到一条旅行售货员回路</p><p>• 此时，还需要<strong>判别这条回路的费用是否优于当前已经找到的最优回路的费用bestc</strong></p><p>• 如果是，则必须更新当前的最优值bestc和当前的最优解bestx</p><p>在递归过程中，当<code>i&lt;n</code>时，当前的扩展结点位于排列树的第i-1层</p><p>• 图G中<strong>存在从顶点x[i-1]到达顶点x[i]的边</strong>时，x[1:i]构成图G中的一条路径，<strong>且当x[1:i]的费用小于当前最优值时算法进入排列树的第i层</strong></p><p>• 否则，则剪去相应的子树</p><p>• <font color=orange>算法中用变量cc记录当前路径的费用</font></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 数据结构</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NUM 100</span></span><br><span class="line"><span class="type">int</span> n=<span class="number">4</span>; <span class="comment">//图G的顶点个数</span></span><br><span class="line"><span class="type">int</span> graph[NUM][NUM] = &#123;&#123;<span class="number">-1</span>,<span class="number">-1</span>,<span class="number">-1</span>,<span class="number">-1</span>,<span class="number">-1</span>&#125;,&#123;<span class="number">-1</span>,-</span><br><span class="line"><span class="number">1</span>,<span class="number">30</span>,<span class="number">6</span>,<span class="number">4</span>&#125;,&#123;<span class="number">-1</span>,<span class="number">30</span>,<span class="number">-1</span>,<span class="number">5</span>,<span class="number">10</span>&#125;,&#123;<span class="number">-1</span>,<span class="number">6</span>,<span class="number">5</span>,<span class="number">-1</span>,<span class="number">20</span>&#125;,&#123;<span class="number">-1</span>,<span class="number">4</span>,<span class="number">10</span>,<span class="number">20</span>,<span class="number">-1</span>&#125;&#125;; </span><br><span class="line"><span class="comment">//图G的邻接矩阵</span></span><br><span class="line"><span class="type">int</span> x[NUM]; <span class="comment">//当前解</span></span><br><span class="line"><span class="type">int</span> bestx[NUM]; <span class="comment">//最优解</span></span><br><span class="line"><span class="type">int</span> cc=<span class="number">0</span>; <span class="comment">//当前费用</span></span><br><span class="line"><span class="type">int</span> NoEdge=<span class="number">-1</span>; <span class="comment">//无边标记</span></span><br><span class="line"><span class="type">int</span> bestc=<span class="number">-1</span>; <span class="comment">//最优费用</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 搜索+剪枝</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">backtrack</span><span class="params">(<span class="type">int</span> t)</span> <span class="comment">//t从2开始</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//到达第n个节点</span></span><br><span class="line"><span class="keyword">if</span>(t==n) &#123;</span><br><span class="line"><span class="keyword">if</span>(graph[x[n<span class="number">-1</span>]][x[n]]!=NoEdge&amp;&amp;(graph[x[n]][<span class="number">1</span>]!=NoEdge)&amp;&amp;(cc+graph[x[n<span class="number">-1</span>]][x[n]]+graph[x[n]][<span class="number">1</span>]&lt;bestc||bestc==<span class="number">-1</span>)) &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">bestx[i]=x[i];</span><br><span class="line">&#125;</span><br><span class="line">bestc=cc+graph[x[n<span class="number">-1</span>]][x[n]]+graph[x[n]][<span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=t;i&lt;=n;i++) &#123;</span><br><span class="line"><span class="comment">//如果上一个节点和它此后的节点有边，并且费用低于现有的最优费用，bestc==-1表示第一次计算</span></span><br><span class="line"><span class="keyword">if</span>(graph[x[t<span class="number">-1</span>]][x[i]]!=NoEdge &amp;&amp; (cc+graph[x[t<span class="number">-1</span>]][x[i]]&lt;bestc ||bestc==<span class="number">-1</span>)) &#123;</span><br><span class="line"><span class="built_in">swap</span>(x[t],x[i]);</span><br><span class="line">cc+=graph[x[t<span class="number">-1</span>]][x[t]];</span><br><span class="line"><span class="built_in">backtrack</span>(t+<span class="number">1</span>);</span><br><span class="line">cc-=graph[x[t<span class="number">-1</span>]][x[t]];</span><br><span class="line"><span class="built_in">swap</span>(x[t],x[i]);</span><br><span class="line">&#125; </span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">x[i]=i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">backtrack</span>(<span class="number">2</span>);</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;最少旅行费用为: &quot;</span>&lt;&lt;bestc&lt;&lt;endl;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;旅行路径为:&quot;</span>&lt;&lt;endl;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">cout&lt;&lt;bestx[i]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;bestx[<span class="number">1</span>];</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>算法效率：</p><p>从第一个城市到第二个城市有n-1种走法，从第二个城市到第三个城市有n-2种走法……因而共有(n-1)!种走法</p><p>若考虑v$_1$v$_2$…v$_n$v$_1$和v$_1$v$<em>n$v$</em>{n-1}$…v$_2$v$_1$是同一条回路，共有**(1&#x2F;2)(n-1)!**条不同的哈密顿回路</p><p>为了比较权重的大小，对每条哈密顿回路要做n-1次加法，故加法的总数为(1&#x2F;2)(n-1)(n-1)!</p><p>使用回溯法求解TSP问题的时间复杂度：<strong>T(n) &#x3D; O(n!)</strong> </p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> 算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>【CSS必备】前端页面一键置灰</title>
      <link href="/posts/e013aa32.html"/>
      <url>/posts/e013aa32.html</url>
      
        <content type="html"><![CDATA[<h1 id="前端页面一键置灰"><a href="#前端页面一键置灰" class="headerlink" title="前端页面一键置灰"></a>前端页面一键置灰</h1><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">body</span>,<span class="selector-tag">html</span> &#123;</span><br><span class="line">    <span class="attribute">filter</span>: <span class="built_in">grayscale</span>(<span class="number">1</span>);</span><br><span class="line">    -webkit-<span class="attribute">filter</span>: <span class="built_in">grayscale</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="filter滤镜属性"><a href="#filter滤镜属性" class="headerlink" title="filter滤镜属性"></a>filter滤镜属性</h2><table><thead><tr><th>filter</th><th>描述</th></tr></thead><tbody><tr><td>none</td><td>默认值，没有效果</td></tr><tr><td>blur(<em>px</em>)</td><td>高斯模糊</td></tr><tr><td>brightness(<em>%</em>)</td><td>曝光</td></tr><tr><td>contrast(<em>%</em>)</td><td>对比度</td></tr><tr><td>drop-shadow(<em>h-shadow v-shadow blur spread color</em>)</td><td>阴影</td></tr><tr><td><code>grayscale(%)</code></td><td>灰度</td></tr><tr><td>hue-rotate(<em>deg</em>)</td><td>色相旋转</td></tr><tr><td>invert(<em>%</em>)</td><td>反转图像</td></tr><tr><td>opacity(<em>%</em>)</td><td>透明度</td></tr><tr><td>saturate(<em>%</em>)</td><td>图像饱和度</td></tr><tr><td>sepia(<em>%</em>)</td><td>深褐色</td></tr><tr><td>url()</td><td>自定义SVG滤镜</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> CSS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> css滤镜 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript</title>
      <link href="/posts/cc1b9611.html"/>
      <url>/posts/cc1b9611.html</url>
      
        <content type="html"><![CDATA[<h2 id="JS中字符串方法有哪些？"><a href="#JS中字符串方法有哪些？" class="headerlink" title="JS中字符串方法有哪些？"></a>JS中字符串方法有哪些？</h2><p><code>split</code>：字符串按指定字符分割为字符串数组。不改变原始字符串<br><code>lastIndexOf</code>：</p><table><thead><tr><th>方法</th><th>描述</th><th>返回值</th><th>是否改变原始字符串</th></tr></thead><tbody><tr><td><code>split</code></td><td>字符串按指定字符分割为字符串数组</td><td>Array</td><td>否</td></tr><tr><td><code>lastIndexOf</code></td><td>返回某个指定的字符串值最后出现的位置</td><td>Number</td><td>否</td></tr><tr><td><code>indexOf</code></td><td>返回某个指定的字符串值在字符串中首次出现的位置</td><td>Number</td><td>否</td></tr><tr><td><code>concat()</code></td><td>连接两个或多个字符串</td><td>String，返回新字符串</td><td>否</td></tr><tr><td><code>substring()</code></td><td>提取字符串中介于两个指定下标之间的字符，左闭右开[start,end)<br>start,end非负整数，负数转0</td><td>String</td><td>否</td></tr><tr><td><code>slice()</code></td><td>方法可提取字符串的某个部分，并以新的字符串返回被提取的部分，[start,end)<br/>start负数，则从尾部开始截取 slice(-2) 表示提取原数组中的倒数第二个元素到最后一个元素（包含最后一个元素）</td><td></td><td>否</td></tr><tr><td><code>includes()</code></td><td>判断字符串是否包含指定的子字符串</td><td></td><td>否</td></tr><tr><td><code>replace() </code><br><code>replaceAll()</code></td><td>用于在字符串中用一些字符替换另一些字符，或替换一个与正则表达式匹配的子串<br>replaceAll该函数会替换所有匹配到的子字符串</td><td></td><td>否</td></tr><tr><td><code>trim()</code></td><td>用于删除字符串的头尾空白符，空白符包括：空格、制表符 tab、换行符等其他空白符等<br/>不适用于 null, undefined, Number 类型</td><td></td><td>否</td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td></tr></tbody></table><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">&quot;how are you&quot;</span>;</span><br><span class="line"><span class="keyword">var</span> word = str.<span class="title function_">split</span>(<span class="string">&quot; &quot;</span>); <span class="comment">// [&quot;how&quot;,&quot;are&quot;,&quot;you&quot;]</span></span><br></pre></td></tr></table></figure><h3 id="slice-和substring-区别"><a href="#slice-和substring-区别" class="headerlink" title="slice()和substring()区别"></a>slice()和substring()区别</h3><p>负数截取，slice支持负数截取，而substring不支持</p><h2 id="JS-数组方法"><a href="#JS-数组方法" class="headerlink" title="JS 数组方法"></a>JS 数组方法</h2><table><thead><tr><th>方法</th><th>描述</th><th>返回值</th><th>是否改变原数组</th></tr></thead><tbody><tr><td><code>join()</code></td><td>用指定的分隔符将数组每一项拼接为字符串，默认逗号</td><td>String</td><td>否</td></tr><tr><td><code>push()</code></td><td>数组末尾添加1&#x2F;n<br>向数组的末尾添加新元素，可以添加一个或多个元素</td><td>Number，返回数组新长度</td><td>改变数组长度</td></tr><tr><td><code>pop()</code></td><td>数组末尾删除1<br>删除数组最后一个元素</td><td>所有类型，返回在最后一个元素</td><td>改变数组长度</td></tr><tr><td><code>shift()</code></td><td>数组开头删除1<br>删除数组第一个元素</td><td>所有类型，返回第一个元素</td><td>改变数组长度</td></tr><tr><td><code>unshift()</code></td><td>向数组的开头添加一个或更多元素</td><td>Number，返回数组新长度</td><td>改变数组长度</td></tr><tr><td><code>sort()</code></td><td>数组元素排序，默认字母升序<br>数字排序，通过一个函数作为参数来调用<br>数字升序，Array.sort(<strong>function</strong>(a,b){<strong>return</strong> b-a})</td><td>Array</td><td>改变原始数组</td></tr><tr><td><code>reverse()</code></td><td>颠倒数组中元素的顺序</td><td>Array</td><td>改变原始数组</td></tr><tr><td><code>concat()</code></td><td>连接两个或多个数组</td><td>Array，返回新数组</td><td>否</td></tr><tr><td><code>slice()</code></td><td>返回从原数组中指定开始下标到结束下标之间的项组成的新数组<br><br>两个参数，要返回项的起始和结束位置(新数组不包括结束位置的元素)；一个参数默认结束位置为数组末尾<br>当出现负数时，将负数加上数组长度的值来替换该位置的数</td><td>Array，返回新数组</td><td>否</td></tr><tr><td><code>splice()</code></td><td>可实现删除、插入和替换<br> &#x3D;&gt; 删除元素 &#x2F; 指定索引添加元素 &#x2F; 替换指定索引位置元素<br><em>array</em>.splice(<em>index</em>,<em>howmany</em>,<em>item1</em>,…..,<em>itemX</em>)<br><br>index - 必需，数组元素下标<br>howmany - 可选，数字，删除多少元素，未规定则删除从 index 开始到原数组结尾的所有元素<br>item1,……,itemX - 选，要添加到数组的新元素</td><td>Array，返回删除元素的数组</td><td>改变原始数组</td></tr><tr><td><code>indexOf()</code></td><td>从数组的开头（位置 0）开始向后查找<br>两个参数：要查找的项和（可选的）表示查找起点位置的索引</td><td>Number</td><td>否</td></tr><tr><td><code>lastIndexOf()</code></td><td>从数组的末尾开始向前查找<br/>两个参数：要查找的项和（可选的）表示查找起点位置的索引</td><td>Number</td><td>否</td></tr><tr><td><code>fill()</code></td><td>es6新增(es6+) 使用特定值填充数组中的一个或多个元素。<br>当只是用一个参数时，该方法会用该参数的值填充整个数组<br>3 个参数： 填充数值，起始位置参数，结束位置参数（不包括结束位置的那个元素）</td><td></td><td>否</td></tr><tr><td><code>filter()</code></td><td>返回满足过滤条件组成的数组</td><td>Array</td><td>否</td></tr><tr><td><code>every()</code></td><td>判断数组中每一项都是否满足条件，只有所有项都满足条件，才会返回 true，参数Function</td><td>Boolean</td><td>否</td></tr><tr><td><code>some()</code></td><td>判断数组中是否存在满足条件的项，只要有一项满足条件，就会返回 true，参数Function</td><td>Boolean</td><td>否</td></tr><tr><td><code>includes()</code></td><td>es7+ 判断一个数组是否包含一个指定的值<br>参数有两个，1（必填）需要查找的元素值，2（可选）开始查找元素的位置 <br>使用&#x3D;&#x3D;&#x3D;运算符来进行值比较</td><td>Boolean</td><td>否</td></tr><tr><td><code>sort()</code></td><td></td><td></td><td></td></tr><tr><td><code>forEach()</code></td><td>对数组进行遍历循环，对数组中的每一项运行给定函数<br>参数都是 function 类型，默认有传<br>参数：遍历的数组内容；对应的数组索引，数组本身</td><td>-</td><td>否</td></tr><tr><td><code>map()</code></td><td>返回一个新数组，数组中的元素为原始数组元素调用函数处理后的值</td><td></td><td>否</td></tr><tr><td><code>reduce()</code>、<code>reduceRight()</code></td><td>迭代数组的所有项(即累加器)，然后构建一个最终返回的值<br><br>reduce()方法从数组的第一项开始，逐个遍历到最后<br>reduceRight()则从数组的最后一项开始，向前遍历到第一项<br>4 个参数：前一个值、当前值、项的索引和数组对象</td><td></td><td></td></tr><tr><td><code>copyWithin()</code></td><td>es6+ 从数组的指定位置拷贝元素到数组的另一个指定位置中</td><td></td><td>改变原数组</td></tr><tr><td><code>find()</code></td><td>接受两个参数：一个回调函数，一个可选值用于指定回调函数内部的 this<br><br/>该回调函数可接受三个参数：数组的某个元素value，该元素对应的索引位置index，以及该数组本身。<br>均会在回调函数第一次返回 true 时停止查找</td><td>返回匹配的值</td><td>否</td></tr><tr><td><code>findIndex()</code></td><td>同上</td><td>返回匹配值得索引</td><td>否</td></tr><tr><td><code>toLocaleString()</code>、<code>toString()</code></td><td>将数组转换为字符串</td><td></td><td></td></tr><tr><td><code>flat()</code>、<code>flatMap()</code></td><td>es6+ 按照一个可指定的深度递归遍历数组，并将所有元素与遍历到的子数组中的元素合并为一个新数组返回</td><td></td><td>否</td></tr><tr><td><code>entries()</code>、<code>keys()</code>、<code>values()</code></td><td>es6+ 遍历数组。它们都返回一个遍历器对象，可以用for…of循环进行遍历<br>区别：keys()是对键名的遍历、values()是对键值的遍历，entries()是对键值对的遍历</td><td></td><td></td></tr></tbody></table><h3 id="JS实现数组去重"><a href="#JS实现数组去重" class="headerlink" title="JS实现数组去重"></a>JS实现数组去重</h3><p>已知数组arr，对该数组进行去重，去重后的数组用uniqueArray代替</p><ul><li><p><strong>1 利用ES6中的Set方法去重</strong></p></li><li><ul><li><pre><code class="javascript">let uniqueArray = Array.from(new Set(arr));let uniqueArray = [...new Set(arr)];<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- **2 some()方法去重**</span><br><span class="line"></span><br><span class="line">- - some()方法判断数组中是否存在满足条件的项，满足返回true。定义新数组承接未重复数据，遍历原始数组的时候，用新数组来判断数据是否已经出现过。</span><br><span class="line"></span><br><span class="line">- - ```javascript</span><br><span class="line">    function uniqueArr(arr) &#123;</span><br><span class="line">        // 新数组</span><br><span class="line">        let result = [arr[0]];</span><br><span class="line">        for(let i = 1; i &lt; arr.length; i++) &#123;</span><br><span class="line">            // 判断结果数组中是否存在一样的值，若果没有的话则将数据存入结果数组中</span><br><span class="line">            if(!result.some(val =&gt; &#123;arr[i] === val&#125;)) &#123;</span><br><span class="line">                result.push(arr[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></code></pre></li></ul></li><li><p><strong>3 双重for循环+splice去重</strong></p></li><li><ul><li>第一层循环确保数组中的每一项都能被比较，第二层循环确保被比较项后的每一项都能跟被比较项比较，重复则splice(index,1)删除重复元素</li></ul></li><li><p><strong>4 filter()+indexOf()方法去重</strong></p></li><li><ul><li><p>数组的当前元素在原始数组中的第一个索引&#x3D;&#x3D;当前索引值，则第一次出现，即唯一</p></li><li><pre><code class="javascript">function uniqueArr(arr) &#123;    return arr.filter((item, index, arr)=&gt;&#123;        return arr.indexOf(item, 0) === index;    &#125;)&#125;<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- **5 ES6中Map方法去重**</span><br><span class="line"></span><br><span class="line">- - 通过创建一个空Map数据结构，然后遍历需要去重的数组，最后把数组的每一个元素作为key存到Map中，由于Map中不会出现相同的key，所以最后得到的结果就是数组去重后的所有元素。</span><br><span class="line"></span><br><span class="line">- - ```javascript</span><br><span class="line">    function uniqueArr(arr) &#123;                </span><br><span class="line">        let map = new Map();               </span><br><span class="line">        let result = [];      </span><br><span class="line">        for (let i = 0, i &lt; arr.length; i++) &#123;    </span><br><span class="line">            if (map.has(arr[i])) &#123;       </span><br><span class="line">                // 判断是否存在key          </span><br><span class="line">                map.set(array[i], true);     </span><br><span class="line">            &#125; else &#123;       </span><br><span class="line">                map.set(array[i], false); </span><br><span class="line">                result.push(array[i]);  </span><br><span class="line">            &#125;                   </span><br><span class="line">        &#125;                 </span><br><span class="line">        return result;         </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></code></pre></li></ul></li></ul><h3 id="reduce-实现数组求平均值"><a href="#reduce-实现数组求平均值" class="headerlink" title="reduce()实现数组求平均值"></a>reduce()实现数组求平均值</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// arr为已知数组，要求数组每项元素为数字类型Number</span></span><br><span class="line">arr.<span class="title function_">reduce</span>(<span class="function">(<span class="params">acc, current</span>) =&gt;</span> acc + current) / arr.<span class="property">length</span></span><br></pre></td></tr></table></figure><p><code>二维数组</code>定义：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = <span class="keyword">new</span> <span class="title class_">Array</span>(<span class="number">10</span>); <span class="comment">//表格有10行</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>;i &lt; arr.<span class="property">length</span>; i++)&#123;</span><br><span class="line"> arr[i] = <span class="keyword">new</span> <span class="title class_">Array</span>(<span class="number">10</span>).<span class="title function_">fill</span>(<span class="number">0</span>); <span class="comment">//每行有10列</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="JS-进制转换"><a href="#JS-进制转换" class="headerlink" title="JS 进制转换"></a>JS 进制转换</h2><p>进制分：十进制、二进制、十六进制、八进制</p><p>在JavaScript内部的默认情况下，二进制、十六进制、八进制字面量数值，都会自动转为十进制进行运算。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">### 十进制转其他进制</span><br><span class="line"></span><br><span class="line"><span class="title function_">toString</span>()转换 =&gt; x.<span class="title function_">toString</span>(n) - x十进制数字，n转换的进制(<span class="number">2</span>,<span class="number">8</span>,<span class="number">16</span>,<span class="number">32</span>)</span><br><span class="line"></span><br><span class="line">### 其他进制转十进制</span><br><span class="line"></span><br><span class="line"><span class="built_in">parseInt</span>()转换 =&gt; <span class="built_in">parseInt</span>(m,n) - m转换的数，n转换的数是多少进制的，如<span class="built_in">parseInt</span>(x,<span class="number">2</span>)代表将二进制数x转换为十进制</span><br><span class="line"></span><br><span class="line">### 其他进制之间的转换 - 先转十进制，再转其他进制</span><br><span class="line"><span class="comment">// 表示将二进制的x转换为十六进制</span></span><br><span class="line"><span class="built_in">parseInt</span>(x,<span class="number">2</span>).<span class="title function_">toString</span>(<span class="number">16</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">// 表示将十六进制的x转换为二进制</span></span><br><span class="line"><span class="built_in">parseInt</span>(x, <span class="number">16</span>).<span class="title function_">toString</span>(<span class="number">2</span>)</span><br></pre></td></tr></table></figure><h2 id="JS-Map"><a href="#JS-Map" class="headerlink" title="JS Map"></a>JS Map</h2><p>Map 对象存有键值对，其中的键可以是任何数据类型。</p><p>Map 对象记得键的原始插入顺序。</p><p>Map 对象具有表示映射大小的属性。</p><p><code>注意</code>：Map默认存储中，当存在key值相同时，后存储的key值对应的value会默认覆盖先前已有的value值。</p><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td><code>new Map()</code></td><td>创建新的 Map 对象。</td></tr><tr><td><code>set()</code></td><td>为 Map 对象中的键设置值。</td></tr><tr><td><code>get()</code></td><td>获取 Map 对象中键的值。</td></tr><tr><td><code>entries()</code></td><td>返回 Map 对象中键&#x2F;值对的数组。</td></tr><tr><td><code>keys()</code></td><td>返回 Map 对象中键的数组。</td></tr><tr><td><code>values()</code></td><td>返回 Map 对象中值的数组。</td></tr><tr><td><code>clear()</code></td><td>删除 Map 中的所有元素。</td></tr><tr><td><code>delete()</code></td><td>删除由键指定的元素。</td></tr><tr><td><code>has()</code></td><td><code>Map.has(key)</code> 如果键存在，则返回 true。</td></tr><tr><td><code>forEach()</code></td><td>Map迭代 为每个键&#x2F;值对调用回调。</td></tr></tbody></table><h3 id="JavaScript中按值对Map进行排序"><a href="#JavaScript中按值对Map进行排序" class="headerlink" title="JavaScript中按值对Map进行排序"></a>JavaScript中按值对Map进行排序</h3><ul><li>使用展开语法 <code>(...)</code> 获取 Map 条目的数组</li><li>在数组上调用 <code>sort()</code> 方法</li><li>将结果传递给 <code>Map()</code> 构造函数</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 按值升序排序（从低到高）</span></span><br><span class="line"><span class="keyword">const</span> sortNumAsc = <span class="keyword">new</span> <span class="title class_">Map</span>([...map2].<span class="title function_">sort</span>(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a[<span class="number">1</span>] - b[<span class="number">1</span>])); <span class="comment">// 值为数字类型</span></span><br><span class="line"><span class="keyword">const</span> sortNumAsc = <span class="keyword">new</span> <span class="title class_">Map</span>([...map2].<span class="title function_">sort</span>(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a[<span class="number">1</span>] &gt; b[<span class="number">1</span>] ? <span class="number">1</span> : -<span class="number">1</span>)); <span class="comment">// 值为字符类型</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 同理，按键升序排序（从低到高）</span></span><br><span class="line"><span class="keyword">const</span> sortKeyAsc = <span class="keyword">new</span> <span class="title class_">Map</span>([...map2].<span class="title function_">sort</span>(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a[<span class="number">0</span>] - b[<span class="number">0</span>]));</span><br></pre></td></tr></table></figure><h2 id="JS-Set"><a href="#JS-Set" class="headerlink" title="JS Set"></a>JS Set</h2><p>Set 对象允许你存储任何类型的唯一值，无论是原始值或者是对象引用。</p><p><strong>Set中的特殊值</strong></p><p>Set 对象存储的值总是<code>唯一</code>的，所以需要判断两个值是否恒等。有几个特殊值需要特殊对待：</p><ul><li>+0 与 -0 在存储判断唯一性的时候是恒等的，所以不重复；</li><li>undefined 与 undefined 是恒等的，所以不重复；</li><li>NaN 与 NaN 是不恒等的，但是在 Set 中只能存一个，不重复</li></ul><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td><code>new Set()</code></td><td>创建新的 Set 对象。</td></tr><tr><td><code>add()</code></td><td>添加元素</td></tr><tr><td><code>delete()</code></td><td>删除元素</td></tr><tr><td><code>size</code></td><td>Set中元素个数</td></tr><tr><td><code>has()</code></td><td>判断 Set 中是否包含某个元素 如果存在，则返回 true。</td></tr><tr><td><code>clear()</code></td><td>清空Set实例</td></tr><tr><td><code>entries()</code></td><td>返回 Set对象中键&#x2F;值对的数组。</td></tr><tr><td><code>keys()</code></td><td>返回 Set对象中键的数组。</td></tr><tr><td><code>values()</code></td><td>返回 Set对象中值的数组。</td></tr><tr><td><code>Array.from()</code></td><td>Set转换成数组 Array.from(set)</td></tr></tbody></table><p>遍历：forEach、for of</p><h2 id="20220802-JS正则表达式"><a href="#20220802-JS正则表达式" class="headerlink" title="20220802.JS正则表达式"></a>20220802.JS正则表达式</h2><h2 id="JavaScript区分元素是字符还是数值类型的方法"><a href="#JavaScript区分元素是字符还是数值类型的方法" class="headerlink" title="JavaScript区分元素是字符还是数值类型的方法"></a>JavaScript区分元素是字符还是数值类型的方法</h2><ul><li><code>isNaN</code>：检查其参数是否是非数字值</li><li><ul><li>如果参数值为 NaN 或字符串、对象、undefined等非数字值则返回 true, 否则返回 false</li></ul></li><li><code>typeof</code>：使用 typeof 操作符来检测变量的数据类型</li><li><ul><li>string、number、boolean、object</li><li>在JavaScript中，数组是一种特殊的对象类型。 因此 typeof [1,2,3,4] 返回 object</li></ul></li></ul><h2 id="JS-数学Math相关"><a href="#JS-数学Math相关" class="headerlink" title="JS 数学Math相关"></a>JS 数学Math相关</h2><p><code>Math.cbrt()</code>：求一个数的立方根</p><p><code>Math.abs()</code>：求一个数的绝对值</p><p><code>Math.pow(m,n)</code>：求m的n次方</p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> JavaScript </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>『Web前端』笔、面试汇总录</title>
      <link href="/posts/3c488bd8.html"/>
      <url>/posts/3c488bd8.html</url>
      
        <content type="html"><![CDATA[<h2 id="面试问答录"><a href="#面试问答录" class="headerlink" title="面试问答录"></a>面试问答录</h2><h3 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h3><ul><li>讲一下float</li><li>透明度设置</li><li>如何画一个三角形</li><li>CSS盒模型</li><li>CSS布局</li><li>元素垂直居中的方法</li><li>CSS预处理器</li><li>grid、flex布局及属性，flex布局设置居中</li><li>CSS性能优化</li><li>响应式布局</li><li>CSS动画，自定义动画</li><li>CSS单位</li><li>CSS伪元素</li></ul><h3 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a>JavaScript</h3><ul><li>DOM是什么？关于DOM的api有哪些？</li><li>几个很实用的BOM属性对象方法</li><li>闭包</li><li>JS基本数据类型，null和undefined区别</li><li>JS原型链，原型链顶端是什么？Object原型？它原型的原型？</li><li>DOM增删改查(手写)，元素前面插入</li><li>讲一下同步、异步</li><li>了解的JS标准</li><li>sort函数</li></ul><h3 id="Vue"><a href="#Vue" class="headerlink" title="Vue"></a>Vue</h3><ul><li>简单讲一下vue</li><li>vue生命周期，vue生命周期中获取路由参数</li><li>vue指令</li><li></li></ul><h3 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h3><ul><li>linux知道的基本操作</li><li>服务器tomcat与nginx</li><li>如何搭建一个网站</li></ul><h3 id="Web"><a href="#Web" class="headerlink" title="Web"></a>Web</h3><ul><li>web性能优化</li><li></li></ul><h2 id="笔试知识点提炼"><a href="#笔试知识点提炼" class="headerlink" title="笔试知识点提炼"></a>笔试知识点提炼</h2><h3 id="JavaScript中-x3D-x3D-与-x3D-x3D-x3D-区别"><a href="#JavaScript中-x3D-x3D-与-x3D-x3D-x3D-区别" class="headerlink" title="JavaScript中&#x3D;&#x3D;与&#x3D;&#x3D;&#x3D;区别"></a>JavaScript中&#x3D;&#x3D;与&#x3D;&#x3D;&#x3D;区别</h3><ul><li>相等运算符<code>==</code></li><li>严格相等运算符<code>===</code></li></ul><table><thead><tr><th>&#x3D;&#x3D;比较</th><th>&#x3D;&#x3D;&#x3D;比较</th></tr></thead><tbody><tr><td>1)两个值<font color=red>类型相同</font>，再进行三个等号（<u>&#x3D;&#x3D;&#x3D;</u>）比较<br/>2)<font color=red>类型不同</font>，先<u>类型转换</u>，再&#x3D;&#x3D;&#x3D;比较<br/>  a.<strong>原始类型</strong>的值 &#x3D;&gt; 转数值类型比较<br/>  b.<strong>对象与原始类型值</strong>比较 &#x3D;&gt; 对象转原始类型值比较<br>  c.<strong><code>undefined</code> 和 <code>null</code></strong> &#x3D;&gt; 比较其他类型 false，互比 true<br>  d. <strong>不相等运算符 <code>!=</code></strong> &#x3D;&gt; 返回相反值</td><td>1）<strong>不同类型</strong>值 &#x3D;&gt; false<br/>2）<strong>同一原始类型</strong>值 &#x3D;&gt; 比较值<br>  如果其中至少一个是NaN，那么不相等。（判断一个值是否是NaN，只能使用isNaN()来判断）<br/>3）<strong>复合类型</strong>值 &#x3D;&gt; 比较指向同一地址<br/>4）**<code>undefined</code>和<code>null</code>** &#x3D;&gt; true<br>5) <strong>严格不相等运算符<code>!==</code></strong> &#x3D;&gt; 先求严格相等运算符的结果，然后返回相反值</td></tr></tbody></table><hr><p><strong>&#x3D;&#x3D;&#x3D; 严格相等运算符</strong></p><ul><li>不同类型值 &#x3D;&gt; false</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> === <span class="string">&quot;1&quot;</span> <span class="comment">// false</span></span><br><span class="line"><span class="literal">true</span> === <span class="string">&quot;true&quot;</span> <span class="comment">// false</span></span><br></pre></td></tr></table></figure><ul><li><p>同一原始类型值 &#x3D;&gt; 比较值</p></li><li><ul><li>同一类型的原始类型的值（数值、字符串、布尔值）比较时，值相同就返回true，值不同就返回false。</li></ul></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> === <span class="number">0x1</span> <span class="comment">// true 十进制与十六进制的1比较</span></span><br><span class="line"><span class="title class_">NaN</span> === <span class="title class_">NaN</span>  <span class="comment">// false</span></span><br><span class="line">+<span class="number">0</span> === -<span class="number">0</span> <span class="comment">// true</span></span><br></pre></td></tr></table></figure><blockquote><p>NaN与任何值都不相等（包括自身）；正0等于负0</p></blockquote><ul><li><p>复合类型值 &#x3D;&gt; 比较指向同一地址</p></li><li><ul><li>两个复合类型（对象、数组、函数）的数据比较时，不是比较它们的值是否相等，而是比较它们是否指向同一个地址</li></ul></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#125; === &#123;&#125; <span class="comment">// false 两个空对象</span></span><br><span class="line">[] === [] <span class="comment">// false 两个空数组</span></span><br><span class="line">(<span class="keyword">function</span> (<span class="params"></span>) &#123;&#125; === <span class="keyword">function</span> (<span class="params"></span>) &#123;&#125;) <span class="comment">// false 两个空函数</span></span><br><span class="line"><span class="comment">// 运算符两边的空对象、空数组、空函数的值，都存放在不同的内存地址，所以结果是false</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 如果两个变量引用同一个对象，则它们相等 */</span></span><br><span class="line"><span class="keyword">var</span> v1 = &#123;&#125;;</span><br><span class="line"><span class="keyword">var</span> v2 = v1;</span><br><span class="line">v1 === v2 <span class="comment">// true</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 两个对象的比较，严格相等运算符比较的是地址，而大于或小于运算符比较的是值 */</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Date</span>() &gt; <span class="keyword">new</span> <span class="title class_">Date</span>() <span class="comment">// false</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Date</span>() &lt; <span class="keyword">new</span> <span class="title class_">Date</span>() <span class="comment">// false</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Date</span>() === <span class="keyword">new</span> <span class="title class_">Date</span>() <span class="comment">// false</span></span><br></pre></td></tr></table></figure><ul><li><p><code>undefined</code>和<code>null</code> &#x3D;&gt; undefined和null与自身严格相等</p></li><li><p>严格不相等运算符<code>!==</code> &#x3D;&gt; 先求严格相等运算符的结果，然后返回相反值</p></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> !== <span class="string">&#x27;1&#x27;</span> <span class="comment">// true</span></span><br></pre></td></tr></table></figure><hr><p><strong>&#x3D;&#x3D;相等运算符</strong></p><ul><li><p>原始类型的值 &#x3D;&gt; 转<strong>数值类型</strong>比较</p></li><li><ul><li>原始类型的数据会转换成<strong>数值类型</strong>再进行比较</li></ul></li></ul> <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> == <span class="literal">true</span> <span class="comment">// true  等同于 1 === Number(true) =&gt; 1===1</span></span><br><span class="line"></span><br><span class="line"><span class="number">0</span> == <span class="literal">false</span> <span class="comment">// true 等同于 0 === Number(false)</span></span><br><span class="line"></span><br><span class="line"><span class="number">2</span> == <span class="literal">true</span> <span class="comment">// false 等同于 2 === Number(true)</span></span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;true&#x27;</span> == <span class="literal">true</span> <span class="comment">// false</span></span><br><span class="line"><span class="comment">// 等同于 Number(&#x27;true&#x27;) === Number(true) =&gt; 等同于 NaN === 1</span></span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;</span> == <span class="number">0</span> <span class="comment">// true</span></span><br><span class="line"><span class="comment">// 等同于 Number(&#x27;&#x27;) === 0 =&gt; 等同于 0 === 0</span></span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;</span> == <span class="literal">false</span>  <span class="comment">// true</span></span><br><span class="line"><span class="comment">// 等同于 Number(&#x27;&#x27;) === Number(false) =&gt; 等同于 0 === 0</span></span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;1&#x27;</span> == <span class="literal">true</span>  <span class="comment">// true</span></span><br><span class="line"><span class="comment">// 等同于 Number(&#x27;1&#x27;) === Number(true) =&gt; 等同于 1 === 1</span></span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;\n  123  \t&#x27;</span> == <span class="number">123</span> <span class="comment">// true 因为字符串转为数字时，省略前置和后置的空格</span></span><br></pre></td></tr></table></figure><ul><li>对象与原始类型值比较 &#x3D;&gt; 对象转原始类型值比较</li><li><ul><li>对象（这里指广义的对象，包括数组和函数）</li></ul></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>] == <span class="number">1</span> <span class="comment">// true  等同于 Number([1]) == 1</span></span><br><span class="line"></span><br><span class="line">[<span class="number">1</span>] == <span class="string">&#x27;1&#x27;</span> <span class="comment">// true 等同于 Number([1]) == Number(&#x27;1&#x27;)</span></span><br><span class="line"></span><br><span class="line">[<span class="number">1</span>] == <span class="literal">true</span> <span class="comment">// true 等同于 Number([1]) == Number(true)</span></span><br></pre></td></tr></table></figure><ul><li><strong>undefined 和 null</strong> &#x3D;&gt; 比较其他类型false，互比true</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="literal">false</span> == <span class="literal">null</span> <span class="comment">// false</span></span><br><span class="line"><span class="literal">false</span> == <span class="literal">undefined</span> <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="number">0</span> == <span class="literal">null</span> <span class="comment">// false</span></span><br><span class="line"><span class="number">0</span> == <span class="literal">undefined</span> <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="literal">undefined</span> == <span class="literal">null</span> <span class="comment">// true</span></span><br></pre></td></tr></table></figure><ul><li><ul><li>绝大多数情况下，对象与undefined和null比较，都返回false。只有在对象转为原始值得到undefined时，才会返回true.</li></ul></li><li>不相等运算符<code>!=</code> &#x3D;&gt; 返回相反值</li></ul><h3 id="聊聊JavaScript中的Object-defineProperty"><a href="#聊聊JavaScript中的Object-defineProperty" class="headerlink" title="聊聊JavaScript中的Object.defineProperty()"></a>聊聊JavaScript中的Object.defineProperty()</h3><p>在Vue2.x中，实现响应式的原理Object.defineProperty()这个ES5的API是核心。</p><p>**<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty">Object.defineProperty()</a>**：</p><p><strong><code>Object.defineProperty()</code></strong> 方法会直接在一个对象上定义一个新属性，或者修改一个对象的现有属性，并返回此对象。 &#x3D;&gt; **<code>Object.defineProperty()</code>**通过定义属性的元数据信息精准控制属性的行为。</p><p>传统定义JS对象的方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let obj = &#123;&#125;;</span><br><span class="line">let obj = new Object; </span><br><span class="line">let obj = Object.create();</span><br></pre></td></tr></table></figure><p>通常我们使用到的Object对象，在给对象设置属性时，一般通过对象的<code>.</code>操作符或者<code>[]</code>操作符直接赋值，或直接使用队形字面量方式赋值，比如 obj.a &#x3D; 10 。此类赋值后属性值可以后续更改，且对象可以被for..in 或 Object.keys 枚举遍历，即通过循环方式获取到该对象的属性值。</p><p>当只想定义了对象后，后续无法更改属性值或无法枚举时(精确的添加或修改对象的属性)，我们就用到了<strong>Object.defineProperty()</strong></p><p><strong>语法</strong>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(obj, prop, descriptor)</span><br></pre></td></tr></table></figure><p><strong>参数</strong>说明如下：</p><ul><li>obj：Object，要定义属性的对象</li><li>prop: String||Symbol，要定义或修改的属性的名称或 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Symbol"><code>Symbol</code></a></li><li><strong>descriptor</strong>: Object，要定义或修改的<u>属性描述符</u></li></ul><p><strong>返回值</strong>：Object，被传递给函数的对象</p><blockquote><p><strong>默认情况下，使用 Object.defineProperty() 添加的属性值是不可修改的</strong>。</p></blockquote><p>接下来我们来着重看一下<strong>descriptor</strong>属性描述对象：</p><p>对象里目前存在的属性描述符有两种主要形式：<em>数据描述符</em>和<em>存取描述符</em>。一个描述符只能是这两者其中之一；不能同时是两者。</p><ul><li><em>数据描述符</em>是一个具有值的属性，该值可以是可写的，也可以是不可写的。</li><li><em>存取描述符</em>是由 getter 函数和 setter 函数所描述的属性。</li></ul><p>两种描述符都是对象，该描述对象共有<code>configurable、enumerable、value、writable、get、set</code>等6个可选键值。</p><table><thead><tr><th></th><th>描述</th><th>默认值</th></tr></thead><tbody><tr><td><code>configurable</code></td><td><code>configurable</code> 键值为 <code>true</code> 时，该属性的描述符才能够被改变，同时该属性也能从对应的对象上被删除</td><td>false</td></tr><tr><td><code>enumerable</code></td><td><code>enumerable</code> 键值为 <code>true</code> 时，该属性才会出现在对象的枚举属性中</td><td>false</td></tr><tr><td><code>writable</code></td><td><code>writable</code> 键值为 <code>true</code> 时，属性的值，也就是上面的 <code>value</code>，才能被<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators#assignment_operators"><code>赋值运算符</code> (en-US)</a>改变</td><td>false</td></tr><tr><td><code>value</code></td><td>该属性对应的值。可以是任何有效的 JavaScript 值（数值，对象，函数等）</td><td>undefined</td></tr><tr><td><code>get</code></td><td>没有 getter，则为 <code>undefined</code>。当访问该属性时，会调用此函数。<br>执行时不传入任何参数，但是会传入 <code>this</code> 对象（由于继承关系，这里的<code>this</code>并不一定是定义该属性的对象）。该函数的返回值会被用作属性的值</td><td>undefined</td></tr><tr><td><code>set</code></td><td>没有 setter，则为 <code>undefined</code>。当属性值被修改时，会调用此函数。<br/>该方法接受一个参数（也就是被赋予的新值），会传入赋值时的 <code>this</code> 对象</td><td>undefined</td></tr></tbody></table><p><strong>描述符可拥有的键值</strong>：</p><table><thead><tr><th></th><th><code>configurable</code></th><th><code>enumerable</code></th><th><code>writable</code></th><th><code>value</code></th><th><code>get</code></th><th><code>set</code></th></tr></thead><tbody><tr><td>数据描述符</td><td>√</td><td>√</td><td>√</td><td>√</td><td>×</td><td>×</td></tr><tr><td>存取描述符</td><td>√</td><td>√</td><td>×</td><td>×</td><td>√</td><td>√</td></tr></tbody></table><div class="note green modern"><p>如果一个描述符不具有 <code>value</code>、<code>writable</code>、<code>get</code> 和 <code>set</code> 中的任意一个键，那么它将被认为是一个数据描述符。</p><p>如果一个描述符同时拥有 <code>value</code> 或 <code>writable</code> 和 <code>get</code> 或 <code>set</code> 键，则会产生一个异常。</p></div><p><strong><font color=red>Object.defineProperty()小练：</font></strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o = &#123;&#125;;</span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(o, <span class="string">&quot;a&quot;</span>,&#123;</span><br><span class="line">    <span class="attr">value</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="attr">writable</span>: <span class="literal">false</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(o.<span class="property">a</span>);  </span><br><span class="line">o.<span class="property">a</span> = <span class="number">2</span>;  </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(o.<span class="property">a</span>);  </span><br><span class="line"><span class="comment">// 两次输出结果？</span></span><br></pre></td></tr></table></figure><div class="hide-block"><button type="button" class="hide-button" style="background-color:  #2da44e;">查看结果    </button><div class="hide-content"><p>第一次输出结果：1<br>第二次输出结果：1，当o.a&#x3D;2时抛出异常，writable为false，value值不可被更改</p><p>&#x3D;&gt; 不用const，此方法可以使定义的变量不可变</p></div></div><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 来源：2020奇安信前端秋招 */</span></span><br><span class="line"><span class="keyword">var</span> o = &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;;</span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(o, <span class="string">&quot;b&quot;</span>, &#123;<span class="attr">value</span>: <span class="number">2</span>, <span class="attr">writable</span>: <span class="literal">false</span>, <span class="attr">enumerable</span>: <span class="literal">false</span>, <span class="attr">configurable</span>: <span class="literal">true</span>&#125;);</span><br><span class="line">o.<span class="property">a</span> = <span class="number">2</span>;</span><br><span class="line">o.<span class="property">b</span> = <span class="number">3</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(o.<span class="property">a</span>, o.<span class="property">b</span>)</span><br><span class="line"><span class="comment">// 代码输出的结果？</span></span><br></pre></td></tr></table></figure><div class="hide-block"><button type="button" class="hide-button" style="background-color:  #2da44e;">查看结果    </button><div class="hide-content"><p>输出结果：2 2</p></div></div><h3 id="JavaScript-Array-map-方法"><a href="#JavaScript-Array-map-方法" class="headerlink" title="JavaScript Array map()方法"></a>JavaScript Array map()方法</h3><p><code>map()</code> 方法返回一个新数组，数组中的元素为原始数组元素调用函数处理后的值。</p><p><font color=red>map() 不会对空数组进行检测；不会改变原始数组</font></p><p><strong>语法</strong>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">array.<span class="title function_">map</span>(<span class="keyword">function</span>(<span class="params">currentValue,index,arr</span>), thisValue)</span><br></pre></td></tr></table></figure><p><strong>参数</strong>说明：</p><table><thead><tr><th>参数</th><th>Required</th><th>描述</th></tr></thead><tbody><tr><td><em>function(currentValue, index,arr)</em></td><td>必须√</td><td>函数，数组中的每个元素都会执行这个函数<br>函数参数如下：<br>currentValue(必须√)：当前元素的值<br>index：当前元素的索引值<br>arr：当前元素属于的数组对象</td></tr><tr><td><em>thisValue</em></td><td>可选</td><td>对象作为该执行回调时使用，传递给函数，用作 “this” 的值。<br/>如果省略了 thisValue，或者传入 null、undefined，那么回调函数的 this 为全局对象。</td></tr></tbody></table><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 来源：2020奇安信前端秋招 */</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>([<span class="number">1</span>,<span class="literal">undefined</span>,<span class="number">3</span>,<span class="number">5</span>].<span class="title function_">map</span>(<span class="function">(<span class="params">_,n</span>)=&gt;</span>n))</span><br><span class="line"><span class="comment">// 上述代码在控制台的运行结果是什么？</span></span><br></pre></td></tr></table></figure><div class="hide-block"><button type="button" class="hide-button" style="background-color:  #2da44e;">查看结果    </button><div class="hide-content"><p>输出结果：[0,1,2,3]</p></div></div><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 来源：2020小鱼易连前端秋招 */</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>].<span class="title function_">map</span>(<span class="built_in">parseInt</span>));</span><br><span class="line"><span class="comment">// 上述代码在控制台的输出结果是什么？</span></span><br></pre></td></tr></table></figure><div class="hide-block"><button type="button" class="hide-button" style="background-color:  #2da44e;">查看结果    </button><div class="hide-content"><p>输出结果：[1,NaN,NaN]</p><p><code>parseInt</code>语法如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">parseInt</span>(string, radix)</span><br><span class="line"><span class="comment">// string 必需。要被解析的字符串。</span></span><br><span class="line"><span class="comment">// radix 可选。表示要解析的数字的基数。该值介于 2 ~ 36 之间。</span></span><br><span class="line"><span class="comment">/** 如果省略该参数或其值为 0，则数字将以 10 为基础来解析。如果它以 “0x” 或 “0X” 开 头，将以 16 为基数。</span></span><br><span class="line"><span class="comment">如果该参数小于 2 或者大于 36，则 parseInt() 将返回 NaN。</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">&#x27;1&#x27;</span>, <span class="number">0</span>) -&gt; <span class="number">1</span>   radix 为 <span class="number">0</span>，且string参数不以“0x”和“<span class="number">0</span>”开头时，<span class="built_in">parseInt</span>() 会根据十进制来解析，所以结果为 <span class="number">1</span>；</span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">&#x27;2&#x27;</span>, <span class="number">1</span>) -&gt; <span class="title class_">NaN</span> radix 为 <span class="number">1</span>，在基数为<span class="number">1</span>（<span class="number">1</span>进制）表示的数中，最大值小于<span class="number">2</span>，超出区间范围，无法解析，所以结果为 <span class="title class_">NaN</span>；</span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">&#x27;3&#x27;</span>, <span class="number">2</span>) -&gt; <span class="title class_">NaN</span> 同理，radix 为 <span class="number">2</span>，基数为<span class="number">2</span>（<span class="number">2</span>进制）表示的数中，最大值小于<span class="number">3</span>，所以结果为 <span class="title class_">NaN</span>。</span><br><span class="line"></span><br><span class="line">=&gt; 因为<span class="built_in">parseInt</span>接收两个参数，所以结果为 [<span class="number">1</span>, <span class="title class_">NaN</span>, <span class="title class_">NaN</span>]</span><br><span class="line"></span><br></pre></td></tr></table></figure></div></div><h3 id="ES6-Symbol类型"><a href="#ES6-Symbol类型" class="headerlink" title="ES6 Symbol类型"></a><a href="https://es6.ruanyifeng.com/#docs/symbol">ES6 Symbol类型</a></h3><p><code>Symbol</code>：ES6引入的一种新的原始数据类型，表示独一无二的值。它属于 JavaScript 语言的原生数据类型之一。</p><p>Symbol 值通过<code>Symbol()</code>函数生成。这就是说，对象的属性名现在可以有两种类型，一种是原来就有的字符串，另一种就是新增的 Symbol 类型。凡是属性名属于 Symbol 类型，就都是独一无二的，可以保证不会与其他属性名产生冲突。</p><blockquote><p><code>Symbol()</code>函数前不能使用<code>new</code>命令，否则会报错</p></blockquote><p>因为生成的 Symbol 是一个原始类型的值，不是对象，所以不能使用<code>new</code>命令来调用。另外，由于 Symbol 值不是对象，所以也不能添加属性。基本上，它是一种类似于字符串的数据类型。</p><ul><li><code>Symbol()</code>函数可以接受一个字符串作为参数，表示对 Symbol 实例的描述</li><li><code>Symbol()</code>函数的参数只是表示对当前 Symbol 值的描述，因此相同参数的<code>Symbol</code>函数的返回值是不相等的</li><li>Symbol 值不能与其他类型的值进行运算，会报错</li><li>Symbol 值可以显式转为字符串，也可以转为布尔值，但是不能转为数值</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> sym = <span class="title class_">Symbol</span>(<span class="string">&#x27;My symbol&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="title class_">String</span>(sym) <span class="comment">// &#x27;Symbol(My symbol)&#x27;</span></span><br><span class="line">sym.<span class="title function_">toString</span>() <span class="comment">// &#x27;Symbol(My symbol)&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// -------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> sym = <span class="title class_">Symbol</span>();</span><br><span class="line"><span class="title class_">Boolean</span>(sym) <span class="comment">// true</span></span><br><span class="line">!sym  <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (sym) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Number</span>(sym) <span class="comment">// TypeError</span></span><br><span class="line">sym + <span class="number">2</span> <span class="comment">// TypeError</span></span><br></pre></td></tr></table></figure><p><strong>Symbol小练</strong>：</p><p>以下关于ES6中Symbol的描述正确的是（）</p><p>A.Symbol是一种JS原始数据类型</p><p>B.Symbol(“a”)&#x3D;&#x3D;&#x3D;Symbol(“a”)的结果为true</p><p>C.Symbol.for(“a”)&#x3D;&#x3D;&#x3D;Symbol.for(“a”)的结果为true</p><p>D.Symbol().instanceof Object结果为true</p><div class="hide-block"><button type="button" class="hide-button" style="background-color:  #2da44e;">查看答案    </button><div class="hide-content"><p>A C</p><p>D: Symbol为原始数据类型，即类型是Symbol D为false </p><p><strong><code>instanceof</code></strong> <strong>运算符</strong>用于检测构造函数的 <code>prototype</code> 属性是否出现在某个实例对象的原型链上</p></div></div><hr><div class='checkbox green checked'><input type="checkbox" checked="checked"/>            <p><strong><code>Symbol.prototype.description</code></strong></p>            </div><p>Symbol 值的实例属性<code>description</code>，直接返回 Symbol 值的描述。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> sym = <span class="title class_">Symbol</span>(<span class="string">&#x27;foo&#x27;</span>);</span><br><span class="line"></span><br><span class="line">sym.<span class="property">description</span> <span class="comment">// &quot;foo&quot;</span></span><br></pre></td></tr></table></figure><div class='checkbox green checked'><input type="checkbox" checked="checked"/>            <p>作为属性名的Symbol</p>            </div><p>由于每一个 Symbol 值都是不相等的，这意味着只要 Symbol 值作为标识符，用于对象的属性名，就能保证不会出现同名的属性。</p><ul><li><code>Symbol 值作为对象属性名时，不能用点运算符</code></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> mySymbol = <span class="title class_">Symbol</span>();</span><br><span class="line"><span class="keyword">const</span> a = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">a.<span class="property">mySymbol</span> = <span class="string">&#x27;Hello!&#x27;</span>;</span><br><span class="line">a[mySymbol] <span class="comment">// undefined</span></span><br><span class="line">a[<span class="string">&#x27;mySymbol&#x27;</span>] <span class="comment">// &quot;Hello!&quot;</span></span><br><span class="line"><span class="comment">// 点运算符后面总是字符串，所以不会读取mySymbol作为标识名所指代的那个值，导致a的属性名实际上是一个字符串，而不是一个 Symbol 值</span></span><br></pre></td></tr></table></figure><ul><li>在对象的内部，使用 Symbol 值定义属性时，Symbol 值必须放在方括号之中</li><li>Symbol 类型还可以用于定义一组常量，保证这组常量的值都是不相等的</li></ul><p>Symbol 值作为属性名时，该属性还是公开属性，不是私有属性。</p><div class='checkbox green checked'><input type="checkbox" checked="checked"/>            <p>属性名的遍历</p>            </div><p>Symbol 值作为属性名，遍历对象的时候，该属性不会出现在<code>for...in</code>、<code>for...of</code>循环中，也不会被<code>Object.keys()</code>、<code>Object.getOwnPropertyNames()</code>、<code>JSON.stringify()</code>返回。</p><p><code>Object.getOwnPropertySymbols()</code>方法，可以获取指定对象的所有 Symbol 属性名。</p><ul><li>该方法返回一个数组，成员是当前对象的所有用作属性名的 Symbol 值</li></ul><p>另一个新的 API，<code>Reflect.ownKeys()</code>方法可以返回所有类型的键名，包括常规键名和 Symbol 键名。</p><div class='checkbox green checked'><input type="checkbox" checked="checked"/>            <p>Symbol.for()，Symbol.keyFor()</p>            </div><p><code>Symbol.for()</code>接受一个字符串作为参数，然后搜索有没有以该参数作为名称的 Symbol 值。</p><ul><li>如果有，就返回这个 Symbol 值</li><li>否则就新建一个以该字符串为名称的 Symbol 值，并将其注册到全局。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s1 = <span class="title class_">Symbol</span>.<span class="title function_">for</span>(<span class="string">&#x27;foo&#x27;</span>);</span><br><span class="line"><span class="keyword">let</span> s2 = <span class="title class_">Symbol</span>.<span class="title function_">for</span>(<span class="string">&#x27;foo&#x27;</span>);</span><br><span class="line"></span><br><span class="line">s1 === s2 <span class="comment">// true</span></span><br><span class="line"><span class="comment">// s1和s2都是 Symbol 值，但是它们都是由同样参数的Symbol.for方法生成的，所以实际上是同一个值。</span></span><br></pre></td></tr></table></figure><p><code>Symbol.for()</code>与<code>Symbol()</code>这两种写法，都会生成新的 Symbol。</p><table><thead><tr><th><code>Symbol.for()</code></th><th><code>Symbol()</code></th></tr></thead><tbody><tr><td>会被登记在全局环境中供搜索</td><td>不会被登记</td></tr><tr><td>不会每次调用就返回一个新的 Symbol 类型的值，而是会先检查给定的<code>key</code>是否已经存在，如果不存在才会新建一个值</td><td></td></tr></tbody></table><p><code>Symbol.keyFor()</code>方法返回一个已登记的 Symbol 类型值的<code>key</code>。</p><blockquote><p><code>Symbol.for()</code>为 Symbol 值登记的名字，是全局环境的，不管有没有在全局环境运行</p></blockquote><h3 id="Object-assign"><a href="#Object-assign" class="headerlink" title="Object.assign"></a><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/assign">Object.assign</a></h3><p>Object.assign() 方法用于将所有可枚举属性的值从一个或多个源对象复制到目标对象。它将返回目标对象。</p><p>简单来说，就是Object.assign()是对象的静态方法，可以用来复制对象的可枚举属性到目标对象，利用这个特性可以实现对象属性的合并。</p><p><strong>语法</strong>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Object</span>.<span class="title function_">assign</span>(target, ...sources)</span><br><span class="line"><span class="comment">// 参数： target---&gt;目标对象 source---&gt;源对象</span></span><br><span class="line"><span class="comment">// 返回值：target，即目标对象</span></span><br></pre></td></tr></table></figure><blockquote><p>如果目标对象与源对象具有相同的 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/keys">key</a>，则目标对象中的属性将被源对象中的属性覆盖，后面的源对象的属性将类似地覆盖前面的源对象的属性。</p></blockquote><ul><li>原型链上的属性和不可枚举属性不能被复制</li></ul><h3 id="CSS3选择器-TODO"><a href="#CSS3选择器-TODO" class="headerlink" title="CSS3选择器 TODO"></a>CSS3选择器 TODO</h3><p>下列选项中不属于CSS3样式选择器的是（）</p><p>A.empty选择器</p><p>B.root选择器</p><p>C.target选择器</p><p>D.ID选择器</p><div class="hide-block"><button type="button" class="hide-button" style="background-color:  #2da44e;">查看答案    </button><div class="hide-content"><p>D</p></div></div><p>TODO </p><h3 id="JS操作符-TODO"><a href="#JS操作符-TODO" class="headerlink" title="JS操作符 TODO"></a>JS操作符 TODO</h3><ul><li>delete操作符不会影响数组长度</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> z=<span class="number">1</span>;y=z=<span class="keyword">typeof</span> y;<span class="variable language_">console</span>.<span class="title function_">log</span>(y)  <span class="comment">// undefined</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// js中赋值操作结合律是右至左的 ，即从最右边开始计算值赋值给左边的变量。等价于下面的代码</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> z = <span class="number">1</span></span><br><span class="line">z = <span class="keyword">typeof</span> y;</span><br><span class="line"><span class="keyword">var</span> y = z;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(y);</span><br></pre></td></tr></table></figure><p><a href="https://blog.csdn.net/qq_46299172/article/details/107582250">经典面试题</a></p><h3 id="RegExp对象-TODO"><a href="#RegExp对象-TODO" class="headerlink" title="RegExp对象 TODO"></a>RegExp对象 TODO</h3><p>RegExp对象的方法有哪些？</p><p>test match exec toString</p><h3 id="xxx"><a href="#xxx" class="headerlink" title="xxx"></a>xxx</h3>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> 面试汇总 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用Hexo+Butterfly+Github+Vercel搭建个人博客</title>
      <link href="/posts/2fe3da.html"/>
      <url>/posts/2fe3da.html</url>
      
        <content type="html"><![CDATA[<h1 id="从0到1搭建Hexo博客"><a href="#从0到1搭建Hexo博客" class="headerlink" title="从0到1搭建Hexo博客"></a>从0到1搭建Hexo博客</h1><h2 id="1-前期准备"><a href="#1-前期准备" class="headerlink" title="1.前期准备"></a>1.前期准备</h2><blockquote><p>注意：此网站博客采用Hexo+Butterfly+Github+Vercel搭建</p><p>Hexo框架+Butterfly主题，Vercel部署</p><p><a href="https://hexo.io/zh-cn/docs/">Hexo框架官方参考文档</a></p><p><a href="https://butterfly.js.org/">Butterfly主题</a></p></blockquote><table><thead><tr><th>准备</th><th>说明</th></tr></thead><tbody><tr><td>操作系统：Win10</td><td></td></tr><tr><td>Node环境安装</td><td><a href="https://nodejs.org/en">Node.js官网</a>，具体环境搭建可参考<a href="https://blog.csdn.net/qq_40618816/article/details/112566147?spm=1001.2014.3001.5501">CSDN博客-Node.js环境搭建部分</a></td></tr><tr><td>Hexo安装</td><td>控制台命令安装<code>npm install -g hexo-cli</code>，验证<code>hexo -v</code></td></tr><tr><td>Github账号、仓库创建</td><td>可自行前往<a href="https://github.com/">Github官网</a>进行邮箱注册Sign up<br><a href="###Github%E4%BB%93%E5%BA%93%E5%88%9B%E5%BB%BA">仓库创建</a></td></tr><tr><td>Git安装</td><td><a href="https://git-scm.com/">Git官网</a>，具体可参考<a href="https://blog.csdn.net/qq_40618816/article/details/113845354?spm=1001.2014.3001.5502">CSDN博客-Git下载安装部分</a></td></tr><tr><td>编辑器Webstorm &#x2F; VSCode</td><td></td></tr><tr><td>域名</td><td>自行购买</td></tr></tbody></table><h3 id="Github仓库创建"><a href="#Github仓库创建" class="headerlink" title="Github仓库创建"></a>Github仓库创建</h3><ul><li>Github账户登录后，点击右上角<code>New repository</code>进行仓库创建</li><li>仓库名Repository name命名格式：<code>&lt;用户名&gt;.github.io</code>！！！</li><li>仓库可见性：<code>Public</code></li></ul><h3 id="Git配置用户名邮箱"><a href="#Git配置用户名邮箱" class="headerlink" title="Git配置用户名邮箱"></a>Git配置用户名邮箱</h3><p><a href="https://git-scm.com/">Git</a>下载安装后，鼠标右键进入 <code>Git bash</code>并配置用户名和邮箱</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name &quot;自己的用户名&quot; # 配置用户名</span><br><span class="line">git config --global user.email &quot;自己的邮箱&quot; # 配置邮箱</span><br><span class="line"></span><br><span class="line"># 查看配置 验证用户名和邮箱是否正确，参考下图</span><br><span class="line">git config -l</span><br></pre></td></tr></table></figure><p><img src="/images/article/hexo/git_username_password.png"></p><h3 id="Git连接至Github仓库"><a href="#Git连接至Github仓库" class="headerlink" title="Git连接至Github仓库"></a>Git连接至Github仓库</h3><p><strong>a.生成公钥</strong></p><p><code>Git bash</code>操作生成ssh公钥，在C盘用户文件夹下找到<code>.ssh文件夹</code> → 公钥<code>id_ras.pub</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 生成ssh公钥</span></span><br><span class="line">ssh-keygen -t rsa -C <span class="string">&quot;用户邮箱&quot;</span></span><br></pre></td></tr></table></figure><p><strong>b.SSH KEY配置到Github</strong></p><p>在Github中配置ssh密钥，进入Github，点击右上角头像进入<code>Settings</code>，左侧栏选择 <code>SSH and GPG keys</code>进行密钥配置</p><ul><li><code>Title</code>：自己对该密钥命名一个名字</li><li><code>Key type</code>：Authentication Key</li><li><code>Key</code>：填入上述公钥<code>id_ras.pub</code></li></ul><p><strong>c.测试连接</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># git bash测试连接 =&gt; 判断是否出现账户信息</span></span><br><span class="line">ssh -T git@github.com</span><br></pre></td></tr></table></figure><h2 id="2-初始化Hexo博客项目"><a href="#2-初始化Hexo博客项目" class="headerlink" title="2.初始化Hexo博客项目"></a>2.初始化Hexo博客项目</h2><h3 id="2-1-项目初始化"><a href="#2-1-项目初始化" class="headerlink" title="2.1 项目初始化"></a>2.1 项目初始化</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 初始化项目 注意：以下出现的项目名需要自定义</span></span><br><span class="line">hexo init 项目名</span><br><span class="line"></span><br><span class="line"><span class="comment"># 项目安装依赖</span></span><br><span class="line"><span class="built_in">cd</span> 项目名</span><br><span class="line">npm i</span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动项目(以下两条命令均可) =&gt; 本地预览：http://localhost:4000/</span></span><br><span class="line">hexo server</span><br><span class="line">hexo s</span><br></pre></td></tr></table></figure><p>初始化Hexo项目且安装依赖后，项目结构如下：</p><p><img src="/images/article/hexo/hexo%E9%A1%B9%E7%9B%AE%E7%BB%93%E6%9E%84.png"></p><p>打开浏览器进行本地预览<a href="http://localhost:4000/">http://localhost:4000/</a> ，如下图，表示博客构建成功。</p><p><img src="/images/article/hexo/hexo%E5%88%9D%E5%A7%8B%E5%8C%96%E6%A0%B7%E4%BE%8B.png"></p><h3 id="2-2-项目一键部署"><a href="#2-2-项目一键部署" class="headerlink" title="2.2 项目一键部署"></a>2.2 项目一键部署</h3><p>项目的一键部署参考<a href="https://hexo.io/zh-cn/docs/github-pages">Hexo_Github Pages一键部署文档</a>，即将静态博客挂载到Github Pages。</p><p><strong>2.2.1 安装 hexo-deployer-git</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure><p><strong>2.2.2 修改配置文件__config.yml</strong></p><p><code>_config.yml</code>是整个Hexo框架的配置文件，可根据<a href="https://hexo.io/zh-cn/docs/configuration">官方配置描述</a>自行配置。</p><p>修改<code>_config.yml</code>最后一行的配置，将repository修改为你自己的github项目地址即可，还有分支要改为<code>main</code>代表主分支（注意缩进）。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">deploy:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">git</span></span><br><span class="line">  <span class="comment"># 仓库地址 注意&lt;&gt;内需填写自己的Github相关用户名</span></span><br><span class="line">  <span class="attr">repo:</span> <span class="string">git@github.com:&lt;Github的用户名&gt;/&lt;用户名.github.io&gt;.git</span> </span><br><span class="line">  <span class="attr">branch:</span> <span class="string">master</span> <span class="comment"># 分支改为master代表主分支</span></span><br></pre></td></tr></table></figure><p><strong>2.2.3 代码部署</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 命令部署，将代码部署到Github</span></span><br><span class="line">hexo clean &amp;&amp; hexo generate &amp;&amp; hexo deploy  <span class="comment"># Git BASH终端</span></span><br><span class="line">hexo clean; hexo generate; hexo deploy  <span class="comment"># WebStorm终端</span></span><br></pre></td></tr></table></figure><ul><li><code>hexo clean</code>&#x2F; <code>hexo cl</code>：删除之前生成的文件，若未生成过静态文件，可忽略此命令</li><li><code>hexo generate</code> &#x2F; <code>hexo g</code>：生成静态文件</li><li><code>hexo deploy</code> &#x2F; <code>hexo d</code>：部署文章</li></ul><p><strong>2.2.4 浏览器访问</strong></p><p>稍等两分钟，浏览 <code>&lt;GitHub 用户名&gt;.github.io</code> 检查你的网站能否运作。</p><h2 id="3-Vercel部署"><a href="#3-Vercel部署" class="headerlink" title="3.Vercel部署"></a>3.Vercel部署</h2><p><code>Vercel</code> 是一个网站托管服务平台，开发者可以将自己的网络应用部署、托管在平台上运行。它能够托管你的静态html界面，甚至能够托管你的node.js与Python服务端脚本。</p><h3 id="3-1-Vercel账户与Github账户关联"><a href="#3-1-Vercel账户与Github账户关联" class="headerlink" title="3.1 Vercel账户与Github账户关联"></a>3.1 Vercel账户与Github账户关联</h3><p>Vercel账号与Github账户关联(没有Vercel账号的可以在<a href="https://vercel.com/dashboard">Vercel官网</a>创建一个)</p><h3 id="3-2-项目关联"><a href="#3-2-项目关联" class="headerlink" title="3.2 项目关联"></a>3.2 项目关联</h3><ul><li><p>点击右上角的<code>Add New Project</code>创建新的项目</p></li><li><p>找到自己Github账号静态博客的仓库<code>&lt;username&gt;.github.io</code>进行<code>Import</code>操作</p></li><li><p>自定义项目名称(数字+字母+连字符)，然后其他默认，点击<code>Deploy</code>部署</p></li></ul><p><img src="/images/article/hexo/vercel-1.png"><br><img src="/images/article/hexo/vercel-2.png"></p><h3 id="3-3-绑定自定义域名"><a href="#3-3-绑定自定义域名" class="headerlink" title="3.3 绑定自定义域名"></a>3.3 绑定自定义域名</h3><p><code>View Domains</code>查看当前域，输入框中输入自己购买的域名后<code>Add</code>添加。</p><p><img src="/images/article/hexo/vercel%E5%9F%9F%E5%90%8D-1.png"></p><p>在阿里云域名解析记录里面添加记录，记录类型对应<code>Type</code>，主机记录对应<code>Name</code>，记录值对应<code>Value</code>，其他默认。</p><p><font color=red>注意：当绑定新域名后，需同步修改<code>_config.yml</code>文件中的<code>url</code>配置项为自己的新域名</font></p><p>之后就可以访问自定义的域名来浏览博客啦~</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">url:</span> <span class="string">&lt;自定义的新域名&gt;</span></span><br></pre></td></tr></table></figure><h2 id="4-Butterfly主题安装与应用"><a href="#4-Butterfly主题安装与应用" class="headerlink" title="4.Butterfly主题安装与应用"></a>4.Butterfly主题安装与应用</h2><h3 id="4-1-主题安装"><a href="#4-1-主题安装" class="headerlink" title="4.1 主题安装"></a>4.1 主题安装</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># npm 安装</span></span><br><span class="line">npm i hexo-theme-butterfly</span><br></pre></td></tr></table></figure><p>命令执行安装后，可在项目的依赖包文件夹<code>node_modules</code>下找到该主题<code>hexo-theme-butterfly</code>文件夹</p><h3 id="4-2-主题应用"><a href="#4-2-主题应用" class="headerlink" title="4.2 主题应用"></a>4.2 主题应用</h3><ul><li>修改<code>_config.yml</code>文件中的<code>theme</code>配置项改为<code>butterfly</code>。</li><li>安装Butterfly主题必需的渲染依赖</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">theme: butterfly</span><br><span class="line"><span class="comment"># 主题的渲染依赖</span></span><br><span class="line">npm install hexo-renderer-pug hexo-renderer-stylus --save</span><br></pre></td></tr></table></figure><blockquote><p>建议：</p><p>将依赖包中主题文件夹中的 <code>_config.yml</code> 复制到 Hexo 根目录里 且 重命名为 <code>_config.butterfly.yml</code>，之后只需操作 <code>_config.butterfly.yml</code>即可。</p><p><font size=2>Hexo会自动合并主题中的<code>_config.yml</code>和 <code>_config.butterfly.yml</code>里的配置，如果存在同名配置，会使用<code>_config.butterfly.yml</code>的配置，其优先度较高。</font></p></blockquote><h2 id="5-写作——博客文章书写"><a href="#5-写作——博客文章书写" class="headerlink" title="5.写作——博客文章书写"></a>5.写作——博客文章书写</h2><p><a href="https://hexo.io/zh-cn/docs/writing">参考__官方文档</a></p><p>我们在<code>source/_posts</code>文件夹下新建<code>.md</code>文件进行文章的编辑操作</p><h3 id="Front-matter"><a href="#Front-matter" class="headerlink" title="Front-matter"></a>Front-matter</h3><p><code>Front-matter</code> 是文件最上方以 <code>---</code> 分隔的区域，用于指定个别文件的变量</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title:</span><br><span class="line"><span class="section">date:</span></span><br><span class="line"><span class="section">---</span></span><br></pre></td></tr></table></figure><table><thead><tr><th>参数</th><th>描述 []符号代表非必需</th><th>默认值</th></tr></thead><tbody><tr><td>title</td><td>文章标题</td><td>文章的文件名</td></tr><tr><td>date</td><td>文章创建日期</td><td>文章建立日期</td></tr><tr><td>updated</td><td>[文章更新日期]</td><td>文件更新日期</td></tr><tr><td>tags</td><td>[文章标签]</td><td></td></tr><tr><td>categories</td><td>[文章分类]</td><td></td></tr><tr><td>keywords</td><td>[文章关键字]</td><td></td></tr><tr><td>description</td><td>[文章描述]</td><td></td></tr><tr><td>top_img</td><td>[文章顶部图片]</td><td></td></tr><tr><td>cover</td><td>[文章缩略图(如果没有设置top_img,文章页顶部将显示缩略图，可设为false&#x2F;图片地址&#x2F;留空)]</td><td></td></tr><tr><td>comments</td><td>[开启文章评论功能]</td><td>true</td></tr><tr><td>aside</td><td>[显示侧边栏]</td><td>true</td></tr><tr><td>highlight_shrink</td><td>[配置代码框是否展开(true&#x2F;false)]</td><td>wen默认为设置中highlight_shrink的配置</td></tr></tbody></table><h3 id="文章链接优化——abblink"><a href="#文章链接优化——abblink" class="headerlink" title="文章链接优化——abblink"></a>文章链接优化——abblink</h3><p>hexo博客的文章URL格式是在<code>_config.yml</code>下配置<code>permalink</code>，默认格式为：:year&#x2F;:month&#x2F;:day&#x2F;:title&#x2F;，此处介绍abblink插件，避免URL出现中文以及暴露日期文章名称等。</p><p>首先，安装<strong>hexo-abbrlink</strong>插件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-abbrlink --save</span><br></pre></td></tr></table></figure><p>然后修改站点配置文件<code>_config.yml</code>，当使用<code>hexo g</code>后会自动在文章中加上abbrlink</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">permalink: article/:abbrlink.html</span><br><span class="line">abbrlink:</span><br><span class="line">  alg: crc32  <span class="comment"># 算法：crc16(default) and crc32</span></span><br><span class="line">  rep: hex    <span class="comment"># 进制：dec(default) and hex</span></span><br></pre></td></tr></table></figure><h2 id="6-Butterfly主题配置与美化"><a href="#6-Butterfly主题配置与美化" class="headerlink" title="6.Butterfly主题配置与美化"></a>6.Butterfly主题配置与美化</h2><p>Butterfly主题相关配置在<code>_config.butterfly.yml</code>中进行</p><h3 id="文章置顶与封面"><a href="#文章置顶与封面" class="headerlink" title="文章置顶与封面"></a>文章置顶与封面</h3><p><strong>【置顶】</strong><br>可以直接在文章的<strong>front-matter</strong>区域里添加<code>sticky: 1</code>属性来把这篇文章置顶。数值越大，置顶的优先级越大。<br><strong>【封面】</strong><br>文章的 markdown 文档上,在 <strong>Front-matter</strong> 添加 <code>cover</code> ,并填上要显示的图片地址。</p><h3 id="网站图标更换"><a href="#网站图标更换" class="headerlink" title="网站图标更换"></a>网站图标更换</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Favicon（网站图标）</span></span><br><span class="line"><span class="attr">favicon:</span> <span class="string">/img/xxx.png</span></span><br></pre></td></tr></table></figure><p>图片自定义，并且修改配置文件<code>_config.butterfly.yml</code>后，需要在依赖包对应的主题文件夹的相对路径下添加此图片，此处的添加路径为<br><code>node_modules/hexo-theme-butterfly/source/img</code> 添加<code>xx.png</code>表示网站图标。</p><h3 id="Live2D看板"><a href="#Live2D看板" class="headerlink" title="Live2D看板"></a>Live2D看板</h3><p>控制台&#x2F;终端安装插件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm install --save hexo-helper-live2d</span><br><span class="line">npm install --save live2d-widget-model-koharu</span><br></pre></td></tr></table></figure><p>修改配置文件<code>_config.yml</code>，在配置文件末尾添加如下配置项：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Live2D</span></span><br><span class="line"><span class="comment">## https://github.com/EYHN/hexo-helper-live2d</span></span><br><span class="line"><span class="attr">live2d:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span> <span class="comment">#开关插件版看板娘</span></span><br><span class="line">  <span class="attr">scriptFrom:</span> <span class="string">local</span> <span class="comment"># 默认</span></span><br><span class="line">  <span class="attr">pluginRootPath:</span> <span class="string">live2dw/</span> <span class="comment"># 插件在站点上的根目录(相对路径)</span></span><br><span class="line">  <span class="attr">pluginJsPath:</span> <span class="string">lib/</span> <span class="comment"># 脚本文件相对与插件根目录路径</span></span><br><span class="line">  <span class="attr">pluginModelPath:</span> <span class="string">assets/</span> <span class="comment"># 模型文件相对与插件根目录路径</span></span><br><span class="line">  <span class="comment"># scriptFrom: jsdelivr # jsdelivr CDN</span></span><br><span class="line">  <span class="comment"># scriptFrom: unpkg # unpkg CDN</span></span><br><span class="line">  <span class="comment"># scriptFrom: https://npm.elemecdn.com/live2d-widget@3.x/lib/L2Dwidget.min.js # 你的自定义 url</span></span><br><span class="line">  <span class="attr">tagMode:</span> <span class="literal">false</span> <span class="comment"># 标签模式, 是否仅替换 live2d tag标签而非插入到所有页面中</span></span><br><span class="line">  <span class="attr">debug:</span> <span class="literal">false</span> <span class="comment"># 调试, 是否在控制台输出日志</span></span><br><span class="line">  <span class="attr">model:</span></span><br><span class="line">    <span class="attr">use:</span> <span class="string">live2d-widget-model-koharu</span> <span class="comment"># npm-module package name</span></span><br><span class="line">    <span class="comment"># use: koharu tororo wanko # 博客根目录/live2d_models/ 下的目录名</span></span><br><span class="line">    <span class="comment"># use: ./wives/wanko # 相对于博客根目录的路径</span></span><br><span class="line">    <span class="comment"># use: https://npm.elemecdn.com/live2d-widget-model-wanko@1.0.5/assets/wanko.model.json # 你的自定义 url</span></span><br><span class="line">  <span class="attr">display:</span></span><br><span class="line">    <span class="attr">position:</span> <span class="string">left</span> <span class="comment">#控制看板娘位置</span></span><br><span class="line">    <span class="attr">width:</span> <span class="number">150</span> <span class="comment">#控制看板娘大小</span></span><br><span class="line">    <span class="attr">height:</span> <span class="number">300</span> <span class="comment">#控制看板娘大小</span></span><br><span class="line">  <span class="attr">mobile:</span></span><br><span class="line">    <span class="attr">show:</span> <span class="literal">false</span> <span class="comment"># 手机中是否展示</span></span><br></pre></td></tr></table></figure><h1 id="Hexo博客部署命令"><a href="#Hexo博客部署命令" class="headerlink" title="Hexo博客部署命令"></a><a href="https://butterfly.js.org/">Hexo博客</a>部署命令</h1><h2 id="本地部署与线上部署"><a href="#本地部署与线上部署" class="headerlink" title="本地部署与线上部署"></a>本地部署与线上部署</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 本地</span></span><br><span class="line">hexo cl; hexo s</span><br><span class="line"><span class="comment"># 线上</span></span><br><span class="line">hexo clean; hexo g; hexo d</span><br></pre></td></tr></table></figure><h2 id="快速上手"><a href="#快速上手" class="headerlink" title="快速上手"></a>快速上手</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>在地址栏里输入一个 URL，到这个页面呈现出来，中间会发生什么</title>
      <link href="/posts/1e169319.html"/>
      <url>/posts/1e169319.html</url>
      
        <content type="html"><![CDATA[<h2 id="在地址栏里输入一个-URL，到这个页面呈现出来，中间会发生什么？"><a href="#在地址栏里输入一个-URL，到这个页面呈现出来，中间会发生什么？" class="headerlink" title="在地址栏里输入一个 URL，到这个页面呈现出来，中间会发生什么？"></a>在地址栏里输入一个 URL，到这个页面呈现出来，中间会发生什么？</h2><ul><li>DNS 解析</li><li>TCP 连接</li><li>发送 HTTP 请求</li><li>服务器处理请求并返回 HTTP 报文</li><li>浏览器解析渲染页面</li><li>连接结束</li></ul><p>输入 url 后，首先需要找到这个 url 域名的服务器 ip<br>为了寻找这个 ip，浏览器首先会寻找缓存，查看缓存中是否有记录，缓存的查找记录为：浏览器缓存-》系统缓存 -》路由器缓存，<br>缓存中没有则查找系统的 hosts 文件中是否有记录，<br>如果没有则查询 DNS 服务器，<br>得到服务器的 ip 地址后，浏览器根据这个 ip 以及相应的端口号，构造一个 http 请求，<br>这个请求报文会包括这次请求的信息，主要是请求方法，请求说明和请求附带的数据，并将这个 http 请求封装在一个 tcp 包中，<br>这个 tcp 包会依次经过传输层，网络层，数据链路层，物理层到达服务器，服务器解析这个请求来作出响应，返回相应的 html 给浏览器，<br>因为 html 是一个树形结构，浏览器根据这个 html 来构建 DOM 树，<br>在 dom 树的构建过程中如果遇到 JS 脚本和外部 JS 连接，则会停止构建 DOM 树来执行和下载相应的代码，这会造成阻塞，<br>这就是为什么推荐 JS 代码应该放在 html 代码的后面，之后根据外部样式，内部样式，内联样式构建一个 CSS 对象模型树 CSSOM 树，<br>构建完成后和 DOM 树合并为渲染树，这里主要做的是排除非视觉节点，<br>比如 script，meta 标签和排除 display 为 none 的节点，之后进行布局，<br>布局主要是确定各个元素的位置和尺寸，之后是渲染页面，<br>因为 html 文件中会含有图片，视频，音频等资源，在解析 DOM 的过程中，遇到这些都会进行并行下载，<br>浏览器对每个域的并行下载数量有一定的限制，一般是 4-6 个，当然在这些所有的请求中我们还需要关注的就是缓存，<br>缓存一般通过 Cache-Control、Last-Modify、Expires 等首部字段控制。<br>Cache-Control 和 Expires 的区别在于 Cache-Control 使用相对时间，Expires 使用的是基于服务器端的绝对时间，因为存在时差问题，一般采用 Cache-Control，<br>在请求这些有设置了缓存的数据时，会先查看是否过期，如果没有过期则直接使用本地缓存，过期则请求并在服务器校验文件是否修改，<br>如果上一次响应设置了 ETag 值会在这次请求的时候作为 If-None-Match 的值交给服务器校验，<br>如果一致，继续校验Last-Modified，没有设置 ETag 则直接验证 Last-Modified，再决定是否返回 304。</p>]]></content>
      
      
      <categories>
          
          <category> 前端基础 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>WebStorm的一些常用快捷键</title>
      <link href="/posts/f47680a4.html"/>
      <url>/posts/f47680a4.html</url>
      
        <content type="html"><![CDATA[<h1 id="WebStorm快捷键"><a href="#WebStorm快捷键" class="headerlink" title="WebStorm快捷键"></a>WebStorm快捷键</h1><table><thead><tr><th>WebStorm快捷键</th><th>说明</th></tr></thead><tbody><tr><td><code>Ctrl+Shift+U</code></td><td>大小写转换</td></tr><tr><td><code>Ctrl+D</code></td><td>复制当前行</td></tr><tr><td><code>Ctrl+F4</code></td><td>关闭当前选项卡</td></tr><tr><td><code>Ctrl+R</code></td><td>当前文件内代码替换</td></tr><tr><td><code>Ctrl+Shift+R</code></td><td>全局搜索替换</td></tr><tr><td><code>Ctrl+F</code></td><td>当前文件内搜索</td></tr><tr><td><code>Ctrl+Shift+F</code></td><td>全局搜索</td></tr><tr><td><code>Ctrl+Alt+L</code></td><td>格式化代码</td></tr><tr><td><code>Ctrl+/</code></td><td>单行注释</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 日常Tips </category>
          
      </categories>
      
      
        <tags>
            
            <tag> WebStorm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>canvas+svg</title>
      <link href="/posts/2e768727.html"/>
      <url>/posts/2e768727.html</url>
      
        <content type="html"><![CDATA[<p>snap.svg</p><p>v-drag拖拽</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>修改浏览器滚动条</title>
      <link href="/posts/727c85fe.html"/>
      <url>/posts/727c85fe.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>跨域、同源策略</title>
      <link href="/posts/e899c839.html"/>
      <url>/posts/e899c839.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>地址与域名的关系</title>
      <link href="/posts/ac5c3742.html"/>
      <url>/posts/ac5c3742.html</url>
      
        <content type="html"><![CDATA[<h2 id="地址与域名"><a href="#地址与域名" class="headerlink" title="地址与域名"></a>地址与域名</h2><p>一个域名只有一个ip地址，一个地址可以对应多个域名。</p><h2 id="80、8080端口"><a href="#80、8080端口" class="headerlink" title="80、8080端口"></a>80、8080端口</h2><p>HTTP默认端口80,8080一般用于连接代理</p><h2 id="127-0-0-1"><a href="#127-0-0-1" class="headerlink" title="127.0.0.1"></a>127.0.0.1</h2><p>127.0.0.1等同于localhost</p><ul><li>localhost是本地DNS解析的127.0.0.1的域名</li><li>localhost是域名，一般windows系统默认将localhost指向127.0.0.1</li></ul><p>127.0.0.1与0.0.0.0</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Vue生命周期</title>
      <link href="/posts/83f13096.html"/>
      <url>/posts/83f13096.html</url>
      
        <content type="html"><![CDATA[<h1 id="Vue"><a href="#Vue" class="headerlink" title="Vue"></a>Vue</h1><h2 id="Vue生命周期"><a href="#Vue生命周期" class="headerlink" title="Vue生命周期"></a>Vue生命周期</h2><p><strong>Vue的生命周期</strong>：</p><blockquote><p>Vue实例从创建到销毁的过程为生命周期，即指从创建、初始化数据、编译模板、挂载Dom到渲染、更新到渲染、销毁的一系列过程，它主要分为8个阶段：创建前后、载入前后、更新前后、销毁前后以及一些特殊场景的生命周期。</p></blockquote><table><thead><tr><th>生命周期</th><th>描述</th></tr></thead><tbody><tr><td>beforeCreate</td><td>组件实例被创建之初<br/>执行时组件实例还未创建，通常用于插件开发中执行一些初始化任务</td></tr><tr><td>created</td><td>组件实例已经完全创建<br/>组件实例初始化完毕，各种数据可以使用，常用于异步数据获取</td></tr><tr><td>beforeMount</td><td>组件挂载之前<br/>未执行渲染、更新，dom未创建</td></tr><tr><td>mounted</td><td>组件挂载到实例上去之后<br/>初始化结束，dom已创建，可用于获取访问数据和dom元素</td></tr><tr><td>beforeUpdate</td><td>组件数据发生变化，更新之前<br/>更新前，可用于获取更新前各种状态</td></tr><tr><td>updated</td><td>组件数据更新之后<br/>更新后，所有状态已是最新</td></tr><tr><td>beforeDestroy</td><td>组件实例销毁之前<br/>销毁前，可用于一些定时器或订阅的取消</td></tr><tr><td>destroyed</td><td>组件实例销毁之后<br/>组件已销毁</td></tr><tr><td>activated</td><td>keep-alive缓存的组件激活时</td></tr><tr><td>deactivated</td><td>keep-alive缓存的组件停用时调用</td></tr><tr><td>errorCaptured</td><td>捕获一个来自子孙组件的错误时被调用</td></tr></tbody></table><p><strong>Vue生命周期</strong>的整体流程如下图所示：</p><p><img src="/images/article/vue/vue%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.png"></p><ul><li><code>beforeCreate</code> → <code>created</code></li><li><ul><li>初始化vue实例，进行数据观测</li></ul></li><li><code>created</code></li><li><ul><li>完成数据观测，属性与方法的计算，watch、event事件回调的配置</li><li>可调用methods中的方法，访问和修改data数据触发响应式渲染dom</li><li>可通过computed和watch完成数据计算</li><li>此时vm.$el并未被创建</li></ul></li><li><code>created</code> → <code>beforeMount</code></li><li><ul><li>判断是否存在el选项，不存在则停止编译，直至调用vm.$mounted(el)才会继续编译</li><li>优先级：render &gt; template &gt; 外层HTML</li><li>vm.el获取到的是挂载dom的</li></ul></li><li><code>beforeMount</code></li><li><ul><li>此阶段可获取到vm.el，vm.el虽已完成dom初始化，但并未挂载在el选项上</li></ul></li><li><code>beforeMount</code> → <code>mounted</code></li><li><ul><li>vm.el完成挂载，vm.$el生成的dom替换了el选项对应的dom</li></ul></li><li><code>mounted</code></li><li><ul><li>vm.el已经完成dom的挂载与渲染，此刻打印vm.$el，发现之前的挂载点及内容已被替换为新的dom</li></ul></li><li><code>beforeUpdate</code></li><li><ul><li>更新的数据必须是被渲染在模板上的(el、template、render之一)</li><li>此时view层还未更新；若再次修改数据，不会再次触发更新方法</li></ul></li><li><code>updated</code></li><li><ul><li>完成view层的更新；若再次修改数据，会再次触发更新方法(beforeUpdate、updated)</li></ul></li><li><code>beforeDestroy</code></li><li><ul><li>实例被销毁前调用，此时实例属性与方法仍可访问</li></ul></li><li><code>destroyed</code></li><li><ul><li>完全销毁一个实例</li><li>可清理它与其它实例的连接，解绑它的全部指令及事件监听器</li><li>并不能清除dom，仅仅销毁实例</li></ul></li></ul><h3 id="created-与-mounted"><a href="#created-与-mounted" class="headerlink" title="created 与 mounted"></a>created 与 mounted</h3><table>    <tr>        <th></th>        <th>created</th>        <th>mounted</th>    </tr>    <tr>        <td>不同点</td>        <td>是在组件实例一旦创建完成的时候立刻调用，<br>页面dom节点并未生成，触发时机比mounted更早</td>        <td>是在页面dom节点渲染完毕后立刻执行的<br></td>    </tr>    <tr>        <td>相同点</td>        <td colspan=2 align=center>都能拿到实例对象的属性和方法</td>    </tr></table><h3 id="Vue父子组件生命周期顺序"><a href="#Vue父子组件生命周期顺序" class="headerlink" title="Vue父子组件生命周期顺序"></a>Vue父子组件生命周期顺序</h3><h2 id="Vue和jQuery"><a href="#Vue和jQuery" class="headerlink" title="Vue和jQuery"></a>Vue和jQuery</h2><ul><li>jQuery：事件驱动</li><li>Vue：数据驱动，双向绑定，设计模式MVVM，单文件模式</li><li><ul><li>M：Model 数据逻辑处理</li></ul></li><li><ul><li>V：View 视图</li></ul></li><li><ul><li>VM：View Model 数据视图</li></ul></li></ul><h2 id="Vue指令"><a href="#Vue指令" class="headerlink" title="Vue指令"></a>Vue指令</h2><ul><li>v-text：设置标签文本值（支持表达式）</li><li>v-html：</li><li>v-on：</li><li>v-show：</li><li>v-if：</li><li>v-bind：</li><li>v-for：</li><li>v-model：</li><li></li></ul>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> Vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
            <tag> Vue生命周期 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Axios</title>
      <link href="/posts/6155a9d6.html"/>
      <url>/posts/6155a9d6.html</url>
      
        <content type="html"><![CDATA[<h2 id=""><a href="#" class="headerlink" title=""></a></h2>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> axios </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSS</title>
      <link href="/posts/b6981f1b.html"/>
      <url>/posts/b6981f1b.html</url>
      
        <content type="html"><![CDATA[<h1 id="一文读懂CSS"><a href="#一文读懂CSS" class="headerlink" title="一文读懂CSS"></a>一文读懂CSS</h1><h2 id="CSS优先级"><a href="#CSS优先级" class="headerlink" title="CSS优先级"></a>CSS优先级</h2><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">!important() &gt; 行内样式(1000) &gt; ID选择器(0100) &gt; 类、伪类选择器(0010) &gt; 元素选择器(0001) &gt; 继承/通配符选择器<span class="code">`*`</span>(0000)</span><br></pre></td></tr></table></figure><h2 id="CSS盒模型-Box-Model"><a href="#CSS盒模型-Box-Model" class="headerlink" title="CSS盒模型(Box Model)"></a>CSS盒模型(Box Model)</h2><blockquote><p>CSS盒模型本质上是一个盒子，封装周围的HTML元素，它包括：边距<code>margin</code>，边框<code>border</code>，填充<code>padding</code>，和实际内容<code>content</code>。</p></blockquote><p><img src="/images/article/css/css%E7%9B%92%E6%A8%A1%E5%9E%8B.png"></p><ul><li>改变内边距padding则可以改变内容与盒子之间的距离</li><li>改变外边距margin则可以改变盒子之间的距离</li></ul><h3 id="计算模型"><a href="#计算模型" class="headerlink" title="计算模型"></a>计算模型</h3><p>盒子大小的计算分为：<strong>标准盒子模型</strong>、<strong>IE盒子模型</strong>，通过CSS属性box-sizing设置</p><ul><li>标准盒子模型：<code>box-sizing: content-box</code></li><li>IE盒子模型：<code>box-sizing: border-box</code></li><li>若box-sizing设置为<code>box-sizing: inherit</code>时，则从父元素继承</li></ul><table><thead><tr><th></th><th>标准盒子模型</th><th>IE盒子模型&#x2F;怪异盒模型</th></tr></thead><tbody><tr><td>box-sizing</td><td><code>content-box</code></td><td><code>border-box</code></td></tr><tr><td>宽&#x2F;高(width&#x2F;height)</td><td><strong>width&#x3D;content</strong></td><td><strong>width&#x3D;content+padding+border</strong></td></tr><tr><td>盒子大小(盒子总宽度)</td><td>width+padding+border+margin</td><td>width+margin</td></tr></tbody></table><h2 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h2><h3 id="画三角形"><a href="#画三角形" class="headerlink" title="画三角形"></a>画三角形</h3><p>三角形原理：边框的均分原理</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>:<span class="number">0</span>;</span><br><span class="line">    <span class="attribute">height</span>:<span class="number">0</span>;</span><br><span class="line">    <span class="attribute">border-top</span>: <span class="number">10px</span> solid red;</span><br><span class="line">    <span class="attribute">border-right</span>: <span class="number">10px</span> solid transparent;</span><br><span class="line">    <span class="attribute">border-bottom</span>: <span class="number">10px</span> solid transparent;</span><br><span class="line">    <span class="attribute">border-left</span>: <span class="number">10px</span> solid transparent;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="画一条0-5px的线"><a href="#画一条0-5px的线" class="headerlink" title="画一条0.5px的线"></a>画一条0.5px的线</h3><ul><li>采用 meta viewport 的方式<meta name="viewport" content="initial-scale=1.0, maximum-scale=1.0, user-scalable=no" /></li><li>采用 border-image 的方式</li><li>采用 transform: scale()的方式</li></ul><h2 id=""><a href="#" class="headerlink" title=""></a></h2>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTML标签</title>
      <link href="/posts/20d7027.html"/>
      <url>/posts/20d7027.html</url>
      
        <content type="html"><![CDATA[<h1 id="HTML标签"><a href="#HTML标签" class="headerlink" title="HTML标签"></a>HTML标签</h1><h2 id="关于标签嵌套"><a href="#关于标签嵌套" class="headerlink" title="关于标签嵌套"></a>关于标签嵌套</h2><ul><li><code>a</code>标签中可以嵌套标签，不可以放块标签</li><li>块级元素与块级元素平级，内嵌元素与内嵌元素平级</li><li>块元素可以包含内联元素或某些块元素；内联元素不可以包含块元素，只能包含其他内联元素</li><li>几个特殊的块级元素只能包含内嵌元素，不能再包含块级元素 </li><li><ul><li><code>h1</code>~&#96;h6<code>、</code>p<code>、</code>dt&#96;</li></ul></li><li>块级元素不能放在标签<code>p</code>里面</li><li><code>li</code>标签可以包含<code>div</code>标签，因为li和div都是装载内容的容器</li></ul><blockquote><p>为提高浏览器的渲染效率，应尽量少的嵌套标签、扁平化。</p></blockquote><h2 id="块级元素与内联元素"><a href="#块级元素与内联元素" class="headerlink" title="块级元素与内联元素"></a>块级元素与内联元素</h2><table><thead><tr><th>块级元素</th><th>内联元素（行内元素）</th></tr></thead><tbody><tr><td>独占一行，默认情况下，其宽度自动填满其父元素宽度</td><td>相邻行内元素排列在同一行，直至一行排不下，才会换行，其宽度随元素内容而变化</td></tr><tr><td>可以设置宽高width&#x2F;height属性</td><td>设置宽高无效</td></tr><tr><td>可以设置margin padding属性</td><td>行内元素起边距作用的只有 <strong>margin-left</strong>&#x2F;<strong>margin-right</strong>&#x2F;<strong>padding-left</strong>&#x2F;<strong>padding-right</strong></td></tr><tr><td>对应属性display:block</td><td>对应display:inline</td></tr></tbody></table><h2 id="HTML-语义化标签的理解"><a href="#HTML-语义化标签的理解" class="headerlink" title="HTML 语义化标签的理解"></a>HTML 语义化标签的理解</h2><p>HTML5 语义化标签是指正确的标签包含了正确的内容，结构良好，便于阅读，比如 nav 表示导航条，类似的还有 article、header、footer 等等标签。</p><h2 id="HTML5-新增的元素"><a href="#HTML5-新增的元素" class="headerlink" title="HTML5 新增的元素"></a>HTML5 新增的元素</h2><p>语义化标签 header,footer,nav,aside,section<br>增强表单，为 input 增加了 color， emial,data ,range 等类型<br>存储，提供了 sessionStorage，localStorage,和 离线存储，通过这些存储方式方便数据在客户端的存储和获取<br>多媒体，规定了 音频和视频元素 audio 和 vedio<br>地理定位<br>canvas 画布<br>拖放<br>多线程编程的 web worker 和 websocket 协议。</p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTML </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
