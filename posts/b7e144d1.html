<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0"><title>算法 | MANGOのBlog</title><meta name="author" content="Mango Ru"><meta name="copyright" content="Mango Ru"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="算法简介算法是指解决问题的方法或过程（步骤），算法的四个性质：输入、输出、确定性和有限性。 常用的描述算法的形式：自然语言、程序流程图、伪代码。 12345678算法归类：- 递归：汉诺塔- 分治：二分查找、归并排序、快速排序- 动态规划：0-1背包、矩阵连乘、最长公共子序列- 贪心：Dijkstra算法、Kruskal算法、Prim算法、背包问题- 回溯：0-1背包、N皇后、旅行售货员、m着色…">
<meta property="og:type" content="article">
<meta property="og:title" content="算法">
<meta property="og:url" content="https://www.mangodb.site/posts/b7e144d1.html">
<meta property="og:site_name" content="MANGOのBlog">
<meta property="og:description" content="算法简介算法是指解决问题的方法或过程（步骤），算法的四个性质：输入、输出、确定性和有限性。 常用的描述算法的形式：自然语言、程序流程图、伪代码。 12345678算法归类：- 递归：汉诺塔- 分治：二分查找、归并排序、快速排序- 动态规划：0-1背包、矩阵连乘、最长公共子序列- 贪心：Dijkstra算法、Kruskal算法、Prim算法、背包问题- 回溯：0-1背包、N皇后、旅行售货员、m着色…">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://www.mangodb.site/images/article/default_bg.png">
<meta property="article:published_time" content="2023-03-04T11:53:30.000Z">
<meta property="article:modified_time" content="2023-04-05T15:25:30.788Z">
<meta property="article:author" content="Mango Ru">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://www.mangodb.site/images/article/default_bg.png"><link rel="shortcut icon" href="/img/mango.png"><link rel="canonical" href="https://www.mangodb.site/posts/b7e144d1.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//fonts.googleapis.com" crossorigin=""/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://unpkg.com/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web&amp;display=swap" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":true,"languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简"},
  noticeOutdate: {"limitDay":99999,"position":"top","messagePrev":"It has been","messageNext":"days since the last update, the content of the article may be outdated."},
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":200},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    post: true
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":50,"languages":{"author":"作者: Mango Ru","link":"链接: ","source":"来源: MANGOのBlog","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'mediumZoom',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://unpkg.com/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://unpkg.com/flickr-justified-gallery/dist/fjGallery.css'
    }
  },
  isPhotoFigcaption: true,
  islazyload: true,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  }
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '算法',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-04-05 23:25:30'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="/css/custom.css"><link rel="stylesheet" href="/css/universe.css"><link rel="stylesheet" href="/css/custom.css" media="defer" onload="this.media='all'"><!-- hexo injector head_end start --><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-footer-beautify@1.0.0/lib/runtime.css" media="print" onload="this.media='all'"><!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.3.0"></head><body><link rel="stylesheet" href="https://unpkg.com/pace-js/themes/blue/pace-theme-minimal.css"/><script src="https://unpkg.com/pace-js/pace.min.js"></script><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/avatar/joy.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">14</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">8</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">8</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/images/article/default_bg.png')"><nav id="nav"><span id="blog-info"><a href="/" title="MANGOのBlog"><span class="site-name">MANGOのBlog</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">算法</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-03-04T11:53:30.000Z" title="发表于 2023-03-04 19:53:30">2023-03-04</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-04-05T15:25:30.788Z" title="更新于 2023-04-05 23:25:30">2023-04-05</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%89%8D%E7%AB%AF/">前端</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%89%8D%E7%AB%AF/%E7%AE%97%E6%B3%95/">算法</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">26.3k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>106分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="算法"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h2 id="算法简介"><a href="#算法简介" class="headerlink" title="算法简介"></a>算法简介</h2><p>算法是指解决问题的方法或过程（步骤），算法的四个性质：<font color=red>输入、输出、确定性和有限性</font>。</p>
<p>常用的描述算法的形式：自然语言、程序流程图、伪代码。</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">算法归类：</span><br><span class="line"></span><br><span class="line"><span class="bullet">-</span> 递归：汉诺塔</span><br><span class="line"><span class="bullet">-</span> 分治：二分查找、归并排序、快速排序</span><br><span class="line"><span class="bullet">-</span> 动态规划：0-1背包、矩阵连乘、最长公共子序列</span><br><span class="line"><span class="bullet">-</span> 贪心：Dijkstra算法、Kruskal算法、Prim算法、背包问题</span><br><span class="line"><span class="bullet">-</span> 回溯：0-1背包、N皇后、旅行售货员、m着色</span><br><span class="line">……</span><br></pre></td></tr></table></figure>

<h3 id="算法复杂性分析"><a href="#算法复杂性分析" class="headerlink" title="算法复杂性分析"></a>算法复杂性分析</h3><p><strong>几个概念</strong></p>
<p> <font color=orange>算法复杂性 &#x3D; 算法所需要的计算机资源</font>，用N、I 来表示算法要解决问题的规模和算法的输入，用C表示算法的复杂性，有：<font color=orange>C &#x3D;F(N,I)</font></p>
<p> <font color=orange>算法的时间复杂性T(n)</font>：如果问题的规模为n，在算法输入为I时算法所需的时间资源为T(N,I) ，T(N,I)称为算法的时间复杂性</p>
<p> <font color=orange>算法的空间复杂性S(n)</font>：如果问题的规模为n，在算法输入为I时算法所需的空间资源为S(N,I) ，S(N,I)称为算法的空间复杂性</p>
<p> 算法分析：分析算法复杂性的过程</p>
<p> 空间复杂性分析相对比较简单，通常主要分析时间复杂性</p>
<p><strong>时间复杂性渐进表示法</strong></p>
<p>【符号O的运算规则】</p>
<p>• (1)<strong>O(f)+O(g)&#x3D;O(max(f,g))</strong></p>
<p>• (2)<strong>O(f)+O(g)&#x3D;O(f+g)</strong></p>
<p>• (3)<strong>O(f)O(g)&#x3D;O(fg)</strong></p>
<p>• (4)如果g(N)&#x3D;O(f(N))，则O(f)+O(g)&#x3D;O(f)</p>
<p>• (5)O(Cf(N))&#x3D;O(f(N))，其中C是一个正的常数</p>
<p>• (6)f&#x3D;O(f)</p>
<blockquote>
<p>思考练习：求下列函数的渐进表达式</p>
</blockquote>
<p>(1) 5$n^2$ + 10n &#x3D;O($n^2$)</p>
<p>(2) n + nlog$n^2$&#x3D;O(nlogn)  (<strong>log$_a$$M^n$&#x3D;nlog$_a$M</strong>)</p>
<p>(3) $n^2$ &#x2F;100 + $3^n$ &#x3D;O($3^n$) ???</p>
<p>(4) 20 log$3^n$ &#x3D;O(n)  </p>
<p>(5) 1&#x2F;$n^2$ + 1 &#x3D; O(1)</p>
<p>(6) log$n^5$ + $n^(1&#x2F;2)$ &#x3D; O(logn)</p>
<p><strong>常见的算法复杂度的大O阶</strong></p>
<p>√ O(1): 表示算法的运行时间为常量时间</p>
<p>√ O(logn): 二分查找等算法</p>
<p>√ O(n): 线性算法，例如线性查找</p>
<p>√ O(nlogn): 快速排序、归并排序等算法</p>
<p>√ O(n^2): 对数组进行排序的简单算法，例如冒泡排序等</p>
<p>√ O(n^3): 做两个n阶矩阵的乘法运算</p>
<p>√ O(2^n): 求具有n个元素集合的所有子集的算法</p>
<p>√ O(n!): 求具有n个元素的全排列的算法</p>
<p><strong>O(1)&lt;O(logn)&lt;O(n)&lt; O(nlogn) &lt;O($n^2$)&lt;O($2^n$)&lt;O(n!)</strong></p>
<h2 id="算法——递归算法"><a href="#算法——递归算法" class="headerlink" title="算法——递归算法"></a>算法——递归算法</h2><p><code>递归</code>：在调用一个函数的过程中又出现直接或间接调用该函数本身，称为函数的递归调用，这种函数称为<strong>递归函数</strong>。</p>
<ul>
<li><strong>直接递归</strong>：p函数定义中调用p函数</li>
<li><strong>间接递归</strong>：p函数定义中调用q函数，而q函数定义中又调用p函数</li>
<li>尾递归：一个递归过程或递归函数中的递归调用语句是最后一条执行语句</li>
</ul>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 递归实例</span></span><br><span class="line"></span><br><span class="line">1-100求和：f(n) = f(n-1) + n &#123;n&gt;1&#125;, f(1) = 1</span><br><span class="line">铺地板(2xn过道铺地板方案)：f(n) = f(n-1) + f(n-2) &#123;n&gt;2&#125;, f(1)=1,f(2)=2</span><br><span class="line">【求阶乘】：f(n) = n<span class="emphasis">*f(n-1) &#123;n&gt;0&#125;, f(0)=1</span></span><br><span class="line"><span class="emphasis">【Fibonacci数列】/兔子数列 =&gt; 蜂房问题：f(n) = f(n-1) + f(n-2) &#123;n&gt;2&#125;, f(1)=1,f(2)=1</span></span><br><span class="line"><span class="emphasis">青蛙跳台阶：f(n) = f(n-1) + f(n-2) &#123;n&gt;2&#125;, f(1)=1,f(2)=2</span></span><br></pre></td></tr></table></figure>

<p><strong>递归特点</strong></p>
<p>能够用递归解决的问题应该满足以下3个条件：</p>
<ul>
<li><ol>
<li>需要解决的问题可以转化为<strong>一个或多个子问题来求解</strong>，而这些子问题的<strong>求解方法与原问题完全相同</strong>，只是在数量规模上不同</li>
</ol>
</li>
<li><ol start="2">
<li>递归调用的<strong>次数</strong>必须是<strong>有限</strong>的</li>
</ol>
</li>
<li><ol start="3">
<li>必须有<strong>结束递归的条件</strong>来终止递归</li>
</ol>
</li>
</ul>
<p>递归两要素：<font color=green>递归表达式 + 递归结束条件</font></p>
<p><strong>何时使用递归？</strong></p>
<ul>
<li><ol>
<li><strong>定义</strong>是递归的（<u>阶乘</u>、<u>斐波那契数列</u>等）</li>
</ol>
</li>
<li><ol start="2">
<li><strong>数据结构</strong>是递归的（<u>单链表</u>、<u>二叉树</u>等）</li>
</ol>
</li>
<li><ol start="3">
<li><strong>问题的求解方法</strong>是递归的（<u>汉诺塔</u>、<u>回溯法</u>等）</li>
</ol>
</li>
</ul>
<p><strong>递归优缺点</strong>：</p>
<ul>
<li><p>优点：<strong>结构清晰，可读性强</strong>，而且容易用<em>数学归纳法来证明算法的正确性</em>，因此它为设计算法、调试程序带来很大方便。</p>
</li>
<li><p>缺点：递归算法的<strong>运行效率较低</strong>，无论是耗费的计算时间还是占用的存储空间都比非递归算法要多。</p>
</li>
<li><p>解决方法：在某些递归算法中可消除递归调用，使其<u>转化为非递归算法</u>。</p>
</li>
</ul>
<p><strong>【递归扩展实例】</strong></p>
<h3 id="Ackerman函数"><a href="#Ackerman函数" class="headerlink" title="Ackerman函数"></a>Ackerman函数</h3><blockquote>
<p><strong>Ackerman函数</strong></p>
</blockquote>
<p>当一个函数及它的一个变量（参数）是由函数自身定义时，称这个函数是<font color=orange>双递归函数</font>。</p>
<p>Ackerman函数 A(n，m) 定义如下：<br>$$<br>\begin{cases}<br>A(1,0)&#x3D;2\<br>A(0,m)&#x3D;1, \quad m\geq0\<br>A(n,0)&#x3D;n+2, \quad n\geq2\<br>A(n,m)&#x3D;A(A(n-1,m),m-1), \quad m\geq1\<br>\end{cases}<br>$$</p>
<h3 id="全排列问题"><a href="#全排列问题" class="headerlink" title="全排列问题"></a>全排列问题</h3><blockquote>
<p><strong>全排列问题</strong></p>
</blockquote>
<p>设计一个递归算法生成n个元素{r$_1$,r$_2$,…,r$_n$}的全排列。</p>
<p>设R&#x3D;{r$_1$,r$_2$,…,r$_n$}是要进行排列的n个元素，R$_i$ &#x3D;R-{r$_i$}。</p>
<p>集合X中元素的全排列记为perm(X)。</p>
<p>(r$_i$)perm(X)表示在全排列perm(X)的每一个排列前加上前缀得到的排列。R的全排列可归纳定义如下：</p>
<ul>
<li><p><font color=orange>当n&#x3D;1时，perm(R)&#x3D;(r)，其中r是集合R中唯一的元素；</font></p>
</li>
<li><p><font color=orange>当n&gt;1时，perm(R)由(r$_1$)perm(R$_1$)，(r$_2$)perm(R$_2$)，…，(r$_n$)perm(R$_n$)构成。</font></p>
</li>
</ul>
<p>&#x3D;&gt;</p>
<p>{1, 2, 3}的全排列如下：</p>
<p><strong>(1,2,3)，(1,3,2)，(2,1,3)，(2,3,1)，(3,1,2)，(3,2,1)</strong></p>
<p>【全排列问题】：</p>
<p> 分析：• 由排列组合的知识可知，<font color=orangedark>n个元素的全排列共有n!种。</font></p>
<p> 解决方案：</p>
<p>• 方案1：可以采用n层循环嵌套的方式 -&gt; 代码冗长</p>
<p>• 方案2：n!可分解为n*(n-1)!种，而(n-1)!又分解为(n-1)(n-2)!种，依次类推。 </p>
<p>(1) 可以用循环重复执行“<font color=orangedark>交换位置，后面再接剩余序列的所有排列</font>”；</p>
<p>(2) 对剩余的序列再使用该方法，直至没有剩余序列——递归调用。</p>
<p> 递归分析：</p>
<p>• 用一个数组a[n]来保存1<del>n之间的n个自然数，对于i&#x3D;1 ~ n，<font color=orange>每次用a[1]与a[i]交换后，对a[2]</del>a[n]中的n-1个元素进行全排列，然后再交换a[1]与a[i]的值，使它恢复到此次排列前的状态</font></p>
<p>• 对于<font color=orange>a[3]~a[n]区间内的n-2个元素进行全排列，然后再把交换的元素交换回来</font>；</p>
<p>• 依次类推，<font color=orange>直到对a[n]进行全排列时，输出整个数组的值，即得到一种排列结果。</font></p>
<p> <strong>算法设计</strong>：</p>
<p>对于n个元素a&#x3D;(a$_1$, a$_2$, ……a$_k$, ……a$_n$)，设过程 <strong>perm(a, k, n)</strong> 是<strong>求a的第k到第n个元素的全排列</strong>。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">procedure <span class="title function_">perm</span>(a,k,n)</span><br><span class="line"><span class="keyword">if</span> k=n then</span><br><span class="line">	<span class="title function_">print</span>(a)</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">for</span> i ← k to n <span class="keyword">do</span></span><br><span class="line">&#123; </span><br><span class="line">    a[k] &lt;--&gt; a[i];</span><br><span class="line">    call <span class="title function_">perm</span>(a,k+<span class="number">1</span>,n);</span><br><span class="line">    a[k]  &lt;--&gt; a[i];</span><br><span class="line">&#125;</span><br><span class="line">endif</span><br><span class="line">end</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 主程序：perm(a, k, n) 求a的第k到第n个元素的全排列</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 注意：a是数组Array，k、n为整数Number</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">perm</span>(<span class="params">a, k, n</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (k === n) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(a.<span class="title function_">join</span>(<span class="string">&quot;&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = k; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="comment">// 第一次交换 将元素换到打头位置</span></span><br><span class="line">        <span class="title function_">swap</span>(a,k,i);</span><br><span class="line">        <span class="title function_">perm</span>(a, k+<span class="number">1</span>, n);</span><br><span class="line">        <span class="comment">// 第二次交换 将两个元素再次换回，序列保持原状，防止重复</span></span><br><span class="line">        <span class="title function_">swap</span>(a,k,i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">swap</span>(<span class="params">a, k, i</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> t = a[k];</span><br><span class="line">    a[k] = a[i];</span><br><span class="line">    a[i] = t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>全排列问题应用：</p>
<ul>
<li><p>使用1-9这9个数字，每个数字各出现一次，如何组成如下数学公式：<strong>□□□</strong> <strong>+</strong> <strong>□□□</strong> <strong>&#x3D;</strong> <strong>□□□</strong></p>
</li>
<li><p>即：组成三个三位数，其中两个数之和等于第三个数。</p>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 提示</span></span><br><span class="line">int a = list[<span class="number">0</span>]*<span class="number">100</span> + list[<span class="number">1</span>]*<span class="number">10</span> + list[<span class="number">2</span>];</span><br><span class="line">int b = list[<span class="number">3</span>]*<span class="number">100</span> + list[<span class="number">4</span>]*<span class="number">10</span> + list[<span class="number">5</span>];</span><br><span class="line">int c = list[<span class="number">6</span>]*<span class="number">100</span> + list[<span class="number">7</span>]*<span class="number">10</span> + list[<span class="number">8</span>];</span><br><span class="line"><span class="keyword">if</span>(a + b == c) <span class="variable language_">console</span>.<span class="title function_">log</span>(a, b ,c);</span><br></pre></td></tr></table></figure>

<h3 id="整数划分问题"><a href="#整数划分问题" class="headerlink" title="整数划分问题"></a><strong>整数划分问题</strong></h3><blockquote>
<p><strong>整数划分问题</strong></p>
</blockquote>
<p>将正整数n表示成一系列正整数之和：n&#x3D;n$_1$+n$_2$+…+n$_k$，• 其中，n$_1$≥n$_2$≥…≥n$_k$≥1，k≥1。正整数n的这种表示称为<strong>正整数n的划分</strong>。</p>
<ul>
<li><p>例如正整数6有如下11种不同的划分：</p>
</li>
<li><ul>
<li><p>6</p>
<p>5+1</p>
<p>4+2，4+1+1</p>
<p>3+3，3+2+1，3+1+1+1</p>
<p>2+2+2，2+2+1+1，2+1+1+1+1</p>
<p>1+1+1+1+1+1</p>
</li>
</ul>
</li>
</ul>
<p>【<strong>整数划分问题</strong>】</p>
<p> 设p(n)为正整数n的划分数，难以找到递归关系</p>
<p> 考虑增加一个自变量：<font color=orange>将n的最大加数n$_1$不大于的m划分个数记作q(n,m)</font></p>
<p> 可建立q(n,m)的如下递归关系：</p>
<ul>
<li><p><strong>(1) q(n,1)&#x3D;1, n$\geq$1;</strong></p>
</li>
<li><ul>
<li>当最大加数n$_1$不大于1时，任何正整数n只有一种划分形式，即</li>
</ul>
</li>
</ul>
<p>$$<br>n &#x3D; \overbrace{1+1+\cdots+1}^{n}<br>$$</p>
<ul>
<li><p><strong>(2) q(n,m)&#x3D;q(n,n), m$\geq$n;</strong></p>
</li>
<li><ul>
<li>最大加数n$_1$实际上不能大于n。因此，q(1,m)&#x3D;1。</li>
</ul>
</li>
<li><p><strong>(3) q(n,n)&#x3D;1+q(n,n-1);</strong></p>
</li>
<li><ul>
<li>正整数n的划分由n$_1$&#x3D;n的划分和n$_1$≤n-1的划分组成。</li>
</ul>
</li>
<li><p><strong>(4) q(n,m)&#x3D;q(n,m-1)+q(n-m,m), n&gt;m&gt;1;</strong></p>
</li>
<li><ul>
<li>正整数n的最大加数n$_1$不大于m的划分由n$_1$&#x3D;m的划分和n$_1$≤n-1 的划分组成。</li>
</ul>
</li>
</ul>
<p>递推公式如下：<br>$$<br>q(n,m) &#x3D;<br>\begin{cases}<br>1 &amp; \quad n&#x3D;1,m&#x3D;1\<br>q(n,n) &amp;\quad n&lt;m\<br>1+q(n,n-1) &amp;\quad n&#x3D;m\<br>q(n,m-1)+q(n-m,m) &amp;\quad n&gt;m&gt;1\<br>\end{cases}<br>$$<br>正整数n的划分数p(n)&#x3D;q(n,n)</p>
<h3 id="汉诺塔问题O-2-n"><a href="#汉诺塔问题O-2-n" class="headerlink" title="汉诺塔问题O(2$^n$)"></a>汉诺塔问题O(2$^n$)</h3><blockquote>
<p><strong>汉诺塔问题（梵塔问题, Tower of Hanoi）</strong></p>
</blockquote>
<p>问题描述：</p>
<p>设A, B, C是3个塔座。开始时，在塔座A上有一叠共n个圆盘，这些圆盘自下而上，由大到小地叠在一起。</p>
<p>各圆盘从小到大编号为1,2,…,n，现要求将塔座A上的这一叠圆盘移到塔座C上，并仍按同样顺序叠置。在</p>
<p>移动圆盘时应遵守以下移动规则：</p>
<p>• 规则1：<font color=orange>每次只能移动1个圆盘</font>；</p>
<p>• 规则2：<font color=orange>任何时刻都不允许将较大的圆盘压在较小的圆盘之上</font>；</p>
<p>• 规则3：在满足移动规则1和2的前提下，可将圆盘移至A,B,C中任一塔座上。</p>
<p><strong>设计思路</strong>：</p>
<p>将n个圆盘从A-&gt;C，可以分解为3个步骤：</p>
<ul>
<li><p>(1) 将n-1个圆盘从A-&gt;B</p>
</li>
<li><p>(2) 将1个圆盘从A-&gt;C</p>
</li>
<li><p>(3) 将n-1个圆盘从B-&gt;C</p>
</li>
</ul>
<p>时间复杂度：<strong>T(n) &#x3D; O(2$^n$)</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 实现代码 </span></span><br><span class="line"></span><br><span class="line"><span class="comment">// n个圆盘Number ABC塔座String</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">hanoi</span>(<span class="params">n, A, B, C</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span>(n &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="title function_">hanoi</span>(n-<span class="number">1</span>, A, C, B);</span><br><span class="line">        <span class="title function_">move</span>(n, A, C);</span><br><span class="line">        <span class="title function_">hanoi</span>(n-<span class="number">1</span>, B, A, C);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">move</span>(<span class="params">n, a, c</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;move &#x27;</span> + n + <span class="string">&quot; from &quot;</span> + a + <span class="string">&#x27; to &#x27;</span> + c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>思考：四个柱子的汉诺塔问题？</p>
</blockquote>
<h2 id="算法——分治算法"><a href="#算法——分治算法" class="headerlink" title="算法——分治算法"></a>算法——分治算法</h2><p><strong>分治法的基本思想</strong>：</p>
<p>将一个难以直接解决的大问题，分割成一些规模较小的相同问题，以便各个击破，<strong>分</strong>而<strong>治</strong>之</p>
<ul>
<li><p>将待求解的较大规模的问题 <u>分割成k个更小规模的子问题</u></p>
</li>
<li><p>对这 <u>k个子问题分别求解</u></p>
</li>
<li><p>如果子问题的规模仍然不够小，则再划分为k个子问题，如此递归进行下去，直到问题规模足够小、很容易求出其解为止</p>
</li>
<li><p>将求出的小规模的问题的解合并为一个更大规模的问题的解，<font color=orange>自底向上</font>逐步求出原来问题的解</p>
</li>
</ul>
<p><strong>分治法的适用条件</strong>：</p>
<p>分治法所能解决的问题一般具有以下几个特征：</p>
<ul>
<li><ol>
<li>该问题的 <u>规模缩小到一定的程度就可以容易地解决</u></li>
</ol>
</li>
<li><ol start="2">
<li>该问题可以分解为若干个规模较小的相同问题，即该问题具有<strong>最优子结构</strong>性质</li>
</ol>
</li>
<li><ol start="3">
<li>利用该问题分解出的 <u>子问题的解可以合并为该问题的解</u>【如果具备了前两条特征，而不具备第三条特征，则可以考虑<strong>贪心算法或动态规划</strong>】</li>
</ol>
</li>
<li><ol start="4">
<li>该问题所分解出的 <u>各个子问题是相互独立的</u>，即子问题之间不包含公共的子问题【重复地解公共的子问题用<strong>动态规划</strong>较好】</li>
</ol>
</li>
</ul>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 典型实例</span></span><br><span class="line"></span><br><span class="line">二分查找</span><br><span class="line">归并排序</span><br><span class="line">快速排序</span><br><span class="line"></span><br><span class="line">线性时间选择</span><br><span class="line">棋盘覆盖</span><br><span class="line">大整数乘法</span><br><span class="line">Strassen矩阵乘法</span><br></pre></td></tr></table></figure>

<p>分治法的<strong>时间复杂度</strong>：</p>
<p> 一个分治法将规模为n的问题 <font color=orange>分成a个规模为n&#x2F;b的子问题去解</font></p>
<p> 设阀值n$_0$&#x3D;1，且<font color=orange>adhoc解（直接可以求解）</font>规模为1的问题耗费1个单位时间</p>
<p> 设将原问题分解为a个子问题以及用merge将a个子问题的解<strong>合并</strong>为原问题的解需用f(n)个单位时间</p>
<p> 用T(n)表示该分治法解规模为|P|&#x3D;n的问题所需的计算时间，则有：<br>$$<br>T(n)&#x3D;<br>\begin{cases}<br>O(1) &amp;\quad n&#x3D;1 \<br>aT(n&#x2F;b)+f(n) &amp;\quad n&gt;1<br>\end{cases}<br>$$</p>
<p>递推求解得：</p>
<p>当f(n)为常数时，即f(n)&#x3D;c<br>$$<br>T(n)&#x3D;<br>\begin{cases}<br>O(n^{log_b a}) &amp;\quad a≠1 \<br>O(log_bn)&amp;\quad a&#x3D;1<br>\end{cases}<br>$$</p>
<p>当f(n)&#x3D;cn，c为常数时<br>$$<br>T(n)&#x3D;<br>\begin{cases}<br>O(n) &amp;\quad a&lt;b \<br>O(log_bn)&amp;\quad a&#x3D;b\<br>O(n^{log_b a}) &amp;\quad a&gt;b<br>\end{cases}<br>$$</p>
<h3 id="二分查找O-logn"><a href="#二分查找O-logn" class="headerlink" title="*二分查找O(logn)"></a>*二分查找O(logn)</h3><p>**二分查找(Binary Search)**又称为折半查找，它是一种高效的查找方法，但是二分查找要求<font color=orange>待查找列表中的<u>元素是有序</u>的</font>，是典型的分治算法实例之一。</p>
<p><strong>设计思路</strong>：</p>
<p> 设A[low..high]为当前查找区间，首先 <font color=orange>确定区间的中点位置mid&#x3D;⌊(low + high)&#x2F;2⌋；然后将待查的key值与A[mid]进行比较</font></p>
<ul>
<li><ol>
<li>若key&#x3D;&#x3D;A[mid]，则查找成功并返回该元素的下标</li>
</ol>
</li>
<li><ol start="2">
<li>若key&lt;A[mid]，则查找左子表A[low..mid-1]</li>
</ol>
</li>
<li><ol start="3">
<li>若key&gt;A[mid]，则查找右子表A[mid+1..high]</li>
</ol>
</li>
</ul>
<p> <font color=orange>对新的查找区间重复上述查找过程</font>，直到找到关键字为key的元素为止，或者满足当前查找空间为空（即查找失败）</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 伪代码形式 </span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 1 非递归算法 BinarySearch(A[0...n-1], key)</span></span><br><span class="line"><span class="comment">//实现非递归的二分查找</span></span><br><span class="line"><span class="comment">//输入：一个升序数组A[0..n-1]和一个查找键key</span></span><br><span class="line"><span class="comment">//输出：一个数组元素的下标，该元素等于Key；如果没有找到，则返回-1</span></span><br><span class="line">low &lt;- <span class="number">0</span>, high -&gt; n-<span class="number">1</span></span><br><span class="line"><span class="keyword">while</span> low ≤ high</span><br><span class="line">	mid &lt;- ⌊(low + high)/<span class="number">2</span>⌋</span><br><span class="line">	<span class="keyword">if</span> key = A[mid] <span class="keyword">return</span> mid</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> key &lt; A[mid] high &lt;- mid - <span class="number">1</span></span><br><span class="line">	<span class="keyword">else</span> low &lt;- mid + <span class="number">1</span></span><br><span class="line"><span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2 递归算法 BinarySearch(A[0...n-1], key, low, high)</span></span><br><span class="line"><span class="comment">//实现递归的二分查找</span></span><br><span class="line"><span class="comment">//输入：一个升序数组A[0..n-1]和一个查找键key</span></span><br><span class="line"><span class="comment">//输出：一个数组元素的下标，该元素等于Key；如果没有找到，则返回-1</span></span><br><span class="line"><span class="keyword">if</span> low&gt;high <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">mid &lt;- ⌊(low + high)/<span class="number">2</span>⌋</span><br><span class="line"><span class="keyword">if</span> key = A[mid] <span class="keyword">return</span> mid</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> key &lt; A[mid] <span class="keyword">return</span> <span class="title class_">BinarySearch</span>(A, key, low, mid-<span class="number">1</span>)</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">return</span> <span class="title class_">BinarySearch</span>(A, key, mid+<span class="number">1</span>, high)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>二分查找的时间复杂度</strong>：T(n)&#x3D;O(logn)</p>
<p>每执行一次while循环或一次迭代，<u>待搜索数组的大小将减少一半</u>。因此，在最坏情况下，程序被执行了<strong>O(logn)</strong> 次，循环体或递归函数内运算需要O(1) 时间，因此整个算法在最坏情况下的时间复杂度为O(logn) 。</p>
<h3 id="归并排序O-nlogn"><a href="#归并排序O-nlogn" class="headerlink" title="*归并排序O(nlogn)"></a>*归并排序O(nlogn)</h3><p><strong>基本思想</strong>：</p>
<p>将两个或两个以上的有序子序列“<strong>归并</strong>(Merge)”为一个有序序列。</p>
<p>在内部排序中，通常采用的是<strong>二路归并排序</strong>。即：将两个位置相邻的有序子序列归并为一个有序序列。</p>
<p><strong>算法原理</strong>：</p>
<p>假设初始序列含有n个记录，则可看成n个有序的子序列，每个子序列长度为1。然后两两归并，得到 <strong>[n&#x2F;2]</strong> 个长度为2或1的有序子序列；再两两归并，……如此重复，直至得到一个长度为n的有序序列为止。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 二路归并 Merge</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">Merge</span> <span class="params">(<span class="type">int</span> SR[ ], <span class="type">int</span> TR[ ], <span class="type">int</span> s, <span class="type">int</span> m, <span class="type">int</span> t )</span></span><br><span class="line">&#123; <span class="comment">/***将有序列SR[s..m]和SR[m+1..t]两路归并为TR[ ]***/</span></span><br><span class="line">    <span class="type">int</span> i=s, j=m+<span class="number">1</span>, k=s;</span><br><span class="line">    <span class="keyword">while</span> (i&lt;=m &amp;&amp; j&lt;=t) &#123; <span class="comment">//两序列中元素逐个比较</span></span><br><span class="line">        <span class="keyword">if</span> (SR[i]&lt;=SR[j]) TR[k++]=SR[i++];</span><br><span class="line">        <span class="keyword">else</span> TR[k++]=SR[j++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (i&lt;=m) TR[k++]=SR[i++]; <span class="comment">//前一个子序列剩下的</span></span><br><span class="line">    <span class="keyword">while</span> (j&lt;=t) TR[k++]=SR[j++]; <span class="comment">//后一个子序列剩下的</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 归并排序 MergeSort</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">MergeSort</span><span class="params">(<span class="type">int</span> SR[], <span class="type">int</span> s, <span class="type">int</span> t )</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (s &lt; t) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> (s+t)/<span class="number">2</span>; <span class="comment">// 将SR[s..t]分割</span></span><br><span class="line">        MergeSort(SR, s, m); <span class="comment">// 递归地排序子序列SR[s..m]</span></span><br><span class="line">        MergeSort(SR, m+<span class="number">1</span>, t); <span class="comment">//递归地排序子序列SR[m+1..t]</span></span><br><span class="line">        Merge(SR, TR, s, m, t); <span class="comment">//归并</span></span><br><span class="line">        Copy(TR, SR, s, t); </span><br><span class="line">        <span class="comment">//将数组TR复制回数组SR =&gt; for(int i=s;i&lt;=t;i++) SR[i] = TR[i];</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>归并排序的时间复杂度</strong>：<strong>T(n)&#x3D;O(nlogn)</strong></p>
<p>一趟归并操作是将r[1]~r[n]中相邻的长度为<em>h</em>的有序序列进行两两归并，这需要<em>O</em>(<em>n</em>)时间。整个归并排序需要进行log$_2$<em>n</em>趟，因此，时间复杂度为<em>O</em>(<em>n</em>log$_2$<em>n</em>)。</p>
<p><strong>归并排序的空间复杂度</strong>：O(n)</p>
<p>算法在执行时，需要占用与原始记录序列同样数量的存储空间，因此，空间复杂度为O(n)</p>
<blockquote>
<p>思考：k路归并排序???</p>
</blockquote>
<h3 id="快速排序O-nlogn"><a href="#快速排序O-nlogn" class="headerlink" title="*快速排序O(nlogn)"></a>*快速排序O(nlogn)</h3><p><strong>基本思想</strong>：</p>
<p>通过一趟排序将 <u>要排序的数据分割为独立的两部分</u>，其中一部分的所有数据比另一部分的所有数据小，再按这种方法对两部分数据分别进行快速排序，<u>整个排序过程可以递归进行</u>，使整个数据变成有序序列。</p>
<p>快排的基本步骤：</p>
<ul>
<li>从数组中选择一个元素作为基准</li>
<li>排序数组：比基准值小的放左边，大的放右边，这样每一次分割结束后基准值会插入到中间</li>
<li>利用递归，将摆放在左边的数组和右边的数组重复上述操作</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 分区函数：Partition(A,p,q) A代表数组 p起始下标 q结束下标</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">quickSort</span>(<span class="params">A, p=<span class="number">0</span>, q</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span>(A.<span class="property">length</span> &lt;= <span class="number">1</span>) &#123; <span class="keyword">return</span> A &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(p &lt; q) &#123;</span><br><span class="line">        <span class="keyword">let</span> r = <span class="title function_">partition</span>(A, p, q);</span><br><span class="line">        <span class="title function_">quickSort</span>(A, p, r-<span class="number">1</span>);</span><br><span class="line">        <span class="title function_">quickSort</span>(A, r+<span class="number">1</span>, q);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> A;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">exchange</span>(<span class="params">A, i, j</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> t = A[i];</span><br><span class="line">    A[i] = A[j];</span><br><span class="line">    A[j] = t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">partition</span>(<span class="params">A, p, q</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> x = A[p];</span><br><span class="line">    <span class="keyword">let</span> i = p;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> j = p+<span class="number">1</span>; j &lt;= q; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(A[j] &lt;= x) &#123;</span><br><span class="line">            i++;</span><br><span class="line">            <span class="title function_">exchange</span>(A, i, j);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">exchange</span>(A, p, i);</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>快排不同情况下的算法复杂度</strong></p>
<p>(1) 最坏情况：O(n^2^)</p>
<p>(2) 最好情况 &#x2F; 一般情况 &#x2F; 好坏交替：O(nlogn)</p>
<p><strong>算法改进</strong>：&#x3D;&gt; 【<u>随机化快速排序</u>】T(n) &#x3D; <strong>O(nlogn)</strong></p>
<ul>
<li><p>通过修改算法partition，可以设计出采用<strong>随机选择策略</strong>的快速排序算法</p>
</li>
<li><p>在A[p..q]中<font color=orange>随机选出一个元素作为划分基准</font></p>
</li>
<li><p>可以使划分基准的选择是随机的，从而可以期望划分是较对称的</p>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// RandomizedPartition (A, p , q) </span></span><br><span class="line"></span><br><span class="line">r &lt;- <span class="title function_">random</span>(p,q) <span class="comment">// [p,q]之间的随机数</span></span><br><span class="line">A[r] &lt;--&gt; A[p] <span class="comment">//随机值与第一个交换</span></span><br><span class="line">i &lt;- <span class="title class_">Partition</span>(A, p, q) </span><br><span class="line"><span class="keyword">return</span> i</span><br></pre></td></tr></table></figure>



<h3 id="线性时间选择O-n"><a href="#线性时间选择O-n" class="headerlink" title="线性时间选择O(n)"></a>线性时间选择O(n)</h3><p>问题：给定线性序集中<strong>n个元素</strong>和一个<strong>整数k</strong>，1≤k≤n，要求找<strong>出这n个元素中第k小（或第k大）的元素</strong></p>
<p>例如：2, 5, 6, 1, 8, 7, 9，请找出<strong>第2小</strong>的元素</p>
<p>排序后查找，T(n)&#x3D;O(nlogn)，能不能不排序？？？</p>
<p>• 快速排序的分区思想</p>
<p>• 统计比基准元素（例如以第1个为基准）小的元素个数，如果个数大于等于k，则第k最小元素在前半部分，否则在后半部分</p>
<p><strong>算法设计</strong>：</p>
<p>对于无序序列a[s..t]，在其中查找第k小的元素的过程：</p>
<p>• 若s&#x3D;t，即其中只有一个元素，返回a[s]</p>
<p>• 若s!&#x3D;t，表示该序列中有两个或两个以上元素，以基准为中心将其划分为a[s..i]和a[i+1..t]，<strong>a[s..i]中所有元素均小于等于a[i]，a[i+1..t]中所有元素均大于a[i]</strong></p>
<ul>
<li>j &#x3D; i-s+1，统计小于等于a[i]的元素个数</li>
<li>j&gt;&#x3D;k，第k小元素在a[s..i]中，递归在a[s..i]中寻找第k小元素</li>
<li>j &lt; k，第k小元素在a[i+1..t]中，递归在a[i+1..t]中寻找第k-j小元素</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="D:\PersonalData\Mango\NEW\Blog\Hexo-blog\blog-mango\source\images\article\算法\线性时间选择算法设计.png" alt="image-20230315170056006"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 线性时间选择的算法实现</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">quickSelect</span><span class="params">(<span class="type">int</span> a[], <span class="type">int</span> s, <span class="type">int</span> t, <span class="type">int</span> k)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (s==t) <span class="keyword">return</span> a[s];</span><br><span class="line">    <span class="type">int</span> i= partition(s,t),</span><br><span class="line">        j=i-s+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (k&lt;=j) <span class="keyword">return</span> quickSelect(a, s, i, k);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> quickSelect(a, i+<span class="number">1</span>, t, k-j); </span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 改进</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">randomizedSelect</span><span class="params">(<span class="type">int</span> a[], <span class="type">int</span> s, <span class="type">int</span> t, <span class="type">int</span> k)</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (s==t) <span class="keyword">return</span> a[s];</span><br><span class="line">    <span class="type">int</span> i=randomizedpartition(s,t),</span><br><span class="line">        j=i-s+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (k&lt;=j) <span class="keyword">return</span> randomizedSelect(a, s, i, k);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> randomizedSelect(a, i+<span class="number">1</span>, r, k-j);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="棋盘覆盖"><a href="#棋盘覆盖" class="headerlink" title="棋盘覆盖"></a>棋盘覆盖</h3><p>问题：</p>
<p>在一个2$^k$×2$^k$ 个方格组成的棋盘中，恰有一个方格与其他方格不同，称该方格为一特殊方格，且称该棋盘为一特殊棋盘。在棋盘覆盖问题中，要用以下4种不同形态的L型骨牌 <font color=orange>覆盖给定的特殊棋盘上除特殊方格以外的所有方格，且任何2个L型骨牌不得重叠覆盖</font>。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="D:\PersonalData\Mango\NEW\Blog\Hexo-blog\blog-mango\source\images\article\算法\棋盘覆盖骨牌.png" alt="image-20230315170846608"></p>
<p><strong>问题分析</strong>：</p>
<ul>
<li><p>当k&gt;0时，将2$^k$×2$^k$棋盘分割为4个2$^{k-1}$× 2$^{k-1}$子棋盘(a)所示</p>
</li>
<li><p>特殊方格必位于4个较小子棋盘之一中，其余3个子棋盘中无特殊方格，为了将这3个无特殊方格的子棋盘转化为特殊棋盘，<font color=orange>可以用一个L型骨牌覆盖这3个较小棋盘的会合处</font>，如 (b)所示</p>
</li>
<li><ul>
<li>将原问题转化为4个较小规模的棋盘覆盖问题</li>
</ul>
</li>
<li><ul>
<li>递归地使用这种分割，直至棋盘简化为棋盘1×1</li>
</ul>
</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="D:\PersonalData\Mango\NEW\Blog\Hexo-blog\blog-mango\source\images\article\算法\棋盘覆盖问题分析.png" alt="image-20230315171340222"></p>
<p><strong>算法设计</strong>：</p>
<ul>
<li><p>(1) 每次对分割后的四个小方块进行判断，判断特殊方格是否在其中</p>
</li>
<li><p>(2) 判断的方法是每次先记录下整个大方块的左上角方格的行列坐标，然后再与特殊方格坐标进行比较，就可以知道特殊方格是否在该块中</p>
</li>
<li><ul>
<li>如果特殊方块在其中，继续递归即可</li>
</ul>
</li>
<li><ul>
<li>如果不在，则根据分割的四个方块的不同位置，把右下角、左下角、右上角或者左上角的方格标记为特殊方块，然后继续递归</li>
</ul>
</li>
<li><p>在递归函数中，需要有一个变量s来记录边的方格数，每次对方块进行划分时，边的方格数都会减半，这个变量是为了方便判断特殊方格的位置</p>
</li>
</ul>
<p><strong>复杂度分析</strong>：<br>$$<br>T(k)&#x3D;<br>\begin{cases}<br>O(1) &amp; k&#x3D;0 \<br>4T(k-1)+O(1) &amp; k&gt;0<br>\end{cases}</p>
<p>\<br>\<br>T(n)&#x3D;O(4^k) 渐进意义下的最优算法<br>$$</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 棋盘覆盖算法实现</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">chessBoard</span><span class="params">(<span class="type">int</span> tr, <span class="type">int</span> tc, <span class="type">int</span> dr, <span class="type">int</span> dc, <span class="type">int</span> size)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (size == <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="type">int</span> t = tile++, <span class="comment">// L型骨牌号</span></span><br><span class="line">        s = size/<span class="number">2</span>; <span class="comment">// 分割棋盘</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 覆盖左上角子棋盘</span></span><br><span class="line">    <span class="keyword">if</span> (dr &lt; tr + s &amp;&amp; dc &lt; tc + s)</span><br><span class="line">        <span class="comment">// 特殊方格在此棋盘中</span></span><br><span class="line">        chessBoard(tr, tc, dr, dc, s);</span><br><span class="line">    <span class="keyword">else</span> &#123;<span class="comment">// 此棋盘中无特殊方格</span></span><br><span class="line">        <span class="comment">// 用 t 号L型骨牌覆盖右下角</span></span><br><span class="line">        board[tr + s - <span class="number">1</span>][tc + s - <span class="number">1</span>] = t;</span><br><span class="line">        <span class="comment">// 覆盖其余方格</span></span><br><span class="line">        chessBoard(tr, tc, tr+s<span class="number">-1</span>, tc+s<span class="number">-1</span>, s);&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 覆盖右上角子棋盘</span></span><br><span class="line">    <span class="keyword">if</span> (dr &lt; tr + s &amp;&amp; dc &gt;= tc + s)</span><br><span class="line">        <span class="comment">// 特殊方格在此棋盘中</span></span><br><span class="line">        chessBoard(tr, tc+s, dr, dc, s);</span><br><span class="line">    <span class="keyword">else</span> &#123;<span class="comment">// 此棋盘中无特殊方格</span></span><br><span class="line">        <span class="comment">// 用 t 号L型骨牌覆盖左下角</span></span><br><span class="line">        board[tr + s - <span class="number">1</span>][tc + s] = t;</span><br><span class="line">        <span class="comment">// 覆盖其余方格</span></span><br><span class="line">        chessBoard(tr, tc+s, tr+s<span class="number">-1</span>, tc+s, s);&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 覆盖左下角子棋盘</span></span><br><span class="line">    <span class="keyword">if</span> (dr &gt;= tr + s &amp;&amp; dc &lt; tc + s)</span><br><span class="line">        <span class="comment">// 特殊方格在此棋盘中</span></span><br><span class="line">        chessBoard(tr+s, tc, dr, dc, s);</span><br><span class="line">    <span class="keyword">else</span> &#123;<span class="comment">// 用 t 号L型骨牌覆盖右上角</span></span><br><span class="line">        board[tr + s][tc + s - <span class="number">1</span>] = t;</span><br><span class="line">        <span class="comment">// 覆盖其余方格</span></span><br><span class="line">        chessBoard(tr+s, tc, tr+s, tc+s<span class="number">-1</span>, s);&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 覆盖右下角子棋盘</span></span><br><span class="line">    <span class="keyword">if</span> (dr &gt;= tr + s &amp;&amp; dc &gt;= tc + s)</span><br><span class="line">        <span class="comment">// 特殊方格在此棋盘中</span></span><br><span class="line">        chessBoard(tr+s, tc+s, dr, dc, s);</span><br><span class="line">    <span class="keyword">else</span> &#123;<span class="comment">// 用 t 号L型骨牌覆盖左上角</span></span><br><span class="line">        board[tr + s][tc + s] = t;</span><br><span class="line">        <span class="comment">// 覆盖其余方格</span></span><br><span class="line">        chessBoard(tr+s, tc+s, tr+s, tc+s, s);&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="大整数乘法"><a href="#大整数乘法" class="headerlink" title="大整数乘法"></a>大整数乘法</h3><p>问题：请设计一个有效的算法，可以进行两个n位大整数的乘法运算</p>
<h3 id="Strassen矩阵乘法"><a href="#Strassen矩阵乘法" class="headerlink" title="Strassen矩阵乘法"></a><strong>Strassen矩阵乘法</strong></h3><h2 id="算法——动态规划【最优子结构-重叠子问题】"><a href="#算法——动态规划【最优子结构-重叠子问题】" class="headerlink" title="算法——动态规划【最优子结构+重叠子问题】"></a>算法——动态规划【最优子结构+重叠子问题】</h2><h3 id="数字三角形"><a href="#数字三角形" class="headerlink" title="数字三角形"></a><strong>数字三角形</strong></h3><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="D:\PersonalData\Mango\NEW\Blog\Hexo-blog\blog-mango\source\images\article\算法\dp-小兔子的难题.png" alt="image-20230315172851434" style="zoom:80%;" />

<p><strong>经典递归解法</strong> <strong>T(n) &#x3D; O(2$^n$)</strong></p>
<ul>
<li><p>计算从第一层到最后一层的所有路径和，然后取最大值</p>
</li>
<li><p>二叉树，从顶点到第二层有2条路径，到第三层有4条路径，到第四层有8条路径，到第五层有16条路径，……</p>
</li>
<li><p>从顶点到最后一层一共有<strong>2$^{n-1}$条路径</strong></p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a[<span class="number">110</span>][<span class="number">110</span>],n;</span><br><span class="line"><span class="type">int</span> <span class="title function_">solve</span><span class="params">(<span class="type">int</span> i,<span class="type">int</span> j)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(i==n+<span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> a[i][j]+max(solve(i+<span class="number">1</span>,j),solve(i+<span class="number">1</span>,j+<span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line">……</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,solve(<span class="number">1</span>,<span class="number">1</span>)); <span class="comment">//(1,1)到最后一层的最大路径和</span></span><br></pre></td></tr></table></figure>

<p><strong>记忆化搜索(备忘录法)</strong></p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="D:\PersonalData\Mango\NEW\Blog\Hexo-blog\blog-mango\source\images\article\算法\dp-数字三角形备忘录.png" alt="image-20230315173649153" style="zoom:70%;" />

<ul>
<li>设(i, j)到达最后一层的最大路径和为p[i][j]【很多人将其取名为**dp[i][j]**】</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> p[<span class="number">105</span>][<span class="number">105</span>],a[<span class="number">105</span>][<span class="number">105</span>],n;</span><br><span class="line"><span class="type">int</span> <span class="title function_">solve</span><span class="params">(<span class="type">int</span> i,<span class="type">int</span> j)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(p[i][j]&gt;=<span class="number">0</span>) <span class="keyword">return</span> p[i][j]; <span class="comment">//引入备忘录保存子问题的解</span></span><br><span class="line">    <span class="keyword">if</span>(i==n+<span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> p[i][j]=a[i][j]+max(solve(i+<span class="number">1</span>,j),solve(i+<span class="number">1</span>,j+<span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line">……</span><br><span class="line"><span class="built_in">memset</span>(p,<span class="number">-1</span>,<span class="keyword">sizeof</span>(p)); <span class="comment">//初始化备忘录</span></span><br><span class="line">solve(<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line"><span class="built_in">printf</span>(“%d\n”,p[<span class="number">1</span>][<span class="number">1</span>]); <span class="comment">//p[1][1]即为所求解</span></span><br></pre></td></tr></table></figure>

<p><strong>动态规划法</strong></p>
<p><strong>思路一</strong>：<strong>T(n) &#x3D; O(n$^2$)</strong></p>
<p>p[i][j]表示(i, j)的达到最后一层的最大路径和，那么p[i][j]的最优解包含了子问题p[i+1][j]或p[i+1][j+1]的最优解</p>
<p>状态转移方程（递归方程）：<br>$$<br>p[i][j]&#x3D;<br>\begin{cases}<br>a[i][j] &amp; i&#x3D;n \<br>max{  p[i+1][j],p[i+1][j+1]} + a[i][j] &amp; 1\leq i&lt;n<br>\end{cases}</p>
<p>\<br>result &#x3D; p[1][1]<br>$$<br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="D:\PersonalData\Mango\NEW\Blog\Hexo-blog\blog-mango\source\images\article\算法\dp-数字三角形动态规划法1.png" alt="image-20230315175020780" style="zoom:80%;" /></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> p[<span class="number">105</span>][<span class="number">105</span>],a[<span class="number">105</span>][<span class="number">105</span>],n;</span><br><span class="line"><span class="type">int</span> <span class="title function_">solve</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++) p[n][j]=a[n][j];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=n<span class="number">-1</span>;i&gt;=<span class="number">1</span>;i--) <span class="comment">//自底向上DP</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=i;j++)<span class="comment">//对行遍历</span></span><br><span class="line">            p[i][j]=a[i][j]+max(p[i+<span class="number">1</span>][j],p[i+<span class="number">1</span>][j+<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line">……</span><br><span class="line">solve();</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,p[<span class="number">1</span>][<span class="number">1</span>]);</span><br></pre></td></tr></table></figure>

<p><strong>思路二</strong>：</p>
<p>p[i][j]表示从(1,1)到达(i, j) 的最大路径和，那么p[i][j]的最优解包含了子问题p[i-1][j-1]或p[i-1][j]的最优解</p>
<p>状态转移方程（递归方程）：<br>$$<br>p[i][j]&#x3D;<br>\begin{cases}<br>a[1][1] &amp; i&#x3D;1 \<br>max{  p[i-1][j-1],p[i-1][j]} + a[i][j] &amp; 1&lt; i\leq n<br>\end{cases}</p>
<p>\<br>result &#x3D; max {p[n][j]}<br>$$<br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="D:\PersonalData\Mango\NEW\Blog\Hexo-blog\blog-mango\source\images\article\算法\dp-数字三角形动态规划法2.png" alt="image-20230315175607613" style="zoom:80%;" /></p>
<hr>
<p>&#x3D;&#x3D;动态规划（Dynamic Programming, DP）&#x3D;&#x3D;</p>
<p><strong>总体思想</strong></p>
<ul>
<li><p>动态规划算法与分治法类似，其基本思想也是 <strong>将待求解问题分解成若干个子问题</strong></p>
</li>
<li><p>经分解得到的<strong>子问题往往不是互相独立</strong>的，有些子问题被重复计算多次</p>
</li>
<li><p>如果能够<strong>保存已解决的子问题的答案</strong>，而在需要时再找出已求得的答案，就可以<u>避免大量重复计算</u>，从而得到<u>多项式时间算法</u></p>
</li>
</ul>
<p><strong>基本步骤</strong>：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="D:\PersonalData\Mango\NEW\Blog\Hexo-blog\blog-mango\source\images\article\算法\dp-基本步骤.png" alt="image-20230315180351822"></p>
<p><strong>基本要素</strong>：</p>
<table>
<thead>
<tr>
<th>最优子结构</th>
<th>重叠子问题</th>
</tr>
</thead>
<tbody><tr>
<td>一个问题的最优解包含着其子问题的最优解，这种性质称为<font color=orange>最优子结构性质</font></td>
<td>递归算法求解问题时，每次产生的子问题并不总是新问题，有些子问题被反复计算多次，这种性质称为<font color=orange>子问题的重叠性质</font></td>
</tr>
<tr>
<td>分析问题的最优子结构性质：首先<font color=orange>假设由问题的最优解导出的子问题的解不是最优的，然后再设法说明在这个假设下可构造出比原问题最优解更好的解，从而导致矛盾</font></td>
<td>动态规划算法，对每一个子问题只解一次，而后<font color=orange>将其解保存在一个表格中</font>，当再次需要解此子问题时，只是简单地<font color=orange>用常数时间查看一下结果</font></td>
</tr>
<tr>
<td>利用问题的最优子结构性质，以<strong>自底向上</strong>的方式递归地从子问题的最优解逐步构造出整个问题的最优解</td>
<td>通常不同的子问题个数随问题的大小呈多项式增长，用动态规划算法只需要多项式时间，从而获得较高的解题效率</td>
</tr>
<tr>
<td>最优子结构是一个问题能用动态规划算法求解的前提</td>
<td></td>
</tr>
</tbody></table>
<p><strong>备忘录法</strong>：</p>
<ul>
<li><p>记忆化搜索</p>
</li>
<li><p>备忘录方法的控制结构与直接递归方法的控制结构相同</p>
</li>
<li><p>区别在于备忘录方法为每个解过的子问题建立了备忘录以备需要时查看，避免相同子问题的重复求解</p>
</li>
<li><p>查表法</p>
</li>
</ul>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="D:\PersonalData\Mango\NEW\Blog\Hexo-blog\blog-mango\source\images\article\算法\dp-递归问题整体结构.png" alt="image-20230315181036987" style="zoom: 67%;" />

<h3 id="矩阵连乘O-n-3"><a href="#矩阵连乘O-n-3" class="headerlink" title="矩阵连乘O(n$^3$)"></a>矩阵连乘O(n$^3$)</h3><p><strong>完全加括号的矩阵连乘积</strong>：</p>
<p>完全加括号的矩阵连乘积可递归地定义为：</p>
<p>• <font color=orange>单个矩阵是完全加括号的</font></p>
<p>• 矩阵连乘积A是完全加括号的，则<font color=orange>A可表示为2个完全加括号的矩阵连乘积B和C的乘积并加括号，即A&#x3D;(BC)</font></p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="D:\PersonalData\Mango\NEW\Blog\Hexo-blog\blog-mango\source\images\article\算法\dp-矩阵连乘-完全加括号的矩阵连乘积.png" alt="image-20230316015248789" style="zoom: 80%;" />

<blockquote>
<p>矩阵A和B可乘的条件： 矩阵A的列数等于矩阵B的行数。</p>
<p>设A是<strong>p×q</strong>的矩阵, B是<strong>q×r</strong>的矩阵, 乘积是<strong>p×r</strong>的矩阵;计算量是 <strong>pqr</strong>。</p>
<p>完全加括号方式的计算工作量的计算【以(A((BC)D))为例】:<br>(A((BC)D))可拆解为下面的步骤来计算工作量<br>BC: 10×40×30 &#x3D; 12000,<br>(BC)D: 10×30×5 &#x3D; 1500,<br>(A((BC)D)): 50×10×5 &#x3D; 2500  &#x3D;&gt; 12000 + 1500 + 2500 &#x3D; 16000</p>
</blockquote>
<p><strong>矩阵连乘问题</strong></p>
<p>给定n个矩阵{A$_1$,A$_2$,…,A$_n$} ，其中A$<em>i$与A$</em>{i+1}$是可乘的，i&#x3D;1,2,…,n-1，考察n个矩阵的连乘积 A$_1$A$_2$…A$_n$，如何确定计算矩阵连乘积的计算次序，使得依此次序计算矩阵连乘积 <font color=orange>需要的数乘次数最少</font></p>
<ul>
<li><p><font color=orange>矩阵乘法满足结合律</font>-&gt;计算矩阵的连乘可以有许多不同的计算次序-&gt;计算次序可以用<u>加括号的方式</u>来确定</p>
</li>
<li><p>若一个矩阵连乘积的计算次序完全确定（该连乘积已完全加括号）-&gt;可依此次序<font color=orange>反复调用2个矩阵相乘的标准算法</font>计算出矩阵连乘积</p>
</li>
</ul>
<p>&#x3D;&#x3D;穷举法&#x3D;&#x3D;</p>
<p>列举出所有可能的计算次序，并计算出每一种计算次序相应需要的数乘次数，从中找出一种数乘次数最少的计算次序</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="D:\PersonalData\Mango\NEW\Blog\Hexo-blog\blog-mango\source\images\article\算法\dp-矩阵连乘-穷举.png" alt="image-20230316015628342"></p>
<p>&#x3D;&#x3D;动态规划法&#x3D;&#x3D;</p>
<p>将矩阵连乘积 A$<em>i$A$</em>{i+1}$…A$_j$ 简记为<strong>A[i:j]</strong> ，i≤j</p>
<p>考察计算A[i:j]的最优计算次序：设这个计算次序在矩阵A$<em>k$和A$</em>{k+1}$之间将矩阵链断开，i≤k&lt;j，则其相应完全加括号方式为 <strong>(A$<em>i$A$</em>{i+1}$…A$<em>k$ )(A$</em>{k+1}$A$_{k+2}$…A$_j$)</strong></p>
<p><u>计算量</u>：<strong>A[i:k]的计算量</strong>加上<strong>A[k+1:j]的计算量</strong>，再加上<strong>A[i:k]和A[k+1:j]相乘的计算量</strong>（三部分组成）</p>
<p><u>分析最优解的结构</u></p>
<p>• 特征：计算A[i:j]的最优次序所 <u>包含的计算矩阵子链 A[i:k]和A[k+1:j]的次序也是最优的</u></p>
<p>• 矩阵连乘计算次序问题的最优解包含着其子问题的最优解 -&gt; <font color=grgreen>最优子结构</font></p>
<p>• 问题的最优子结构性质是该问题可用动态规划算法求解的显著特征</p>
<p>**<u>建立递归关系</u>**：</p>
<p>• 计算A[i:j]，1≤i≤j≤n，<font color=orange>所需要的最少数乘次数m[i,j]</font>，则原问题的最优值为m[1,n] </p>
<p>• 当i&#x3D;j时，A[i:j]&#x3D;A$_i$ ，因此，m[i,i]&#x3D;0，i&#x3D;1,2,…,n</p>
<p>• 当i&lt;j时，<br>$$<br>m[i,j]&#x3D; m[i,k] + m[k+1,j] + p_{i-1}p_kp_j<br>$$<br>• A$<em>i$ 的维数为 p$</em>{i-1}$ × p$_k$    <strong>k的位置只有j-1种可能</strong></p>
<p>• 可以递归地定义m[i,j]为：<br>$$<br>m[i][j]&#x3D;<br>\begin{cases}<br>0 &amp; i&#x3D;j \<br>min { m[i,k]+m[k+1,j]+p_{i-1}p_kp_j } &amp; i&lt;j; {i \leq k&lt;j}<br>\end{cases}<br>$$<br><strong>计算最优值</strong>：</p>
<p>• 对于1≤i≤j≤n不同的有序对(i,j)对应于不同的子问题。不同子问题的个数最多只有：<br>$$<br>\left(<br>\begin{matrix}<br>2\<br>n\<br>\end{matrix}<br>\right)<br>+n&#x3D;\Theta(n^2)<br>$$<br>• 在递归计算时，许多子问题被重复计算多次 -&gt; <font color=grgreen>重叠子问题</font></p>
<p>• 用动态规划算法解此问题，可依据其递归式以 <strong>自底向上</strong> 的方式进行计算</p>
<p>• 在计算过程中，<strong>保存已解决的子问题答案</strong></p>
<p>• 每个子问题只计算一次，而在后面需要时只要简单查一下，从而避免大量的重复计算，最终得到多项式时间的算法</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="D:\PersonalData\Mango\NEW\Blog\Hexo-blog\blog-mango\source\images\article\算法\dp-矩阵连乘-求最优解.png" alt="image-20230316022511310" style="zoom:80%;" />

<p><strong>算法复杂度</strong>分析：</p>
<p>主要计算量取决于算法中对r，i和k的3重循环。循环体内的计算量为O(1)，而3重循环的总次数为O(n$^3$)。因</p>
<p>此<strong>算法的计算时间上界为O(n$^3$)。算法所占用的空间显然为O(n$^2$)。</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">matrixChain</span><span class="params">(<span class="type">int</span> [] p, <span class="type">int</span> [][] m, <span class="type">int</span> [][] s)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> n=p.length-<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n; i++) m[i][i] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> <span class="number">2</span>; r &lt;= n; r++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n - r+<span class="number">1</span>; i++) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> j=i+r-<span class="number">1</span>;</span><br><span class="line">            m[i][j] = m[i+<span class="number">1</span>][j]+ p[i-<span class="number">1</span>]*p[i]*p[j];</span><br><span class="line">            s[i][j] = i;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> i+<span class="number">1</span>; k &lt; j; k++) </span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">t</span> <span class="operator">=</span> m[i][k] + m[k+<span class="number">1</span>][j] + p[i-<span class="number">1</span>]*p[k]*p[j];</span><br><span class="line">                <span class="keyword">if</span> (t &lt; m[i][j]) </span><br><span class="line">                &#123;</span><br><span class="line">                    m[i][j] = t;</span><br><span class="line">                    s[i][j] = k; &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>构造最优解</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//回溯构造最优解</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">traceback</span><span class="params">(<span class="type">int</span> [][] s, <span class="type">int</span> i, <span class="type">int</span> j)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(i==j) <span class="keyword">return</span>;</span><br><span class="line">    traceback(s, i, s[i][j]);</span><br><span class="line">    traceback(s, s[i][j]+<span class="number">1</span>, j);</span><br><span class="line">    System.out.println(“Multiply A” + i + “,“ + s[i][j] + “ and A “ + (s[i][j]</span><br><span class="line">+ <span class="number">1</span>) + “,“ + j);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 备忘录法</span></span><br><span class="line">m&lt;-<span class="number">0</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">lookupChain</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (m[i][j] &gt; <span class="number">0</span>) <span class="keyword">return</span> m[i][j];</span><br><span class="line">    <span class="keyword">if</span> (i == j) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">u</span> <span class="operator">=</span> lookupChain(i+<span class="number">1</span>,j) + p[i-<span class="number">1</span>]*p[i]*p[j];</span><br><span class="line">    s[i][j] = i;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> i+<span class="number">1</span>; k &lt; j; k++) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">t</span> <span class="operator">=</span> lookupChain(i,k) + lookupChain(k+<span class="number">1</span>,j) + p[i-<span class="number">1</span>]*p[k]*p[j];</span><br><span class="line">        <span class="keyword">if</span> (t &lt; u) &#123; u = t; s[i][j] = k; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    m[i][j] = u;</span><br><span class="line">    <span class="keyword">return</span> u;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>







<h3 id="LCS最长公共子序列O-mn"><a href="#LCS最长公共子序列O-mn" class="headerlink" title="LCS最长公共子序列O(mn)"></a>LCS最长公共子序列O(mn)</h3><p><strong>基本定义</strong>：</p>
<p>一个给定序列的 <u>子序列</u> 是在该序列中删去若干元素后得到的序列</p>
<p>给定2个序列X和Y，当另一序列Z既是X的子序列又是Y的子序列时，称Z是序列X和Y的 <strong>公共子序列</strong></p>
<p>公共子序列中长度最长的公共子序列叫做<strong>最长公共子序列</strong></p>
<p>最长公共子序列(Longest Common Subsequence, <code>LCS</code>)问题可以叙述为：</p>
<p>• 给定2个序列X&#x3D;{x$_1$，…，x$_m$}和Y&#x3D;{y$_1$，…，y$_n$}，要求找出X和Y的一个最长公共子序列</p>
<p><strong>算法详解</strong>：</p>
<p>&#x3D;&#x3D;穷举搜索&#x3D;&#x3D; T(n)&#x3D;O(n$\bullet$2$^m$)</p>
<p> 对X的每一个子序列，检查它是否也是Y的子序列，即是否为X和Y的公共子序列</p>
<p> 在检查过程中遴选出最长的公共子序列</p>
<p> X的所有子序列都检查过后即可求出X和Y的最长公共子序列</p>
<p> X的一个子序列相应于下标序列{1，2，…，m}的一个子序列，故X共有<strong>2$^m$个</strong>不同子序列</p>
<p> 穷举搜索法需要<u>指数时间</u></p>
<p>&#x3D;&#x3D;动态规划&#x3D;&#x3D;</p>
<p><strong>状态表示</strong>：<font color=grblue>用C[i,j]记录序列X(i)和Y(j)的最长公共子序列的长度</font>，其中X(i)&#x3D;{x$_1$，…，x$_i$ }, Y(j)&#x3D;{y$_1$，…，y$_j$ }。<font color=grblue>原问题最优解的长度为C[m,n]</font>。</p>
<p><strong>最优子结构性质</strong>：设序列X&#x3D;{x$_1$，…，x$_m$}和Y&#x3D;{y$_1$，…，y$_n$}的一个最长公共子序列为Z&#x3D;{z$_1$，…，z$_k$}，则下述结论成立：</p>
<p>• (1) 若<font color=grblue>x$_m$ &#x3D; y$_n$</font>，则z$_k$ &#x3D; x$_m$ &#x3D; y$_n$ 且Z(k-1) &#x3D; {z$<em>1$，…，z$</em>{k-1}$}是X(m-1)和Y(n-1)的最长公共子序列</p>
<p>• (2) 若<font color=grblue>x$_m$  ≠ y$_n$ 且 z$_k$ ≠ x$_m$</font>，则Z是X(m-1)和Y的最长公共子序列</p>
<p>• (3) 若<font color=grblue>x$_m$  ≠ y$_n$ 且 z$_k$ ≠ y$_n$</font>，则Z是X和Y(n-1)的最长公共子序列</p>
<p><strong>结论</strong>：</p>
<ul>
<li><p><font color=blue>2个序列的最长公共子序列包含了这2个序列前缀的最长公共子序列</font></p>
</li>
<li><p>最长公共子序列问题具有 <strong><u>最优子结构性质</u></strong></p>
</li>
</ul>
<p>由最长公共子序列问题的最优子结构性质可知，要找出X&#x3D;{x$_1$，…，x$_m$}和Y&#x3D;{y$_1$，…，y$_n$}的一个最长公共子序列，可按以下方式递归地进行：</p>
<p>• 当 <strong>x$_m$ &#x3D; y$_n$</strong> 时，找出<strong>X(m-1)和Y(n-1)的最长公共子序列</strong>，然后在其**尾部加上x$_m$(&#x3D;y$_n$)**即可得X和Y的一个最长公共子序列</p>
<p>• 当 <strong>x$_m$ ≠ y$_n$</strong> 时，必须解2个子问题，即找出<strong>X(m-1)和Y的一个最长公共子序列</strong>及<strong>X和Y(n-1)的一个最长公共子序列</strong>。这2个公共子序列中较长者即为X和Y的一个最长公共子序列</p>
<p><strong>建立子问题的最优值C[i, j]的递归关系</strong>，递归方程如下： </p>
<p>由此递归方程容易看到最长公共子序列问题具有 <strong><u>重叠子问题性质</u></strong><br>$$<br>c[i][j]&#x3D;<br>\begin{cases}<br>0 &amp; i&#x3D;0,j&#x3D;0 \<br>c[i-1][j-1]+1 &amp; i,j&gt;0;x_i&#x3D;y_j \<br>max{c[i][j-1],c[i-1][j]} &amp; i,j&gt;0;x_i\neq y_j<br>\end{cases}<br>$$</p>
<p><strong>递归实现 【不考虑重叠子问题】</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">LCS(x, y, i, j)</span><br><span class="line">	<span class="keyword">if</span> x[i] = y[j]</span><br><span class="line">		then c[i, j] &lt;- LCS(x, y, i<span class="number">-1</span>, j<span class="number">-1</span>) + <span class="number">1</span></span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		c[i, j] &lt;- max&#123;LCS(x, y, i<span class="number">-1</span>, j), LCS(x, y, i, j<span class="number">-1</span>)&#125;</span><br><span class="line">	<span class="keyword">return</span> c[i, j]</span><br></pre></td></tr></table></figure>

<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="D:\PersonalData\Mango\NEW\Blog\Hexo-blog\blog-mango\source\images\article\算法\dp-最长公共子序列递归树.png" alt="image-20230315224732653" style="zoom:80%;" />

<p><strong>备忘录法</strong>【增加一个判断语句，自顶向下】<strong>T(n) &#x3D; O(m*n)</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">LCS(x, y, i, j)</span><br><span class="line">	<span class="keyword">if</span> c[i, j] = null</span><br><span class="line">		then <span class="keyword">if</span> x[i] = y[j]</span><br><span class="line">			then c[i, j] &lt;- LCS(x, y, i<span class="number">-1</span>, j<span class="number">-1</span>) + <span class="number">1</span></span><br><span class="line">			<span class="keyword">else</span> c[i, j] &lt;- max&#123;LCS(x, y, i<span class="number">-1</span>, j), LCS(x, y, i, j<span class="number">-1</span>)&#125;</span><br><span class="line">	<span class="keyword">return</span> c[i, j]</span><br></pre></td></tr></table></figure>

<p><strong>动态规划法</strong>【自底向上】<strong>T(n) &#x3D; O(m*n)</strong></p>
<p>根据上面的递归方程绘制表格（制表法）如下：</p>
<p>逐个排查，自上而下填表，当末尾字母相同即x$_i$&#x3D;y$_j$ 时，填入c[i-1][j-1]+1结果，即斜对角结果+1；当末尾字母不同时，则选择左侧和顶部结果最大的那一个，依次填入即可绘制全表。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="D:\PersonalData\Mango\NEW\Blog\Hexo-blog\blog-mango\source\images\article\算法\dp-最长公共子序列制表.png" alt="image-20230315233216549"></p>
<p> <strong>T(n) &#x3D; O(m*n)</strong>  <strong>S(n) &#x3D; O(m*n)</strong></p>
<ul>
<li>计算最优值</li>
<li>构造最优解</li>
<li>构造最长公共子序列</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">Algorithm <span class="title function_">lcsLength</span><span class="params">(x,y,b)</span></span><br><span class="line">m&lt;-x.length-<span class="number">1</span>;</span><br><span class="line">n&lt;-y.length-<span class="number">1</span>;</span><br><span class="line">c[i][<span class="number">0</span>]=<span class="number">0</span>; c[<span class="number">0</span>][i]=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= n; j++) </span><br><span class="line">		<span class="keyword">if</span> (x[i]==y[j]) </span><br><span class="line">			c[i][j]=c[i-<span class="number">1</span>][j-<span class="number">1</span>]+<span class="number">1</span>;</span><br><span class="line">			b[i][j]=<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (c[i-<span class="number">1</span>][j]&gt;=c[i][j-<span class="number">1</span>]) </span><br><span class="line"> 			c[i][j]=c[i-<span class="number">1</span>][j];</span><br><span class="line"> 			b[i][j]=<span class="number">2</span>;</span><br><span class="line"> 		<span class="keyword">else</span> </span><br><span class="line"> 			c[i][j]=c[i][j-<span class="number">1</span>];</span><br><span class="line"> 			b[i][j]=<span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">Algorithm <span class="title function_">lcs</span><span class="params">(<span class="type">int</span> i,<span class="type">int</span> j,<span class="type">char</span> [] x,<span class="type">int</span> [][] b)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (i ==<span class="number">0</span> || j==<span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">	<span class="keyword">if</span> (b[i][j]== <span class="number">1</span>)&#123;</span><br><span class="line">		lcs(i-<span class="number">1</span>,j-<span class="number">1</span>,x,b);</span><br><span class="line">		System.out.print(x[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (b[i][j]== <span class="number">2</span>) lcs(i-<span class="number">1</span>,j,x,b);</span><br><span class="line">	<span class="keyword">else</span> lcs(i,j-<span class="number">1</span>,x,b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>改进(1)：</strong>在算法lcsLength和lcs中，可进一步将数组b省去。<font color=grblue>对于给定的数组元素c[i][j]，可以不借助数组b而仅借助c本身确定 c[i][j]的值是由c[i-1][j-1]，c[i-1][j]和c[i][j-1]中哪一个值所确定的</font>。</p>
<p><strong>改进(2)：</strong>如果只需要计算最长公共子序列的长度，则算法的空间需求可大大减少。<font color=grblue>在计算c[i][j]时，只用到数组c的第i行和第i-1行</font>。用2行的数组空间就可以计算出最长公共子序列的长度，可将空间需求减至<font color=grblue>O(min(m,n))</font>。</p>
<h3 id="最大子段和O-n"><a href="#最大子段和O-n" class="headerlink" title="最大子段和O(n)"></a>最大子段和O(n)</h3><p>问题：给定n个整数（可能是负数）组成的序列a[1], a[2], a[3], …, a[n]，求该序列的子段和，例如a[i]+a[i+1]+…+a[j]的最大值。</p>
<p>当所给的整数均为负数时定义子段和为0，依此定义，所求的最优值为：<font color=orange>max{0, a[i]+a[i+1]+…+a[j]}</font>, 1&lt;&#x3D;i&lt;&#x3D;j&lt;&#x3D;n </p>
<p> 例如，当（a[1],a[2],a[3],a[4],a[5],a[6]）&#x3D;(-2,11,-4,13,-5,-2)时，最大子段和为20，即 20 &#x3D; 11 + (-4) + 13。</p>
<p><strong>算法设计</strong>：</p>
<p><strong>算法1</strong>：<strong>穷举法</strong> ，对所有的(i,j)对，顺序求和a[i]+…+a[j]并比较出最大的和</p>
<p>以a$_1$开始：{a$_1$}, {a$_1$,a$_2$}, {a$_1$,a$_2$,a$_3$}……{a$_1$,……a$_n$}，共n个</p>
<p>以a$_2$开始：{a$_2$}, {a$_2$,a$_3$}, {a$_2$,a$_3$,a$_4$}……{a$_2$,……a$_n$}，共n-1个</p>
<p>…… 以a$_n$开始：{a$_n$}，共1个</p>
<p>一共(n+1)*n&#x2F;2个连续子段</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 穷举法 T(n) = O(n^3)</span></span><br><span class="line"><span class="type">int</span> a[<span class="number">105</span>], n, maxSum=<span class="number">0</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">solve</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=i; j&lt;n; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> T=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k=i; k&lt;=j; k++)</span><br><span class="line">                T+=a[k];</span><br><span class="line">            <span class="keyword">if</span> (T&gt;maxSum)</span><br><span class="line">            &#123;</span><br><span class="line">                maxSum=T;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    solve();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,maxSum);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**************************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 穷举法 改进 T(n) = O(n^2)</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">solve</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> T=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=i; j&lt;n; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            T+=a[j];</span><br><span class="line">            <span class="keyword">if</span>(T&gt;maxSum)</span><br><span class="line">            &#123;</span><br><span class="line">                maxSum=T;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>算法2</strong>：<strong>分治法</strong> **T(n)&#x3D;O(nlogn)**，将数组分成左右两半，分别计算左边的最大和、右边的最大和、跨边界的最大和，然后比较其中最大者</p>
<p>将序列a[1:n] 分为长度相等的两段：a[1: n&#x2F;2]和a[n&#x2F;2+1: n]</p>
<p>分别求出这两段的最大子段和，则a[1:n] 的最大子段和有三种情形：</p>
<p>• (1) a[1:n]的最大子段和与a[1: n&#x2F;2]的最大子段和相同【在前半部分】</p>
<p>• (2) a[1:n] 的最大子段和与a[n&#x2F;2+1: n]的最大子段和相同【在后半部分】</p>
<p>• (3) a[1:n] 的最大子段和为ai +ai+1+…+aj 【在中间部分】</p>
<p>其中，1≤i ≤ n&#x2F;2，n&#x2F;2+1 ≤ j ≤ n </p>
<p>情形(1)和(2)可递归求得，情形(3)一定包括元素a[n&#x2F;2]和a[n&#x2F;2+1]</p>
<p> 在a[1: n&#x2F;2]中，求<strong>s1&#x3D;max{a$<em>i$ +a$</em>{i+1}$+…+a$_{n&#x2F;2}$}</strong>，i&#x3D;1,2,…..,n&#x2F;2</p>
<p> 在a[n&#x2F;2+1: n]中，求**s2&#x3D;max {a$_{n&#x2F;2+1}$+…+a$_j$ }**，j&#x3D;n&#x2F;2+1, ……,n</p>
<p> 则s1+s2 即为情形(3)时的最大值<br>$$<br>T(n)&#x3D;<br>\begin{cases}<br>O(1) &amp; n\leq 0 \<br>2T(n&#x2F;2)+O(n) &amp; n&gt;0<br>\end{cases}<br>$$</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a[<span class="number">105</span>], n, maxSum=<span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">solve</span><span class="params">(<span class="type">int</span> a[], <span class="type">int</span> left, <span class="type">int</span> right)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(left==right) </span><br><span class="line">        maxSum=(a[left]&gt;<span class="number">0</span>?a[left]:<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> mid=(left+right)/<span class="number">2</span>;</span><br><span class="line">        <span class="type">int</span> leftSum=solve(a, left, mid);</span><br><span class="line">        <span class="type">int</span> rightSum=solve(a, mid+<span class="number">1</span>, right);</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> s1=<span class="number">0</span>, lefts=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=mid; i&gt;=left; --i )</span><br><span class="line">        &#123;</span><br><span class="line">            lefts+=a[i];</span><br><span class="line">            <span class="keyword">if</span>(lefts&gt;s1) s1=lefts;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="type">int</span> s2=<span class="number">0</span>, rights=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=mid+<span class="number">1</span>; j&lt;=right; ++j )</span><br><span class="line">        &#123;</span><br><span class="line">            rights+=a[j];</span><br><span class="line">            <span class="keyword">if</span>(rights&gt;s2) s2=rights;</span><br><span class="line">        &#125;</span><br><span class="line">        maxSum=s1+s2;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(maxSum&lt;leftSum) maxSum=leftSum;</span><br><span class="line">        <span class="keyword">if</span>(maxSum&lt;rightSum) maxSum=rightSum;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> maxSum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,solve(a,<span class="number">0</span>,n<span class="number">-1</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>算法3</strong>：<strong>动态规划法 T(n)&#x3D;O(n)</strong></p>
<p>若记b[j]&#x3D;max(a[i]+a[i+1]+..+a[j])，<strong>b[j]表示以a[j]作为最后一个元素的最大子段和</strong>，其中1&lt;&#x3D;i&lt;&#x3D;j，并且1&lt;&#x3D;j&lt;&#x3D;n，则**所求的最大子段和为max{b[j]}**，1&lt;&#x3D;j&lt;&#x3D;n</p>
<p>由b[j]的定义可易知，当b[j-1]&gt;0时b[j]&#x3D;b[j-1]+a[j]，否则b[j]&#x3D;a[j]。故b[j]的动态规划递归式为:</p>
<p><strong>b[j]&#x3D;max(b[j-1]+a[j], a[j])，1&lt;&#x3D;j&lt;&#x3D;n</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a[<span class="number">105</span>],b[<span class="number">105</span>],n, maxSum;</span><br><span class="line"><span class="type">void</span> <span class="title function_">solve</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    b[<span class="number">0</span>]=a[<span class="number">0</span>];</span><br><span class="line">    maxSum=b[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(b[i<span class="number">-1</span>]&gt;<span class="number">0</span>)</span><br><span class="line">            b[i]=b[i<span class="number">-1</span>]+a[i];</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            b[i]=a[i];</span><br><span class="line">        <span class="keyword">if</span>(b[i]&gt;maxSum)</span><br><span class="line">            maxSum=b[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    solve();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,maxSum);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="LIS最长递增子序列"><a href="#LIS最长递增子序列" class="headerlink" title="LIS最长递增子序列"></a>LIS最长递增子序列</h3><p>问题：</p>
<p>**LIS(Longest Increasing Subsequence，最长递增子序列)**：给出一个序列a$_1$,a$_2$,a$_3$,a$_4$,….a$_n$，求它的一个子序列（设为s$_1$,s$_2$,…s$_n$），使得这个子序列满足这样的性质，s$_1$&lt;s$_2$&lt;…&lt;s$_n$并且这个子序列的长度最长。</p>
<p>• 【任务】输出这个最长子序列的长度</p>
<p>• 【样例输入】 1 7 3 5 9 4 8 </p>
<p>• 【样例输出】 长度为4【序列为1 3 5 9或1 3 4 8 】</p>
<p><strong>算法设计</strong>：</p>
<p>设b[i]是在a[i]为单调递增子序列最后一个元素时，所得最长单调递增子序列的长度<br>$$<br>b[i]&#x3D;<br>\begin{cases}<br>1 &amp; if(i&#x3D;1) \<br>max(b[j]) + 1 &amp; if( a[j] &lt; a[i] 且 1 \leq j&lt;i)<br>\end{cases}<br>$$</p>
<ul>
<li><p>a数组存储原始数据</p>
</li>
<li><p>b数组存储对应最长上升子序列长度</p>
</li>
<li><ul>
<li>i&#x3D;3时，a[i]&#x3D;3，在i&lt;3中寻找比3小的元素，有1，则b[3]&#x3D;1+1&#x3D;2</li>
<li>i&#x3D;5时，a[i]&#x3D;9,在i&lt;5中寻找比9小的元素，有1，3，5，7比较得到这些满足条件中的b[i]最大值，为3，则b[5]&#x3D;3+1&#x3D;4</li>
</ul>
</li>
<li><p><strong>构造最优解</strong> pre数组存储最长上升子序列当前元素的上一个元素的下标</p>
</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="D:\PersonalData\Mango\NEW\Blog\Hexo-blog\blog-mango\source\images\article\算法\dp-LIS算法设计.png" alt="image-20230316024312658"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="D:\PersonalData\Mango\NEW\Blog\Hexo-blog\blog-mango\source\images\article\算法\dp-LIS算法构造最优解.png" alt="image-20230316025231970"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 以下是C语言实现方式</span></span><br><span class="line"><span class="comment">// a数组存储原始数据，pre数组存储前一个数据编号</span></span><br><span class="line"><span class="comment">// b数组存储对应最长上升子序列长度</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, a[<span class="number">105</span>], b[<span class="number">105</span>], c[<span class="number">105</span>], maxLen, lab, pre[<span class="number">105</span>];</span><br><span class="line"><span class="type">void</span> <span class="title function_">solve</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//求最长上升子序列O(n^2)</span></span><br><span class="line">    b[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i++) <span class="comment">//分阶段</span></span><br><span class="line">    &#123;</span><br><span class="line">        maxLen = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = i - <span class="number">1</span>; j &gt;= <span class="number">1</span>; j--) <span class="comment">//枚举每个状态</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (a[j]&lt;a[i]&amp;&amp;b[j]&gt;maxLen)</span><br><span class="line">            &#123;</span><br><span class="line">                maxLen = b[j];</span><br><span class="line">                pre[i]=j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        b[i] = maxLen + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    maxLen = b[<span class="number">1</span>];</span><br><span class="line">    lab = <span class="number">1</span>; <span class="comment">//lab存储最长递增子序列最后一个元素的位置</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (b[i] &gt; maxLen)</span><br><span class="line">        &#123;</span><br><span class="line">            maxLen = b[i];</span><br><span class="line">            lab = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//拷贝数列到c数组</span></span><br><span class="line">    <span class="type">int</span> i = lab;</span><br><span class="line">    <span class="type">int</span> num = maxLen;</span><br><span class="line">    <span class="type">int</span> j = maxLen;</span><br><span class="line">    <span class="keyword">while</span>(num&gt;<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        c[j]=a[i];</span><br><span class="line">        j--;</span><br><span class="line">        i=pre[i];</span><br><span class="line">        num--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memset</span>(b, <span class="number">0</span>, <span class="keyword">sizeof</span>(a));</span><br><span class="line">    <span class="built_in">memset</span>(c, <span class="number">0</span>, <span class="keyword">sizeof</span>(c));</span><br><span class="line">    <span class="built_in">memset</span>(pre, <span class="number">0</span>, <span class="keyword">sizeof</span>(pre));</span><br><span class="line">    solve();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,maxLen);</span><br><span class="line">    <span class="comment">//输出数列O(n)</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=maxLen;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d,&quot;</span>,c[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="0-1背包问题O-nc"><a href="#0-1背包问题O-nc" class="headerlink" title="0-1背包问题O(nc)"></a>0-1背包问题O(nc)</h3><p>问题描述：</p>
<p>给定n种物品（每种物品只有一件）和一个背包：物品i的重量是w$_i$ ，其价值为v$_i$ ，背包的容量为C。问应如何选择装入背包的物品，使得装入背包中物品的总价值最大?</p>
<p> 对于每种物品，<font color=orange>只有两种选择：拿(1)或者不拿(0)，不允许拿物品的一部分</font></p>
<p> 0-1背包问题是一个特殊的整数规划问题<br>$$<br>\begin{aligned}<br> \left { \begin{aligned}<br>       \sum_{i&#x3D;1}^nw_ix_i \leq C \<br>        x_i \in{0,1},1 \leq i \leq n<br>       \end{aligned}<br> \right .							%加右}<br> \qquad \text max \sum_{i&#x3D;1}^nv_ix_i<br>\end{aligned}<br>$$<br><strong>问题分析</strong>：</p>
<p>【第一种分析】</p>
<ol>
<li>减少规模</li>
</ol>
<p>• 定义m(i，j)是背包容量为j，可选择物品为i，i+1，…，n时0-1背包问题的最优值</p>
<p>• m(i+1，j)为可选择物品为i+1，…，n时0-1背包问题的最优值</p>
<p>• …</p>
<p>• m(n，j)为可选择物品为n时0-1背包问题的最优值，此时，<strong>规模已为1</strong><br>$$<br>m(n,j)&#x3D;<br>\begin{cases}<br>v_n &amp; j \geq w_n \<br>0 &amp; 0 \leq j &lt; w_n<br>\end{cases}<br>$$</p>
<ol start="2">
<li>推导递归式</li>
</ol>
<p>判断是否放入第i件？</p>
<p>• 1）<strong>不放</strong>，背包当前产生价值仍为<strong>m(i+1，j)</strong></p>
<p>• 2）<strong>放入</strong>，调整背包容量j-w$_i$ ，背包当前产生价值为<strong>m(i+1, j-w$_i$)+v$_i$</strong></p>
<p>-&gt;判断第i件，由0-1背包问题的最优子结构性质，可以建立计算m(i，j)的递归式如下:<br>$$<br>m(i,j)&#x3D;<br>\begin{cases}<br>max { m(i+1,j), m(i+1,j-w_i)+v_i } &amp; j \geq w_i \<br>m(i+1,j) &amp; 0 \leq j &lt; w_i<br>\end{cases}</p>
<p>\</p>
<p>m(n,j)&#x3D;<br>\begin{cases}<br>v_n &amp; j \geq w_n \<br>0 &amp; 0 \leq j &lt; w_n<br>\end{cases}<br>$$<br><strong>实例分析</strong>：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="D:\PersonalData\Mango\NEW\Blog\Hexo-blog\blog-mango\source\images\article\算法\dp-01背包实例分析.png" alt="image-20230316033154179"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">(<span class="type">int</span> v[],<span class="type">int</span> w[],<span class="type">int</span> c,<span class="type">int</span> n,<span class="type">int</span> m[][<span class="number">11</span>])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> jMax=<span class="built_in">min</span>(w[n]<span class="number">-1</span>,c);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">0</span>;j&lt;=jMax;j++) &#123; <span class="comment">//当 0=&lt;j&lt;w[n]时, m(n,j)=0</span></span><br><span class="line">        m[n][j]=<span class="number">0</span>; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j=w[n];j&lt;=c;j++) &#123; <span class="comment">// 当j&gt;=w[n]时, m(n,j)=v[n]</span></span><br><span class="line">        m[n][j]=v[n]; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=n<span class="number">-1</span>;i&gt;=<span class="number">1</span>;i--) &#123; <span class="comment">//DP</span></span><br><span class="line">        <span class="type">int</span> jMax=<span class="built_in">min</span>(w[i]<span class="number">-1</span>,c);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">0</span>;j&lt;=jMax;j++) &#123; <span class="comment">//m(i,j)=m(i+1,j) 当0=&lt;j&lt;w[i]</span></span><br><span class="line">            m[i][j]=m[i+<span class="number">1</span>][j]; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j=w[i];j&lt;=c;j++) &#123; <span class="comment">//m(n,j)=v[n] 当j&gt;=w[n]</span></span><br><span class="line">            m[i][j]=<span class="built_in">max</span>(m[i+<span class="number">1</span>][j],m[i+<span class="number">1</span>][j-w[i]]+v[i]); </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;m[<span class="number">1</span>][c]; <span class="comment">//在c容量可获的最大价值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 从m(i, j)的递归式可以看出，算法需要O(nc)的计算时间，即**T(n)&#x3D;O(nc)**，其中，n为物品数量，c为背包容量</p>
<p> 当背包容量c很大时，算法需要较多的计算时间，例如，当c&gt;2n时，算法需要的计算时间为Ω(n2n)</p>
<p> 算法的空间复杂度：<strong>S(n)&#x3D;O(nc)</strong></p>
<p><strong>构造最优解</strong>：</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="D:\PersonalData\Mango\NEW\Blog\Hexo-blog\blog-mango\source\images\article\算法\dp-01背包构造最优解.png" alt="image-20230316034058367" style="zoom:80%;" />

<p>【第二种分析】</p>
<ol>
<li>换角度来减少规模</li>
</ol>
<p>• 定义m(i，j)是背包容量为j，可选择物品为1,2,3，…，i-1,i时0-1背包问题的最优值</p>
<p>• m(i-1，j)为可选择物品为1,2,3，…，i-1时0-1背包问题的最优值</p>
<p>• …</p>
<p>• m(1，j)为可选择物品为1时0-1背包问题的最优值，此时，<strong>规模已为1</strong><br>$$<br>m(1,j)&#x3D;<br>\begin{cases}<br>v_1 &amp; j \geq w_1 \<br>0 &amp; 0 \leq j &lt; w_1<br>\end{cases}<br>$$</p>
<ol start="2">
<li>推导递归式</li>
</ol>
<p>判断是否放入第i件？</p>
<p>• 1）<strong>不放</strong>，背包当前产生价值仍为<strong>m(i-1，j)</strong></p>
<p>• 2）<strong>放入</strong>，调整背包容量j-w$_i$ ，背包当前产生价值为<strong>m(i-1, j-w$_i$)+v$_i$</strong></p>
<p>计算m(i，j)的递归式如下:<br>$$<br>m(i,j)&#x3D;<br>\begin{cases}<br>max { m(i-1,j), m(i-1,j-w_i)+v_i } &amp; j \geq w_i \<br>m(i-1,j) &amp; 0 \leq j &lt; w_i<br>\end{cases}</p>
<p>\</p>
<p>m(1,j)&#x3D;<br>\begin{cases}<br>v_1 &amp; j \geq w_1 \<br>0 &amp; 0 \leq j &lt; w_1<br>\end{cases}<br>$$<br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="D:\PersonalData\Mango\NEW\Blog\Hexo-blog\blog-mango\source\images\article\算法\dp-01背包实例分析-自上而下.png" alt="image-20230316034635634" style="zoom:80%;" /></p>
<blockquote>
<p>思考</p>
<p> <strong>完全背包问题：</strong>有n种物品和一个容量为C的背包，<strong>每种物品都有无限件可用</strong>。物品i的重量是w[i]，价值为v[i]。求解将哪些物品装入背包可使这些物品的重量总和不超过背包容量，且价值总和最大。</p>
<p> <strong>多重背包问题：</strong>有n种物品和一个容量为C的背包，<strong>第i种物品最多有n[i]件可用</strong>，物品i的重量是w[i]，价值为v[i]。求解将哪些物品装入背包可使这些物品的重量总和不超过背包容量，且价值总和最大。</p>
</blockquote>
<h2 id="算法——贪心算法"><a href="#算法——贪心算法" class="headerlink" title="算法——贪心算法"></a>算法——贪心算法</h2><p>贪心算法概述：</p>
<p><strong>定义</strong>：贪心算法是指在对问题进行求解时，<font color=orange>在每一步选择中都采取最好或者最优（最有利）的选择，从而希望最终结果是最好或者最优的算法</font>。 &#x3D;&#x3D;局部最优 &#x3D;&gt; 全局最优&#x3D;&#x3D;</p>
<ul>
<li><p>有一些问题可以得到整体最优解：<strong>活动安排问题、部分背包问题、最优装载问题、单源最短路径问题、最小生成树</strong>问题等</p>
</li>
<li><p>有一些问题不能得到整体最优解 -&gt; <strong>近似最优解</strong>：<u>多机调度问题、0-1背包</u>问题等</p>
</li>
</ul>
<p><strong>贪心算法的基本要素</strong>：</p>
<ul>
<li><p><strong>贪心选择性质</strong></p>
</li>
<li><ul>
<li>所求问题的整体最优解可以通过一系列局部最优的选择，即贪心选择来达到</li>
<li>是贪心算法与动态规划算法的主要区别</li>
<li>每作一次贪心选择可将所求问题 <u>简化为规模更小的子问题</u></li>
</ul>
</li>
<li><p><strong>最优子结构性质</strong></p>
</li>
<li><ul>
<li>一个问题的最优解 <u>包含其子问题的最优解</u></li>
</ul>
</li>
<li><ul>
<li>一个问题的最优子结构性质是该问题是否可用动态规划算法或贪心算法求解的关键特征</li>
</ul>
</li>
</ul>
<h3 id="活动安排问题O-nlogn"><a href="#活动安排问题O-nlogn" class="headerlink" title="活动安排问题O(nlogn)"></a>活动安排问题O(nlogn)</h3><p>问题：</p>
<p> 设有n个活动的集合E&#x3D;{1,2,…,n}，其中，<font color=orange>每个活动都要求使用同一资源</font>，如演讲会场等，而在<font color=orange>同一时间内只有一个活动能使用这一资源</font>。</p>
<p> 每个活动i都有一个要求使用该资源的<strong>起始时间s$_i$</strong> 和一个<strong>结束时间f$_i$</strong> ，且s$_i$ &lt;f$_i$ 。如果选择了活动i，则它在半开区间**[s$_i$  , $f_i$ )**内占用资源。</p>
<p> 若区间[s$_i$  , $f_i$ )与区间[s$_j$ , $f_j$ )不相交，则称活动i与活动j是<font color=orange>相容</font>的。即：当s$_i$ ≥f$_j$ 或s$_j$ ≥f$_i$ 时，活动i与活动j相容。</p>
<p><strong>活动安排问题：在所给的活动集合中选出最大的相容活动子集</strong>。</p>
<p><strong>算法设计</strong>：该问题要求高效地安排一系列争用某一公共资源的活动</p>
<p>设计思路：</p>
<p>• 按 <u>结束时间的非减序</u> 对活动进行排列</p>
<p>• 选择一个 <u>结束时间最早</u> 的活动</p>
<p>• 依次检查后续活动是否与当前已选择的所有活动相容，<font color=orange>若相容则将该活动加入已选择活动集合中</font>，再继续检查下一活动，否则直接检查下一活动</p>
<p>• 直到所有活动全部检查完毕</p>
<p>由于输入的活动以其完成时间的非减序排列 -&gt; 算法每次总是<strong>选择具有最早完成时间的相容活动加入集合中</strong></p>
<p> 贪心选择意义：使剩余的可安排时间段极大化，以便安排尽可能多的相容活动</p>
<p> 算法效率高：当输入的活动已按结束时间非减序排列，算法只需**O(n)<strong>的时间安排n个活动，使最多的活动能相容地使用公共资源；如果所给出的活动未按非减序排列，需要</strong>O(nlogn)**的时间排序</p>
<p>时间复杂度（输入活动无序）：<strong>T(n) &#x3D; O(nlogn) + O(n) &#x3D; O(nlogn)</strong></p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** 定义数据结构 **/</span></span><br><span class="line"><span class="meta">#include &lt;iostream&gt;</span></span><br><span class="line"><span class="meta">#include &lt;algorithm&gt;</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="title">std</span>;</span><br><span class="line"><span class="comment">//结构体：活动</span></span><br><span class="line"><span class="keyword">struct</span> Activity&#123;</span><br><span class="line">    <span class="built_in">int</span> id; <span class="comment">//活动编号</span></span><br><span class="line">	<span class="built_in">int</span> sTime; <span class="comment">//活动开始时间</span></span><br><span class="line">	<span class="built_in">int</span> fTime; <span class="comment">//活动结束时间</span></span><br><span class="line">	<span class="built_in">bool</span> selected; <span class="comment">//该活动是否选中</span></span><br><span class="line">&#125;;</span><br><span class="line">Activity activities[<span class="number">11</span>];</span><br><span class="line"><span class="built_in">int</span> s[<span class="number">11</span>] = &#123;<span class="number">1</span>,<span class="number">3</span>,<span class="number">0</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">8</span>,<span class="number">2</span>,<span class="number">12</span>&#125;;</span><br><span class="line"><span class="built_in">int</span> f[<span class="number">11</span>] = &#123;<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>,<span class="number">11</span>,<span class="number">12</span>,<span class="number">13</span>,<span class="number">14</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 贪心选择 **/</span></span><br><span class="line"><span class="comment">//比较函数</span></span><br><span class="line"><span class="function"><span class="built_in">int</span> <span class="title">cmp</span>(<span class="params"><span class="keyword">const</span> Activity &amp;a, <span class="keyword">const</span> Activity &amp;b</span>)</span>&#123;</span><br><span class="line">	<span class="comment">//按照活动结束时间非减序排列</span></span><br><span class="line">	<span class="keyword">return</span> a.fTime &lt; b.fTime;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//贪心选择</span></span><br><span class="line"><span class="function"><span class="built_in">int</span> <span class="title">activitySelect</span>(<span class="params">Activity activities[], <span class="built_in">int</span> n</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">int</span> activityCount = <span class="number">0</span>;</span><br><span class="line">	activities[<span class="number">0</span>].selected=<span class="literal">true</span>;</span><br><span class="line">	<span class="built_in">int</span> j=<span class="number">0</span>;</span><br><span class="line">	activityCount=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="built_in">int</span> i=<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//i的开始时间在j的结束时间之后，则相容</span></span><br><span class="line">		<span class="keyword">if</span>(activities[i].sTime&gt;=activities[j].fTime) &#123;</span><br><span class="line">			activities[i].selected=<span class="literal">true</span>;</span><br><span class="line">			j=i;</span><br><span class="line">			activityCount++;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> activityCount;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 主函数 **/</span></span><br><span class="line"><span class="function"><span class="built_in">int</span> <span class="title">main</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="built_in">int</span> i=<span class="number">0</span>;i&lt;<span class="number">11</span>;i++) &#123;</span><br><span class="line">		activities[i].id = i+<span class="number">1</span>;</span><br><span class="line">		activities[i].sTime = s[i];</span><br><span class="line">		activities[i].fTime = f[i];</span><br><span class="line">		activities[i].selected = <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	sort(activities,activities + <span class="number">11</span>,cmp); <span class="comment">//快速排序</span></span><br><span class="line">	<span class="built_in">int</span> activityCount = <span class="number">0</span>;</span><br><span class="line">	activityCount = activitySelect(activities, <span class="number">11</span>);</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;相容活动数量：&quot;</span> &lt;&lt; activityCount &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;相容活动编号：&quot;</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="built_in">int</span> i=<span class="number">0</span>;i&lt;<span class="number">11</span>;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(activities[i].selected)</span><br><span class="line">		&#123;</span><br><span class="line">			cout&lt;&lt;activities[i].id&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	cout&lt;&lt;endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>实例分析</strong>：</p>
<p>贪心算法提供了一个简单、漂亮的方法使得尽可能多的活动能兼容地使用公共资源</p>
<p>例：设待安排的11个活动的开始时间和结束时间按结束时间的非减序排列如下：</p>
<table>
<thead>
<tr>
<th>i</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
<th>6</th>
<th>7</th>
<th>8</th>
<th>9</th>
<th>10</th>
<th>11</th>
</tr>
</thead>
<tbody><tr>
<td>s[i]</td>
<td>1</td>
<td>3</td>
<td>0</td>
<td>5</td>
<td>3</td>
<td>5</td>
<td>6</td>
<td>8</td>
<td>8</td>
<td>2</td>
<td>12</td>
</tr>
<tr>
<td>f[i]</td>
<td><strong>4</strong></td>
<td><strong>5</strong></td>
<td><strong>6</strong></td>
<td><strong>7</strong></td>
<td><strong>8</strong></td>
<td><strong>9</strong></td>
<td><strong>10</strong></td>
<td><strong>11</strong></td>
<td><strong>12</strong></td>
<td><strong>13</strong></td>
<td><strong>14</strong></td>
</tr>
</tbody></table>
<p>若<font color=green>被检查的活动i的开始时间s$_i$ 小于最近选择的活动j的结束时间f$_i$ ，则不选择活动i，否则选择活动i</font>加入已选活动集合中</p>
<table>
<thead>
<tr>
<th>i</th>
<th>&#x3D;&#x3D;1&#x3D;&#x3D;</th>
<th>2</th>
<th>3</th>
<th>&#x3D;&#x3D;4&#x3D;&#x3D;</th>
<th>5</th>
<th>6</th>
<th>7</th>
<th>&#x3D;&#x3D;8&#x3D;&#x3D;</th>
<th>9</th>
<th>10</th>
<th>&#x3D;&#x3D;11&#x3D;&#x3D;</th>
</tr>
</thead>
<tbody><tr>
<td>s[i]</td>
<td>&#x3D;&#x3D;1&#x3D;&#x3D;</td>
<td>3</td>
<td>0</td>
<td>&#x3D;&#x3D;5&#x3D;&#x3D;</td>
<td>3</td>
<td>5</td>
<td>6</td>
<td>&#x3D;&#x3D;8&#x3D;&#x3D;</td>
<td>8</td>
<td>2</td>
<td>&#x3D;&#x3D;12&#x3D;&#x3D;</td>
</tr>
<tr>
<td>f[i]</td>
<td>&#x3D;&#x3D;4&#x3D;&#x3D;</td>
<td>5</td>
<td>6</td>
<td>&#x3D;&#x3D;7&#x3D;&#x3D;</td>
<td>8</td>
<td>9</td>
<td>10</td>
<td>&#x3D;&#x3D;11&#x3D;&#x3D;</td>
<td>12</td>
<td>13</td>
<td>&#x3D;&#x3D;14&#x3D;&#x3D;</td>
</tr>
</tbody></table>
<p>对于活动安排问题，<font color=green>贪心算法能求得的整体最优解，即它最终所确定的相容活动集合的规模最大</font></p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="D:\PersonalData\Mango\NEW\Blog\Hexo-blog\blog-mango\source\images\article\算法\tx-活动安排实例分析.png" alt="image-20230316161326582" style="zoom:80%;" />

<h3 id="部分背包问题O-nlogn"><a href="#部分背包问题O-nlogn" class="headerlink" title="部分背包问题O(nlogn)"></a>部分背包问题O(nlogn)</h3><p><strong>贪心算法与动态规划算法的差异</strong></p>
<ul>
<li><p><u>贪心算法和动态规划算法都要求问题具有最优子结构性质</u></p>
</li>
<li><p>对于具有最优子结构的问题应该选用贪心算法还是动态规划算法求解？</p>
</li>
<li><p>是否能用动态规划算法求解的问题也能用贪心算法求解？</p>
</li>
</ul>
<p>差异实例分析：0-1背包、部分背包问题</p>
<table>
<thead>
<tr>
<th>0-1背包</th>
<th>部分背包</th>
</tr>
</thead>
<tbody><tr>
<td>给定n种物品（每种物品一件）和一个背包。物品i的重量是W$_i$ ，其价值为V$_i$ ，背包的容量为C。应如何选择装入背包的物品，使得装入背包中物品的总价值最大？<br><br>在选择装入背包的物品时，对每种物品i<strong>只有2种选择</strong>，即装入背包或不装入背包。不能将物品i装入背包多次，也不能只装入部分的物品i。</td>
<td>与0-1背包问题类似，所不同的是在选择物品i装入背包时，可以<strong>选择物品i的一部分</strong>，而不一定要全部装入背包，1≤i≤n。</td>
</tr>
<tr>
<td>&#x3D;&#x3D;动态规划求解&#x3D;&#x3D; <br><br>对于0-1背包问题，贪心选择不能得到最优解 -&gt; <strong>无法保证最终能将背包装满</strong>，部分闲置的背包空间降低了每公斤背包空间的价值<br>应比较选择该物品和不选择该物品所导致的最终方案，然后再作出最好选择 -&gt; <font color=orange>重叠子问题</font> -&gt; <strong>动态规划</strong></td>
<td>可以用&#x3D;&#x3D;贪心算法&#x3D;&#x3D;求解 <br><br>对于部分背包问题，优先选择单位重量下价值最大的物品 -&gt; <font color=orange>贪心选择性质</font> -&gt; <strong>贪心算法</strong></td>
</tr>
</tbody></table>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="D:\PersonalData\Mango\NEW\Blog\Hexo-blog\blog-mango\source\images\article\算法\tx-背包问题差异.png" alt="image-20230316162208657" style="zoom:80%;" />

<p><strong>部分背包</strong>问题描述：</p>
<p>设有编号为1,2,3,……,n的n个物品，它们的重量分别为w$_1$, w$_2$, w$_3$, ……, w$_n$，价值分别为v$_1$, v$_2$, v$_3$, ……, v$_n$，其中w$_i$ 和v$_i$ (1≤i≤n)均为正数。有一个背包可以携带的最大重量不超过W。</p>
<p> 求解目标：<strong>在不超过背包负重的前提下使背包装入的总价值最大</strong>（即效益最大化），<strong>允许每个物品取一部分装入背包</strong></p>
<p>问题形式化：</p>
<p>设x$_i$表示物品i装入背包的情况，0≤x$_i$≤1。寻找一个满足下述约束条件，并使目标函数达到最大的解向量X&#x3D;(x$_1$, x$_2$, x$_3$ ,……, x$<em>n$)。<br>$$<br>约束条件：<br>\begin{aligned}<br>\sum</em>{i &#x3D; 1} ^n w_ix_i \leq W &amp;&amp;&amp; 0 \leq x_i \leq 1(1 \leq i \leq n)<br>\end{aligned}</p>
<p>\</p>
<p>目标函数：<br>\begin{aligned}<br>max{ \sum_{i&#x3D;1}^n v_ix_i }<br>\end{aligned}<br>$$<br>如何制定贪心策略？</p>
<p>• (1) 选择<u>价值最大的物品</u> -&gt; 背包容量可能消耗很快</p>
<p>• (2) 选择<u>重量最轻</u>的物品 -&gt; 背包价值可能增长很缓慢</p>
<p>• (3) 选择<u>单位重量下价值最大</u>的物品 -&gt; 在背包价值增长和背包容量消耗之间寻找平衡</p>
<p><strong>设计思路</strong>：</p>
<p> 1. 按照单位重量价值对物品进行<strong>降序</strong>排序</p>
<p> 2. <strong>依次从物品集合中选择单位重量价值最大的物品：如果某物品重量小于背包剩余容量，则将该物品全部装入</strong>，背包总价值加上该物品的价值，背包容量减去该物品的重量，直到所有物品全部装入背包或者背包剩余重量为0为止</p>
<p> 3. 如果某剩余物品重量大于背包剩余容量，且背包剩余容量&gt;0，则<strong>将该物品的一部分装入背包</strong>，背包总价值加上该物品填满剩余容量所对应的价值</p>
<p> 4. 返回背包总价值</p>
<p><strong>实例分析</strong>：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="D:\PersonalData\Mango\NEW\Blog\Hexo-blog\blog-mango\source\images\article\算法\tx-部分背包实例.png" alt="image-20230316164448205"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** 数据结构定义 **/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXN 51</span></span><br><span class="line"><span class="comment">//问题表示</span></span><br><span class="line"><span class="type">int</span> n=<span class="number">5</span>;</span><br><span class="line"><span class="type">double</span> W=<span class="number">100</span>; <span class="comment">//限重</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">NodeType</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="type">double</span> w;</span><br><span class="line">	<span class="type">double</span> v;</span><br><span class="line">	<span class="type">double</span> p; <span class="comment">//p=v/w</span></span><br><span class="line">	<span class="type">bool</span> operator&lt;(<span class="type">const</span> NodeType &amp;s) <span class="type">const</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> p&gt;s.p; <span class="comment">//按p递减排序</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line">NodeType A[]=&#123;&#123;<span class="number">0</span>&#125;,&#123;<span class="number">10</span>,<span class="number">20</span>&#125;,&#123;<span class="number">20</span>,<span class="number">30</span>&#125;,&#123;<span class="number">30</span>,<span class="number">66</span>&#125;,&#123;<span class="number">40</span>,<span class="number">40</span>&#125;,&#123;<span class="number">50</span>,<span class="number">60</span>&#125;&#125;; <span class="comment">//下标为0的元素不用</span></span><br><span class="line"><span class="comment">//求解结果表示</span></span><br><span class="line"><span class="type">double</span> value; <span class="comment">//最大价值</span></span><br><span class="line"><span class="type">double</span> x[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 背包问题求解函数 **/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">knapsack</span><span class="params">()</span> <span class="comment">//求解背包问题并返回总价值</span></span><br><span class="line">&#123;</span><br><span class="line">	value=<span class="number">0</span>; <span class="comment">//初始化最大价值为0</span></span><br><span class="line">	<span class="type">double</span> weight=W; <span class="comment">//背包中能够装入的剩余重量</span></span><br><span class="line">	<span class="built_in">memset</span>(x,<span class="number">0</span>,<span class="keyword">sizeof</span>(x)); <span class="comment">//初始化x向量</span></span><br><span class="line">	<span class="type">int</span> i=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span>(A[i].w&lt;weight) <span class="comment">//物品i能够全部装入时循环</span></span><br><span class="line">	&#123;</span><br><span class="line">		x[i]=<span class="number">1</span>; <span class="comment">//装入物品i</span></span><br><span class="line">		weight-=A[i].w; <span class="comment">//减少背包中能装入的剩余重量</span></span><br><span class="line">		value+=A[i].v; <span class="comment">//累计总价值</span></span><br><span class="line">		i++; <span class="comment">//继续循环</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(weight&gt;<span class="number">0</span>) <span class="comment">//余下重量大于0</span></span><br><span class="line">	&#123;</span><br><span class="line">		x[i]=weight/A[i].w; <span class="comment">//将物品i的一部分装入</span></span><br><span class="line">		value+=x[i]*A[i].v; <span class="comment">//累计总价值</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 输出函数和主函数 **/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">display</span><span class="params">()</span> <span class="comment">//输出结果</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\tW\tV\tV/W\n&quot;</span>);</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;\t%g\t%g\t%3.1f\n&quot;</span>,A[i].w,A[i].v,A[i].p);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;求解过程\n&quot;</span>);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		A[i].p=A[i].v/A[i].w; <span class="comment">//求v/w</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;(1)排序前\n&quot;</span>); display();</span><br><span class="line">	sort(A+<span class="number">1</span>,A+n+<span class="number">1</span>); <span class="comment">//排序</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;(2)排序后\n&quot;</span>); display();</span><br><span class="line">	knapsack();</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;(3)求解结果\n&quot;</span>); <span class="comment">//输出结果</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\tx:[&quot;</span>);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%g,&quot;</span>,x[j]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%g]\n&quot;</span>,x[n]);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\t总价值=%g\n&quot;</span>, value);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>时间复杂度</strong>：</p>
<p>排序算法sort()的时间复杂度为O(nlogn)，while循环的时间复杂度为O(n)</p>
<p>算法的总时间复杂度：<strong>T(n) &#x3D; O(nlogn) + O(n) &#x3D; O(nlogn)</strong></p>
<h3 id="最优装载O-nlogn"><a href="#最优装载O-nlogn" class="headerlink" title="最优装载O(nlogn)"></a>最优装载<strong>O(nlogn)</strong></h3><p>问题描述：</p>
<p>有一批集装箱要装上一艘载重量为c的轮船，其中集装箱i的重量为w$<em>i$ 。最优装载问题要求在装载体积不受限制的情况下，将尽可能多的集装箱装上轮船。<br>$$<br>\begin{aligned}<br>max\sum</em>{i&#x3D;1}^n x_i \<br>\end{aligned}<br>\ </p>
<p>\begin{cases}<br>\sum_{i&#x3D;1}^n w_i x_i \leq C \<br>x_i \in { 0,1 } &amp; 1 \leq i \leq n<br>\<br>\end{cases}</p>
<p>\</p>
<p>变量x_i&#x3D;0表示不装入集装箱i，x_i&#x3D;1表示装入集装箱i<br>$$<br>采用<strong>重量最轻者先装</strong>的贪心选择策略，可产生最优装载问题的最优解</p>
<p>实现原理：排序 -&gt; 装载</p>
<p>• 每次选择时，从剩下的集装箱中，<u>选择重量最小的集装箱</u></p>
<p>• 可以保证已经选出来的集装箱总重量最小，装载的集装箱数量最多，<u>直到轮船不能再继续装载为止</u></p>
<p><strong>贪心选择性质</strong>：从局部最优可推导出全局最优</p>
<p><strong>最优子结构性质</strong>：一个问题的最优解包含其子问题的最优解</p>
<p>算法的主要计算量在于将集装箱依其重量从小到大排序</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//集装箱结构体</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">box</span>&#123;</span><br><span class="line">	<span class="type">int</span> weight;<span class="comment">//集装箱重量</span></span><br><span class="line">	<span class="type">int</span> index; <span class="comment">//集装箱编号</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//比较函数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">cmp</span><span class="params">(<span class="type">const</span> box &amp;a, <span class="type">const</span> box &amp;b)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> a.weight &lt; b.weight; <span class="comment">//按照集装箱重量由小到大排序</span></span><br><span class="line">&#125;</span><br><span class="line">box boxes[<span class="number">8</span>];</span><br><span class="line"><span class="type">int</span> weight[<span class="number">8</span>] = &#123;<span class="number">100</span>,<span class="number">200</span>,<span class="number">50</span>,<span class="number">90</span>,<span class="number">150</span>,<span class="number">50</span>,<span class="number">20</span>,<span class="number">80</span>&#125;;</span><br><span class="line"><span class="type">int</span> x[<span class="number">8</span>];</span><br><span class="line"><span class="type">int</span> c = <span class="number">400</span>;</span><br><span class="line"><span class="type">int</span> opt = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//贪心算法实现最优装载</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">loading</span><span class="params">(box boxes[], <span class="type">int</span> x[], <span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> num = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n&amp;&amp;boxes[i].weight&lt;=c;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		x[boxes[i].index<span class="number">-1</span>]=<span class="number">1</span>; <span class="comment">//记录装载的集装箱编号</span></span><br><span class="line">		num++;</span><br><span class="line">		c-=boxes[i].weight; <span class="comment">//更新剩余重量</span></span><br><span class="line">		opt+=boxes[i].weight; <span class="comment">//更新已装载总重量</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> num;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">8</span>;i++) &#123;</span><br><span class="line">		boxes[i].index = i+<span class="number">1</span>;</span><br><span class="line">		boxes[i].weight=weight[i];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">sort</span>(boxes,boxes + <span class="number">8</span>,cmp); <span class="comment">//快速排序</span></span><br><span class="line">	<span class="built_in">memset</span>(x,<span class="number">0</span>,<span class="built_in">sizeof</span>(x));</span><br><span class="line">	<span class="type">int</span> boxCount = <span class="number">0</span>;</span><br><span class="line">	boxCount = <span class="built_in">loading</span>(boxes,x,<span class="number">8</span>);</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;集装箱数量：&quot;</span> &lt;&lt; boxCount &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;集装箱总重量：&quot;</span> &lt;&lt; opt &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;集装箱编号：&quot;</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">8</span>;i++) &#123;</span><br><span class="line">		<span class="keyword">if</span>(x[i]==<span class="number">1</span>) &#123;</span><br><span class="line">			cout&lt;&lt;i+<span class="number">1</span>&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	cout&lt;&lt;endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="MST最小生成树"><a href="#MST最小生成树" class="headerlink" title="MST最小生成树"></a>MST最小生成树</h3><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="D:\PersonalData\Mango\NEW\Blog\Hexo-blog\blog-mango\source\images\article\算法\tx-最小生成树-畅通工程.png" alt="image-20230316170408585" style="zoom:88%;" />

<p><strong>最小生成树 Minimal Spanning Trees (MST)</strong></p>
<p>任何只由图G的边构成，并包含G的所有顶点的树称为 <u>G的生成树</u></p>
<p>加权无向图G的生成树的代价（权重）是该<u>生成树的所有边的代价（权重）的和</u></p>
<p>最小生成树是其所有生成树中代价（权重）最小的生成树</p>
<p>N个顶点，选取N-1条边，构建一个连通图，且这N-1条边的权重之和最小</p>
<h4 id="最小生成树——Prim算法O-V-2"><a href="#最小生成树——Prim算法O-V-2" class="headerlink" title="最小生成树——Prim算法O(V$^2$)"></a>最小生成树——Prim算法O(V$^2$)</h4><p>普里姆算法 具有贪心选择性质 -&gt; 贪心算法经典实例</p>
<p>Prim算法是一种<strong>基于贪心思想求解加权无向图的最小生成树</strong>的算法</p>
<p>Prim算法的时间复杂度为T(n)&#x3D; O(V$^2$)，适合于处理稠密图；如果使用小根堆优化，时间复杂度为T(n)&#x3D;O(ElogV)</p>
<p><strong>实例分析</strong>：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="D:\PersonalData\Mango\NEW\Blog\Hexo-blog\blog-mango\source\images\article\算法\tx-prim实例分析.png" alt="image-20230316180441431"></p>
<p>设计思路：</p>
<p>(1) 任意选定一点s，设集合S&#x3D;{s}</p>
<p>(2) 从<strong>不在集合S的点</strong>中<strong>选出一个点j使得其与S内的某点i的距离最短</strong>，则(i，j)就是生成树上的一条边，同时将j点加入S</p>
<p>(3) 转到(2)继续进行，直至所有点都己加入S集合</p>
<p><strong>公路造价问题描述</strong>：</p>
<p>现有一张城市地图，图中的顶点为城市，无向边代表两个城市间的连通关系，边上的权代表公路造价。在分析了这张图后发现，任一对城市都是连通的。现在要求用公路把所有城市联系起来，如何设计可使得工程的总造价最少？</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="D:\PersonalData\Mango\NEW\Blog\Hexo-blog\blog-mango\source\images\article\算法\tx-prim公路造价图.png" alt="image-20230316180745830"></p>
<p>【输入格式】：第一行两个数v(v&lt;&#x3D;200)和e分别代表城市数和边数，以下e行，每行为两个顶点和它们之间的边权w(w&lt;1000)。<br>【输出格式】：v-1行，每行为两个城市的序号，表明这两个城市间建一条公路，再加该公路的造价。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** 数据结构定义和初始化 **/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span> </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std; </span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXN 2005</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INF 1000000</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> G[MAXN][MAXN]; <span class="comment">//存储图</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span> ; i &lt; n ; i++)&#123; </span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span> ; j &lt; n ; j++) </span><br><span class="line">			G[i][j] = INF; <span class="comment">//初始化图中两点间距离为无穷大</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/** 贪心选择 **/</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">prim</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> closeset[n], <span class="comment">//记录不在S中的顶点在S中的最近邻接点</span></span><br><span class="line">	lowcost[n], <span class="comment">//记录不在S中的顶点到S的最短距离，即到最近邻接点的权值</span></span><br><span class="line">	used[n]; <span class="comment">//标记顶点是否被访问，访问过的顶点标记为1 </span></span><br><span class="line">    </span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//初始化，S中只有第1个点(0)</span></span><br><span class="line">		lowcost[i] = G[<span class="number">0</span>][i]; <span class="comment">//获取其他顶点到第1个点(0)的距离，不直接相邻的顶点距离为无穷大</span></span><br><span class="line">		closeset[i] = <span class="number">0</span>; <span class="comment">//初始情况下所有点的最近邻接点都为第1个点(0) </span></span><br><span class="line">		used[i] = <span class="number">0</span>; <span class="comment">//初始情况下所有点都没有被访问过</span></span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">	used[<span class="number">0</span>] = <span class="number">1</span>; <span class="comment">//访问第1个点(0)，将第1个点加到S中</span></span><br><span class="line">    <span class="comment">//每一次循环找出一个到S距离最近的顶点</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> j = <span class="number">0</span>; </span><br><span class="line">		<span class="comment">//每一次循环计算所有没有使用的顶点到当前S的距离，得到在没有使用的顶点中到S的最短距离以及顶点号</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; n; k++)</span><br><span class="line">            <span class="comment">//如果顶点k没有被使用，且到S的距离小于j到S的距离，将k赋给j </span></span><br><span class="line">			<span class="keyword">if</span> ((!used[k]) &amp;&amp; (lowcost[k] &lt; lowcost[j])) j = k; </span><br><span class="line">        	<span class="comment">//输出S中与j最近邻点，j，以及它们之间的距离</span></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d %d %d\n&quot;</span>,closeset[j] + <span class="number">1</span>, j + <span class="number">1</span>, lowcost[j]); </span><br><span class="line">		used[j] = <span class="number">1</span>; <span class="comment">//将j增加到S中</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//每一次循环用于在j加入S后，重新计算不在S中的顶点到S的距离，修改与j相邻的边到S的距离，即更新lowcost和closeset</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; n; k++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> ((!used[k]) &amp;&amp; (G[j][k] &lt; lowcost[k])) <span class="comment">//松弛操作，如果k没有被使用，且k到j的距离比原来k到S的距离小</span></span><br><span class="line">			&#123; </span><br><span class="line">				lowcost[k] = G[j][k]; <span class="comment">//将k到j的距离作为新的k到S之间的距离</span></span><br><span class="line">				closeset[k] = j; <span class="comment">//将j作为k在S中的最近邻点</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：</p>
<p><strong>T(n)&#x3D; O(V$^2$)</strong> 【邻接矩阵】-&gt; <strong>稠密图</strong></p>
<p>堆优化（小根堆）：<strong>T(n) &#x3D; O(VlogV)+O(ElogV) &#x3D; O(ElogV)</strong></p>
<p>堆优化（斐波那契堆）：<strong>T(n) &#x3D; O(E+VlogV)</strong></p>
<h4 id="最小生成树——Kruskal算法-O-ElogE"><a href="#最小生成树——Kruskal算法-O-ElogE" class="headerlink" title="最小生成树——Kruskal算法 O(ElogE)"></a>最小生成树——Kruskal算法 O(ElogE)</h4><p>克鲁斯卡尔算法，一种用来查找最小生成树的算法</p>
<p><strong>并查集 -&gt; 最小生成树 -&gt; Kruskal算法</strong></p>
<p>&#x3D;&#x3D;并查集&#x3D;&#x3D;<strong>Union-Find Set</strong></p>
<p>一种<u>树型数据结构</u>，用于处理一些<font color=orange>不相交集合的合并及查询问题</font></p>
<p>在使用中常常以<strong>森林</strong>来表示，可以把<font color=orange>图中每个连通分量看成一个集合</font>，该集合包含了连通分量中的所有点，图的所有连通分量可以用若干个不相交的集合来表示</p>
<p>将编号分别为1…N的N个对象划分为不相交集合，在每个集合中，选择其中某个元素代表所在集合</p>
<p> 常见操作：</p>
<p>• <strong>合并</strong>两个集合</p>
<p>• <strong>查找</strong>某元素属于哪个集合</p>
<p>• <strong>判断</strong>两个元素是否属于同一个集合</p>
<p><strong>基本操作</strong>：</p>
<ul>
<li><p><code>make_set(x)</code>：把每一个元素初始化为一个集合【将每个元素的父结点初始化为自己】</p>
</li>
<li><p><code>find_set(x)</code>：查找一个元素所在的集合。在执行查找操作时，要沿着父结点指针一直找下去，直到找到树根为止</p>
</li>
<li><p><code>union_set(x, y)</code>：利用find_set()找到其中两个集合的祖先，将一个集合的祖先指向另一个集合的祖先</p>
</li>
</ul>
<p>判断两个元素是否属于同一集合，只要<strong>判断它们所在集合的祖先是否相同</strong>即可</p>
<p>合并两个集合，也是<strong>将一个集合的祖先作为另一个集合的祖先</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="D:\PersonalData\Mango\NEW\Blog\Hexo-blog\blog-mango\source\images\article\算法\tx-kruskal并查集基本操作.png" alt="image-20230316182352753"></p>
<p><strong>启发式策略优化</strong></p>
<p>两种启发式策略（<strong>按秩合并</strong>和<strong>路径压缩</strong>）</p>
<p>• **秩(Rank)**：表示结点高度的一个上界，树根的秩为0</p>
<p>• <code>union_set(x,y)</code><strong>时按秩合并</strong>，合并的时候将元素少的集合合并到元素多的集合中，这样合并之后树的高度会相对较小，即每个元素的秩相对较小</p>
<p>• <code>find_set(x)</code><strong>时路径压缩</strong>，当经过“递推”找到祖先结点后，“回溯”的时候顺便将它的子孙结点都直接指向祖先，以后再次find_set(x)时复杂度为O(1)</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="D:\PersonalData\Mango\NEW\Blog\Hexo-blog\blog-mango\source\images\article\算法\tx-kruskal并查集启发式策略优化.png" alt="image-20230316182712283" style="zoom:80%;" />

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">100</span>; <span class="comment">/*结点数目上线*/</span></span><br><span class="line"><span class="type">int</span> pa[MAXN]; <span class="comment">/*pa[x]表示x的父结点*/</span></span><br><span class="line"><span class="type">int</span> rank[MAXN]; <span class="comment">/*rank[x]是x的高度的一个上界*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*创建一个单元集*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">make_set</span><span class="params">(<span class="type">int</span> x)</span></span><br><span class="line">&#123;</span><br><span class="line">	pa[x] = x;</span><br><span class="line">	rank[x] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*带路径压缩的查找*/</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">find_set</span><span class="params">(<span class="type">int</span> x)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>(x != pa[x])</span><br><span class="line">		pa[x] = find_set(p[x]); <span class="comment">//将所有结点的父结点回溯为根结点</span></span><br><span class="line">	<span class="keyword">return</span> pa[x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*按秩合并x，y所在的集合*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">union_set</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span><br><span class="line">&#123;</span><br><span class="line">	x = find_set(x); <span class="comment">//返回x的根结点</span></span><br><span class="line">	y = find_set(y); <span class="comment">//返回y的根结点</span></span><br><span class="line">	<span class="keyword">if</span>(rank[x] &gt; rank[y])<span class="comment">/*让rank比较高的作为父结点*/</span></span><br><span class="line">		pa[y] = x;</span><br><span class="line">	<span class="keyword">else</span> </span><br><span class="line">	&#123;</span><br><span class="line">		pa[x] = y;</span><br><span class="line">		<span class="keyword">if</span>(rank[x] == rank[y]) rank[y]++;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&#x3D;&#x3D;Kruskal算法&#x3D;&#x3D;</p>
<p><strong>基本思想</strong>：<font color=orange>以边为主导地位</font>，始终<font color=orange>选择当前可用</font>（所选的边不能构成回路）<font color=orange>的最小权植边</font>，共选取(V-1)条边（V为顶点数）</p>
<p><strong>设计思路</strong>：</p>
<p>(1) 将<font color=orange>边按权值从小到大排序</font>后逐个判断，如果当前的边加入以后不会产生环，那么就把当前边作为生成树的一条边</p>
<p>(2) 最终得到的结果就是最小生成树</p>
<p>并查集</p>
<p><strong>问题描述</strong>：</p>
<p>某个热带岛屿上村与村之间通过一些丛林小道连接，这些丛林小道需要花费高昂的费用来维护。为了降低维护成本，首席长老决定召开会议，他要长老会的成员估算出每一条丛林小道每月的维护成本（如图所示），然后在这些丛林小道中选取若干条，<font color=skyblue>在保证所有村庄都连接的前提下使得每月所花费的总维护金额最小</font>。请编写一个程序计算维护连接所有村庄的道路系统每月所需最低成本。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="D:\PersonalData\Mango\NEW\Blog\Hexo-blog\blog-mango\source\images\article\算法\tx-kruskal丛林小道.png" alt="image-20230316184025290"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** 数据结构定义和初始化 **/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 定义边(x,y)，权为w */</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">edge</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> x, y;</span><br><span class="line">	<span class="type">int</span> w;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAX = <span class="number">26</span>;</span><br><span class="line">edge e[MAX * MAX];</span><br><span class="line"><span class="type">int</span> rank[MAX];<span class="comment">/* rank[x]表示x的秩 */</span></span><br><span class="line"><span class="type">int</span> father[MAX];<span class="comment">/* father[x]表示x的父节点 */</span></span><br><span class="line"><span class="type">int</span> sum; <span class="comment">/*存储最小生成树的总权重 */</span> </span><br><span class="line"></span><br><span class="line"><span class="comment">/* 比较函数，按权值非降序排序 */</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(<span class="type">const</span> edge a, <span class="type">const</span> edge b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> a.w &lt; b.w;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 并查集 **/</span></span><br><span class="line"><span class="comment">/* 初始化集合 */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">make_set</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	father[x] = x;</span><br><span class="line">	rank[x] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 查找x元素所在的集合,回溯时压缩路径 */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find_set</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (x != father[x])</span><br><span class="line">	&#123;</span><br><span class="line">		father[x] = <span class="built_in">find_set</span>(father[x]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> father[x];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 合并x,y所在的集合 */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">union_set</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> w)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (x == y) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span> (rank[x] &gt; rank[y])</span><br><span class="line">	&#123;</span><br><span class="line">		father[y] = x;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (rank[x] == rank[y])</span><br><span class="line">		&#123;</span><br><span class="line">			rank[y]++;</span><br><span class="line">		&#125;</span><br><span class="line">		father[x] = y;</span><br><span class="line">	&#125;</span><br><span class="line">	sum += w; <span class="comment">//记录权重</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 主函数 **/</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> i, j, k, m, n, t;</span><br><span class="line">	<span class="type">char</span> ch;</span><br><span class="line">	<span class="keyword">while</span>(cin &gt;&gt; m &amp;&amp; m != <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		k = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; m; i++) <span class="built_in">make_set</span>(i); <span class="comment">//初始化集合，m为顶点个数</span></span><br><span class="line">		<span class="comment">//对后m-1进行逐行处理</span></span><br><span class="line">		<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; m - <span class="number">1</span>; i++)</span><br><span class="line">		&#123;</span><br><span class="line">			cin &gt;&gt; ch &gt;&gt; n; <span class="comment">//获取字符（顶点）</span></span><br><span class="line">			<span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">			&#123;</span><br><span class="line">				cin &gt;&gt; ch &gt;&gt; e[k].w; <span class="comment">//获取权重</span></span><br><span class="line">				e[k].x = i;</span><br><span class="line">				e[k].y = ch - <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line">				k++;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; </span><br><span class="line">		<span class="built_in">sort</span>(e, e + k, cmp); <span class="comment">//STL中的函数，直接对数组进行排序</span></span><br><span class="line">		sum = <span class="number">0</span>; </span><br><span class="line">		<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; k; i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="type">int</span> result = <span class="built_in">union_set</span>(<span class="built_in">find_set</span>(e[i].x), <span class="built_in">find_set</span>(e[i].y), e[i].w);</span><br><span class="line">			<span class="keyword">if</span>(result) cout&lt;&lt; e[i].x + <span class="number">1</span>&lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; e[i].y + <span class="number">1</span> &lt;&lt;endl;</span><br><span class="line">		&#125; </span><br><span class="line">		cout &lt;&lt; sum &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>时间复杂度</strong>：</p>
<p>边排序所需时间：T(n) &#x3D; O(ElogE)</p>
<p>Kruskal算法的实现通常使用并查集来快速判断两个顶点是否属于同一个集合。<strong>最坏的情况可能要枚举完所有的边，此时要循环|E|次</strong>，所以这一步的时间复杂度为**O(Eα(V))**【采用路径压缩后，每一次查询所用的时间复杂度为增长极为缓慢的Ackerman函数的反函数——α(x) 】，其增长非常慢，可以视为常数</p>
<p><strong>T(n)&#x3D; O(Eα(V)) + O(ElogE) &#x3D; O(ElogE)</strong> -&gt; <strong>稀疏图</strong></p>
<h4 id="最小生成树——Dijkstra算法O-V-2"><a href="#最小生成树——Dijkstra算法O-V-2" class="headerlink" title="最小生成树——Dijkstra算法O(V$_2$)"></a>最小生成树——Dijkstra算法O(V$_2$)</h4><p><strong>快递员路线规划</strong>：</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="D:\PersonalData\Mango\NEW\Blog\Hexo-blog\blog-mango\source\images\article\算法\tx-dijkstra快递员路线规划.png" alt="image-20230316184851141" style="zoom:80%;" />

<h4 id="单源最短路径问题"><a href="#单源最短路径问题" class="headerlink" title="单源最短路径问题"></a>单源最短路径问题</h4><p><strong>最短路径问题类型</strong></p>
<p> <strong>单源最短路径</strong>问题（<code>Dijkstra算法</code>、Bellman-Ford算法、SPFA算法……）</p>
<p> <strong>单终点最短路径</strong>问题 (<code>Dijkstra算法</code>……)</p>
<p> <strong>单对顶点最短路径</strong>问题 (<code>Dijkstra算法</code>……)</p>
<p> <strong>每对顶点间最短路径</strong>问题（<code>Dijkstra算法</code>、Floyd-Warshall算法……）</p>
<p><strong>最短路径</strong>定义：</p>
<ul>
<li><strong>非网图</strong>：最短路径是指两顶点之间经历的<font color=orange>边数最少</font>的路径</li>
<li><strong>网图</strong>：最短路径是指两顶点之间经历的<font color=orange>边上权值之和最小</font>的路径</li>
</ul>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="D:\PersonalData\Mango\NEW\Blog\Hexo-blog\blog-mango\source\images\article\算法\tx-dijkstra-最短路径.png" alt="image-20230316185519630" style="zoom:80%;" />

<p>&#x3D;&#x3D;单源最短路径&#x3D;&#x3D;问题描述：给定带权有向图G＝(V, E)和源点v∈V，求从v到G中其余各顶点的最短路径</p>
<p><strong>基本思想</strong>：</p>
<p> Dijkstra算法：一个 <u>按路径长度递增的次序</u> 产生最短路径的算法，它用于求解<font color=orange>单源最短路径问题</font>，所求解的图中<font color=orange>不能包含负权边</font></p>
<p> <font color=orange>每次新扩展一个距离最短的点，更新与其相邻的点的距离</font></p>
<p> 当<font color=orange>所有边权都为正</font>时，由于<font color=orange>不会存在一个距离更短的没扩展过的点</font>，所以这个点的距离永远不会再被改变，保证了算法的正确性</p>
<p> 有向图和无向图都可以使用本算法，无向图中的每条边可以看成相反的两条边</p>
<p> 用来求最短路径的<font color=orange>图中不能存在负权边</font></p>
<p> 引入了<strong>松弛(Relaxation)操作</strong>：先让源点s到顶点i的距离d[i]取一个很大的值，然后不断减小d[i]，当所有的d[i]不能再减小时，就求出了s到所有点的最短路径。<font color=orange>松弛操作的目的是减小d[i]的值，如果从s到达i有更优的路径则更新d[i]</font></p>
<p><strong>算法流程</strong> 及演示：</p>
<table>
<thead>
<tr>
<th>s为源，w[u,v]为点u和v之间的边的长度，结果保存在dist[]中</th>
</tr>
</thead>
<tbody><tr>
<td>(1) <strong>初始化</strong>：源的距离dist[s]设为0，其他的点距离设为无穷大，同时把所有的点的状态都设置为没有扩展过。<br>(2) <strong>循环n-1次</strong>：<br> &amp;nbsp;(2.1) 在没有扩展过的点中取一距离最小的点u，并将其状态设为已扩展。<br>&amp;nbsp; (2.2) 对于每个与u相邻的点v，执行relax(u,v)，也就是说，如果dist[u]+w[u,v]&lt;dist[v]，那么把dist[v]更新成更短的距离dist[u]+w[u,v]。此时到点v的最短路径上，前一个节点即为u。<br>(3) <strong>结束</strong>：此时对于任意的u，dist[u]就是s到u的距离。</td>
</tr>
</tbody></table>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="D:\PersonalData\Mango\NEW\Blog\Hexo-blog\blog-mango\source_posts\2023\20230304-算法.assets\image-20230316191251816.png" alt="image-20230316191251816"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 求1到N的最短路,dis[i]表示第i个点到第一个点的最短路 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">dijkstra</span><span class="params">()</span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="comment">//初始化距离数组</span></span><br><span class="line">		dis[i] = <span class="built_in">map</span>[<span class="number">1</span>][i]; </span><br><span class="line">		<span class="type">int</span> k;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">		<span class="type">int</span> tmin = maxint;</span><br><span class="line">		<span class="comment">//找出未访问点中距离值最小的点k，标记其为访问过</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">			<span class="keyword">if</span>( !used[j] &amp;&amp; dis[j] &lt; tmin)&#123;</span><br><span class="line">				tmin = dis[j];</span><br><span class="line">				k = j; </span><br><span class="line">			&#125; </span><br><span class="line">		used[k] = <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">			<span class="comment">//对找出的点的相邻边进行松弛操作</span></span><br><span class="line">		<span class="keyword">if</span>( dis[k] + <span class="built_in">map</span>[k][j] &lt; dis[j]) </span><br><span class="line">			dis[j] = dis[k] + <span class="built_in">map</span>[k][j];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编写一个程序实现Dijkstra算法</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="D:\PersonalData\Mango\NEW\Blog\Hexo-blog\blog-mango\source\images\article\算法\tx-dijkstra.png" alt="image-20230316191856347" style="zoom:80%;" />

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX 100</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INF 100000</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Graph</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> edges[MAX][MAX]; <span class="comment">//邻接矩阵</span></span><br><span class="line">	<span class="type">int</span> n; <span class="comment">//顶点数</span></span><br><span class="line">	<span class="type">int</span> e; <span class="comment">//边数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> visited[MAX]; <span class="comment">//标记顶点是否被访问过</span></span><br><span class="line"><span class="type">int</span> dis[MAX]; <span class="comment">//dis[i]存储结点0到i的最短距离</span></span><br><span class="line">Graph G;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">creatGraph</span><span class="params">()</span> <span class="comment">//用引用作参数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> i,j;</span><br><span class="line">	<span class="type">int</span> s,t; <span class="comment">//存储顶点编号</span></span><br><span class="line">	<span class="type">int</span> v; <span class="comment">//存储边的权值</span></span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;G.n;i++) <span class="comment">//初始化</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;G.n;j++)</span><br><span class="line">		&#123;</span><br><span class="line">			G.edges[i][j]=INF; <span class="comment">//注意：初始值为无穷大 ！！！</span></span><br><span class="line">		&#125;</span><br><span class="line">		visited[i]=<span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;G.e;i++) <span class="comment">//对矩阵相邻的边赋权值</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d&quot;</span>,&amp;s,&amp;t,&amp;v); <span class="comment">//输入边的顶点编号以及权值</span></span><br><span class="line">		G.edges[s<span class="number">-1</span>][t<span class="number">-1</span>] = v;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Dijkstra</span><span class="params">()</span> <span class="comment">//求最短路径</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; G.n; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		dis[i] = INF;</span><br><span class="line">	&#125; </span><br><span class="line">    </span><br><span class="line">	dis[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; G.n; i++)</span><br><span class="line">	&#123;<span class="comment">//每次在还未确定最短路的点中，取一个当前已得到的所有可能的路径长度中最短的那个点，设此点为mark，然后对所有与mark相连的点进行松弛操作</span></span><br><span class="line">		<span class="type">int</span> mark = <span class="number">-1</span>, mindis = INF;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; G.n; j++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (!visited[j] &amp;&amp; dis[j] &lt; mindis)</span><br><span class="line">			&#123;</span><br><span class="line">				mindis = dis[j];</span><br><span class="line">				mark = j; </span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">        </span><br><span class="line">		visited[mark] = <span class="literal">true</span>;</span><br><span class="line">        </span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; G.n; k++)</span><br><span class="line">		&#123;</span><br><span class="line">			dis[k] = <span class="built_in">min</span>(dis[k], dis[mark] + G.edges[mark][k]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> n,e; <span class="comment">//建立的图的顶点数和边数</span></span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>,&amp;n,&amp;e)==<span class="number">2</span>&amp;&amp;n&gt;<span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		G.n=n;</span><br><span class="line">		G.e=e;</span><br><span class="line">		<span class="built_in">creatGraph</span>();</span><br><span class="line">		<span class="built_in">Dijkstra</span>();</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">0</span>; k &lt; G.n; k++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, dis[k]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>时间复杂度</strong>：</p>
<p> T(n) &#x3D; O(V$_2$)</p>
<p> 如果用<strong>二叉堆</strong>(Binary Heap)优化可以达到<strong>O((E+V)logV)</strong></p>
<p> 用<strong>斐波那契堆</strong>(Fibonacci Heap)可以优化到<strong>O(VlogV+E)</strong> </p>
<h2 id="算法——回溯法【DFS-剪枝】"><a href="#算法——回溯法【DFS-剪枝】" class="headerlink" title="算法——回溯法【DFS+剪枝】"></a>算法——回溯法【DFS+剪枝】</h2><p>&#x3D;&#x3D;<strong>DFS+剪枝</strong>&#x3D;&#x3D; 回溯法将问题的解空间转化成<strong>图或者树的结构表示</strong>，然后以<strong>深度优先</strong>的方式搜索解</p>
<p>空间，并且在搜索过程中用<strong>剪枝函数</strong>避免无效搜索</p>
<p><u>牧羊人过河问题</u>：</p>
<p>有一个牧羊人带着一头羊、一只狼和一颗大白菜准备过河，他找到一只很小的船，每次只能带一样东西过去，可是如果让狼与羊单独在一起，狼会吃羊；让羊与白菜单独在一起，羊会吃白菜，牧羊人应如何过河？请设计一个过河方案。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="D:\PersonalData\Mango\NEW\Blog\Hexo-blog\blog-mango\source\images\article\算法\hs-牧羊人过河.png" alt="image-20230316193650570"></p>
<p><strong>一个可行解：</strong></p>
<p>• (1) 牧羊人带羊从河西到河东</p>
<p>• (2) 牧羊人不带任何东西从河东到河西</p>
<p>• (3) 牧羊人带狼从河西到河东</p>
<p>• (4) 牧羊人带羊从河东到河西</p>
<p>• (5) 牧羊人带白菜从河西到河东</p>
<p>• (6) 牧羊人不带任何东西从河东到河西</p>
<p>• (7) 牧羊人带羊从河西到河东</p>
<p>&#x3D;&#x3D;迷宫问题&#x3D;&#x3D;</p>
<p>输入一个n×n的迷宫，定义左上角为起点，右下角为终点，寻找一条从起点到终点的路径。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="D:\PersonalData\Mango\NEW\Blog\Hexo-blog\blog-mango\source\images\article\算法\hs-迷宫问题.png" alt="image-20230316194046592"></p>
<p><strong>回溯法基本思想</strong>：</p>
<p><strong>回溯法：</strong>“<u>通用解题法</u>”，又称为<strong>试探法</strong></p>
<p>从问题的<font color=orange>某一种状态（初始状态）</font>出发，搜索从这种状态出发所能达到的所有“状态”，当一条路<font color=orange>走到“尽头”</font>的时候（不能再前进），再<font color=orange>后退一步或若干步</font>，从另一种可能“状态”出发，继续搜索，直到所有的“路径”（状态）都试探过。这种<font color=orange>不断“前进”、不断“回溯”寻找解</font>的方法，就称为“回溯法”。</p>
<p><strong>回溯法的应用步骤</strong></p>
<p>(1) 针对所给问题，<u>定义问题的解空间</u></p>
<p>(2) 确定易于搜索的<u>解空间结构</u></p>
<p>(3) 以<u>深度优先</u>的方式搜索解空间，并且在搜索过程中用<u>剪枝函数</u>避免无效搜索</p>
<p><strong>常用剪枝函数</strong></p>
<ul>
<li><p>用<code>约束(Constraint)函数</code>在扩展结点处剪去不满足约束的子树</p>
</li>
<li><p>用<code>限界(Bound)函数</code>剪去得不到最优解的子树</p>
</li>
</ul>
<p><strong>问题的解空间</strong></p>
<p> <strong>定义</strong>问题的解空间</p>
<p>• 例：0-1 背包问题——对于有n种物品的，其解空间由长度为n的0-1向量组成，该解空间包含了对变量的所有可能的0-1赋值</p>
<p>• 当 n&#x3D;3 时，其解空间为{ (0, 0, 0), (0, 0, 1), (0, 1, 0), (0, 1, 1), (1, 0, 0), </p>
<p>(1, 0, 1), (1, 1, 0), (1, 1, 1) }</p>
<p> <strong>组织</strong>问题的解空间</p>
<p>• 通常将解空间组织成<strong>树或图</strong>的形式</p>
<p>• 例：对于n&#x3D; 3的0-1背包问题，其解空间可以用一棵<code>完全二叉树</code>表示</p>
<p>• <font color=orange>从树根到叶子结点的任意一条路径可表示解空间中的一个元素</font>，例如某一条路径为(1, 0, 1)，该路径对应解空间中的元素(1, 0, 1)</p>
<p><strong>回溯法解题的关键要素</strong></p>
<ul>
<li><p>回溯法将从<font color=orange>开始结点(根结点)</font>出发，以<font color=orange>深度优先</font>的方式搜索整个解空间</p>
</li>
<li><p>开始结点成为<font color=orange>活结点</font>，同时也成为<font color=orange>扩展结点</font></p>
</li>
<li><p>在当前的扩展结点处，<strong>向纵深方向搜索并移至一个新结点，这个新结点就成为一个新的活结点</strong>，并成为当前的扩展结点</p>
</li>
<li><p>如果<strong>在当前的扩展结点处不能再向纵深方向移动，则当前的扩展结点就成为死结点</strong>，此时应往回移动<font color=orange>（回溯）至最近的一个活结点</font>处，并使其成为当前的扩展结点</p>
</li>
<li><p>回溯法以上述工作方式递归地在解空间中搜索，<strong>直至找到所要求的解或解空间中已无活结点时为止</strong></p>
</li>
</ul>
<p>&#x3D;&#x3D;搜索框架&#x3D;&#x3D;</p>
<p>回溯法对解空间开展<strong>深度优先</strong>搜索；在一般情况下用<code>递归(DFS)</code>方法实现回溯法</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">backtrack</span> <span class="params">(<span class="type">int</span> t)</span> <span class="comment">// t：递归深度</span></span><br><span class="line">&#123; </span><br><span class="line">	<span class="keyword">if</span> (t&gt;n) output(x); <span class="comment">//当搜索到叶结点，输出可行解</span></span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i=f(n,t); i&lt;=g(n,t); i++) <span class="comment">//从下界 to 上界</span></span><br><span class="line">		&#123; </span><br><span class="line">			x[t]=h(i);</span><br><span class="line">			<span class="keyword">if</span> (Constraint(t) &amp;&amp; Bound(t)) <span class="comment">//满足约束条件和限界函数</span></span><br><span class="line">				backtrack(t+<span class="number">1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&#x3D;&#x3D;子集树&#x3D;&#x3D;：从n个元素的集合找出满足某种性质的子集，相应的解空间树称为子集树</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="D:\PersonalData\Mango\NEW\Blog\Hexo-blog\blog-mango\source\images\article\算法\hs-子集树.png" alt="image-20230316195355236" style="zoom:80%;" />

<p>&#x3D;&#x3D;排列树&#x3D;&#x3D;：确定n个元素满足某种性质的排列，相应的解空间树称为排列树</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="D:\PersonalData\Mango\NEW\Blog\Hexo-blog\blog-mango\source\images\article\算法\hs-排列树.png" alt="image-20230316195519776" style="zoom:80%;" />

<p>回溯法<strong>主要用途</strong>：</p>
<ul>
<li><p><font color=orange>求问题所有解</font>：要回溯到根，且根结点的所有子树都已被搜索才结束</p>
</li>
<li><p><font color=orange>求问题的最优解</font>：在所有解中找出具有最优值的解，所有子树都已被搜索才结束</p>
</li>
<li><p><font color=orange>求任一解</font>：只要搜索到问题的一个解就可结束</p>
</li>
</ul>
<h3 id="油田问题"><a href="#油田问题" class="headerlink" title="油田问题"></a>油田问题</h3><p>输入一个m行n列的字符矩阵，统计字符“@”组成多少个八连块。如果两个字符“@”所在的格子相邻（横、竖或者对角线方向），即属于同一个八连块。例如：下图有两个八连块</p>
<table>
<thead>
<tr>
<th>搜索策略</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>从每个“@”格子出发，递归遍历它周围的“@”格子</td>
<td><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="D:\PersonalData\Mango\NEW\Blog\Hexo-blog\blog-mango\source_posts\2023\20230304-算法.assets\hs-油田.png" alt="image-20230316200202672"></td>
</tr>
<tr>
<td>每次访问一个格子时就给它写上一个“连通分量编号idx”</td>
<td></td>
</tr>
<tr>
<td>可以在访问之前检查它是否已经有了编号，从而避免同一个格子访问多次</td>
<td></td>
</tr>
</tbody></table>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">105</span>;</span><br><span class="line"><span class="type">char</span> pic[maxn][maxn] = &#123;<span class="string">&quot;****@&quot;</span>,<span class="string">&quot;*@@*@&quot;</span>,<span class="string">&quot;*@**@&quot;</span>,<span class="string">&quot;@@@*@&quot;</span>,<span class="string">&quot;@@**@&quot;</span>&#125;;</span><br><span class="line"><span class="type">int</span> m = <span class="number">5</span>, n = <span class="number">5</span>,idx[maxn][maxn];</span><br><span class="line"><span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">slove</span><span class="params">(<span class="type">int</span> r, <span class="type">int</span> c, <span class="type">int</span> id)</span> &#123;</span><br><span class="line">	<span class="keyword">if</span>(r&lt;<span class="number">0</span>||r&gt;=m||c&lt;<span class="number">0</span>||c&gt;=n) <span class="keyword">return</span>;</span><br><span class="line">	<span class="keyword">if</span>(idx[r][c]&gt;<span class="number">0</span> || pic[r][c]!=<span class="string">&#x27;@&#x27;</span>) <span class="keyword">return</span>;</span><br><span class="line">	idx[r][c] = id;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> dr=<span class="number">-1</span>; dr&lt;=<span class="number">1</span>; dr++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> dc=<span class="number">-1</span>;dc&lt;=<span class="number">1</span>;dc++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(dr!=<span class="number">0</span>||dc!=<span class="number">0</span>) slove(r+dr, c+dc, id);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="built_in">memset</span>(idx,<span class="number">0</span>,<span class="keyword">sizeof</span>(idx));</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;m;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;n;j++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(idx[i][j]==<span class="number">0</span>&amp;&amp;pic[i][j]==<span class="string">&#x27;@&#x27;</span>) slove(i,j,++cnt);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,cnt);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="马的遍历问题"><a href="#马的遍历问题" class="headerlink" title="马的遍历问题"></a>马的遍历问题</h3><p>在n*m的棋盘中，马只能走斜“日”字。马从位置(x, y)处出发，把棋盘的每一格都走一次，且只走一次，请找出所有路径。</p>
<p><strong>算法设计</strong>：</p>
<p><strong>问题解的搜索空间：</strong>棋盘的规模是n*m，搜索空间是整个棋盘上的n*m个点，用n*m的二维数组记录马行走的过程，初值为0表示未经过</p>
<p><strong>在寻找路径过程中，活结点的扩展规则：</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="D:\PersonalData\Mango\NEW\Blog\Hexo-blog\blog-mango\source\images\article\算法\hs-马的遍历.png" alt="image-20230316221214376"></p>
<p><strong>扩展的约束条件：</strong></p>
<p>• <font color=orange>不出边界</font></p>
<p>• <font color=orange>每个点只经过一次</font></p>
<p>• 函数check()，检查当前状态是否合理</p>
<p>棋盘点对应的数组元素初值为0，对走过的棋盘点的值置为所走步数，<font color=orange>起点存储“1” ，终点存储“n*m”</font></p>
<p><strong>搜索解空间：</strong></p>
<p>• 搜索过程是从任一点(x, y)出发，按深度优先的原则，从8个方向中尝试一个可以走的棋盘点，直到走过棋盘上所有n*m个点</p>
<p>• 用一个<font color=orange>变量dep记录递归深度</font>，也就是走过的点数，当dep&#x3D;&#x3D;n*m时，找到一组解</p>
<p>• 用<font color=orange>n*m的二维数组记录马行走的过程</font>，初始值为0表示未经过。搜索完毕后，起点存储的是“1”，终点存储的是“n*m”</p>
<p>• 可使用<font color=orange>递归</font>实现</p>
<p>• <strong>注意：</strong>问题要求找出全部可能的解，需注意回溯过程的清理现场工作，即置当前位置为未经过</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> n=<span class="number">5</span>,m=<span class="number">4</span>;</span><br><span class="line"><span class="type">int</span> fx[<span class="number">8</span>]=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">-1</span>,<span class="number">-2</span>,<span class="number">-2</span>,<span class="number">-1</span>&#125;;</span><br><span class="line"><span class="type">int</span> fy[<span class="number">8</span>]=&#123;<span class="number">2</span>,<span class="number">1</span>,<span class="number">-1</span>,<span class="number">-2</span>,<span class="number">-2</span>,<span class="number">-1</span>,<span class="number">1</span>,<span class="number">2</span>&#125;;</span><br><span class="line"><span class="type">int</span> A[n+<span class="number">1</span>][m+<span class="number">1</span>]; <span class="comment">//下标从1开始</span></span><br><span class="line"><span class="type">int</span> dep,x,y,numbers=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(x&gt;=<span class="number">1</span> &amp;&amp; x&lt;=n &amp;&amp; y&gt;=<span class="number">1</span> &amp;&amp; y&lt;=m &amp;&amp;(!A[x][y]) )</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">output</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> x=<span class="number">1</span>;x&lt;=n;x++)</span><br><span class="line">	&#123;</span><br><span class="line">		cout&lt;&lt;endl;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> y=<span class="number">1</span>;y&lt;=m;y++)</span><br><span class="line">			cout&lt;&lt;A[x][y]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	cout&lt;&lt;endl;</span><br><span class="line">	cout&lt;&lt;<span class="string">&quot;----------------------------&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y,<span class="type">int</span> dep)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> i,xx,yy;</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;=<span class="number">7</span>;i++) <span class="comment">//加上方向增量，形成新的坐标</span></span><br><span class="line">	&#123;</span><br><span class="line">		xx=x+fx[i];</span><br><span class="line">		yy=y+fy[i];</span><br><span class="line">		<span class="keyword">if</span>(<span class="built_in">check</span>(xx,yy)) <span class="comment">//判断新坐标是否出界，是否已走过</span></span><br><span class="line">		&#123;</span><br><span class="line">			A[xx][yy]=dep;</span><br><span class="line">			<span class="keyword">if</span>(dep==n*m)</span><br><span class="line">			&#123;</span><br><span class="line">				numbers++;</span><br><span class="line">				<span class="built_in">output</span>();</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				<span class="built_in">solve</span>(xx,yy,dep+<span class="number">1</span>);</span><br><span class="line">			A[xx][yy]=<span class="number">0</span>; <span class="comment">//回溯，恢复未走</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> i,j;</span><br><span class="line">	dep=<span class="number">1</span>;</span><br><span class="line">	cout&lt;&lt;<span class="string">&quot;Please input x,y&quot;</span>&lt;&lt;endl;</span><br><span class="line">	cin&gt;&gt;x&gt;&gt;y;</span><br><span class="line">	<span class="keyword">if</span>(x&gt;n||y&gt;m||x&lt;<span class="number">1</span>||y&lt;<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		cout&lt;&lt;<span class="string">&quot;Input error!&quot;</span>;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">		<span class="keyword">for</span>(j=<span class="number">1</span>;j&lt;=m;j++)</span><br><span class="line">			A[i][j]=<span class="number">0</span>;</span><br><span class="line">	</span><br><span class="line">    A[x][y]=<span class="number">1</span>;</span><br><span class="line">	<span class="built_in">solve</span>(x,y,<span class="number">2</span>);</span><br><span class="line">	<span class="keyword">if</span>(numbers==<span class="number">0</span>) cout&lt;&lt;<span class="string">&quot;No solution!&quot;</span>;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		cout&lt;&lt;endl;</span><br><span class="line">		cout&lt;&lt;<span class="string">&quot;Number of solution(s)=&quot;</span>&lt;&lt;numbers&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="N皇后问题"><a href="#N皇后问题" class="headerlink" title="N皇后问题"></a>N皇后问题</h3><p>在Ｎ*Ｎ的棋盘上放置Ｎ个皇后，要求每一行、每一列、每一条对角线上均只能放置一个皇后，求可能的方案及方案数。</p>
<p>• 问题的状态即棋盘的布局状态，<font color=greenblue>状态空间树的根为空棋盘</font>，每个布局的下一步可能布局为该布局结点的子结点</p>
<p>• <font color=greenblue>任意两个王后不放在同一行或同一列或同一斜线</font></p>
<p>• 为了简化状态空间树，采用<font color=greenblue>逐行布局</font>的方式，即每个布局有n个子结点</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="D:\PersonalData\Mango\NEW\Blog\Hexo-blog\blog-mango\source\images\article\算法\hs-N皇后问题.png" alt="image-20230316222322363"></p>
<p><strong>回溯过程分析</strong>：</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="D:\PersonalData\Mango\NEW\Blog\Hexo-blog\blog-mango\source\images\article\算法\hs-N皇后-回溯过程.png" alt="image-20230316222443555" style="zoom:70%;" />

<p><strong>数据结构分析</strong>：</p>
<p>二维数组**A[N][N]**存储皇后位置</p>
<p>• 若第i行第j列放有皇后，则A[i][j]为非0值，否则值为0</p>
<p>一维数组**M[k]、L[k]、R[k]**分别表示竖列、左斜线、右斜线是否放有皇后，有则值为1，否则值为0</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="D:\PersonalData\Mango\NEW\Blog\Hexo-blog\blog-mango\source\images\article\算法\hs-N皇后-数据结构分析1.png" alt="image-20230316224739861"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="D:\PersonalData\Mango\NEW\Blog\Hexo-blog\blog-mango\source\images\article\算法\hs-N皇后-数据结构分析2.png" alt="image-20230316224939690"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="D:\PersonalData\Mango\NEW\Blog\Hexo-blog\blog-mango\source\images\article\算法\hs-N皇后-数据结构分析3.png" alt="image-20230316225140618"></p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="D:\PersonalData\Mango\NEW\Blog\Hexo-blog\blog-mango\source\images\article\算法\hs-N皇后-数据结构分析4.png" alt="image-20230316225227651" style="zoom:80%;" />

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"># 算法描述</span><br><span class="line"></span><br><span class="line">初始化</span><br><span class="line"><span class="keyword">for</span>(某一行的每个位置)</span><br><span class="line">	<span class="keyword">if</span> (安全检测通过)</span><br><span class="line">	&#123;</span><br><span class="line">		放皇后;</span><br><span class="line">		<span class="keyword">if</span> (已到最后一行) &#123; 输出; &#125;</span><br><span class="line">		<span class="keyword">else</span> 试探下一行;</span><br><span class="line">			去皇后;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">安全检测算法：!M[j] &amp;&amp; !R[i-j+N] &amp;&amp; !L[i+j];</span><br><span class="line">放皇后：A[i][j] = M[j] = R[i-j+N] = L[i+j] = <span class="number">1</span>;   </span><br><span class="line">去皇后：A[i][j] = M[j] = R[i-j+N] = L[i+j] = <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*****************核心代码**********************/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 4 <span class="comment">/*N为皇后个数*/</span></span></span><br><span class="line"><span class="type">int</span> count=<span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> M[N]=&#123;<span class="number">0</span>&#125;,L[<span class="number">2</span>*N]=&#123;<span class="number">0</span>&#125;,R[<span class="number">2</span>*N]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="type">int</span> A[N][N]=&#123;<span class="number">0</span>&#125;; <span class="comment">/*皇后位置*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">int</span> A[N][N])</span> <span class="comment">/*输出*/</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> i,j;</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;N;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;N;j++)</span><br><span class="line">			cout&lt;&lt;A[i][j]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">		cout&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*试探每一行皇后的位置*/</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">solve</span><span class="params">(<span class="type">int</span> i,<span class="type">int</span> M[N],<span class="type">int</span> L[<span class="number">2</span>*N],<span class="type">int</span> R[<span class="number">2</span>*N],<span class="type">int</span> A[N][N])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>; j&lt;N;j++) <span class="comment">//放置在i行j列</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(!M[j]&amp;&amp;!L[i-j+N]&amp;&amp;!R[i+j]) <span class="comment">//安全检查</span></span><br><span class="line">		&#123;</span><br><span class="line">			A[i][j]=i+<span class="number">1</span>; <span class="comment">//放皇后</span></span><br><span class="line">			M[j]=L[i-j+N]=R[i+j]=<span class="number">1</span>;</span><br><span class="line">			<span class="keyword">if</span>(i==N<span class="number">-1</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="built_in">print</span>(A); cout&lt;&lt;endl; count++;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> <span class="built_in">solve</span>(i+<span class="number">1</span>,M,L,R,A); <span class="comment">//试探下一行</span></span><br><span class="line">			A[i][j]=<span class="number">0</span>; <span class="comment">//去皇后</span></span><br><span class="line">			M[j]=L[i-j+N]=R[i+j]=<span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> n=<span class="built_in">solve</span>(<span class="number">0</span>,M,L,R,A); <span class="comment">//代表从0行开始试探</span></span><br><span class="line">	cout&lt;&lt;<span class="string">&quot;\n count=&quot;</span>&lt;&lt;n; <span class="comment">//n可行解数目</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>素数环问题：</strong>将从1到n这n个整数围成一个圆环，若其中任意2个相邻的数字相加，结果均为素数，那么这个环就成为素数环。</p>
<p>输入一个正整数n(n&lt;&#x3D;16)，输出所有的素数环。</p>
</blockquote>
<h3 id="图的m着色问题O-m-n"><a href="#图的m着色问题O-m-n" class="headerlink" title="图的m着色问题O(m$^n$)"></a>图的m着色问题O(m$^n$)</h3><p><code>四色问题</code>又称<code>四色猜想、四色定理</code>，是世界近代三大数学难题之一。四色问题的内容是“任何一张地图只用四种颜色就能使具有共同边界的国家着上不同的颜色。”</p>
<p>图的m着色问题 &#x3D;&gt; 研究如何用m种颜色为地图着色</p>
<p>问题描述：</p>
<p>给定<strong>无向连通图G</strong>和<strong>m种不同的颜色</strong>，用这些颜色为图G的各顶点着色，每个顶点着一种颜色。</p>
<p><font color=orange>如果有一种着色方案使G中每条边的两个顶点着不同颜色，则称这个图是m可着色的</font>。</p>
<p>图的m着色问题是对于给定图G和m种颜色，找出所有不同的着色方案，使得图G中任意一条边的两个顶点着不同的颜色。</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="D:\PersonalData\Mango\NEW\Blog\Hexo-blog\blog-mango\source\images\article\算法\hs-图的m着色.png" alt="image-20230316230243776" style="zoom:80%;" />

<p><strong>设计思路</strong>:</p>
<p>【数据结构设计】</p>
<ul>
<li>邻接矩阵（二维数组）：存储图graph[N+1][N+1]</li>
<li>一维数组：存储每个节点的颜色colors[N+1]，colors[t]&#x3D;i表示节点t的颜色为i</li>
</ul>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="D:\PersonalData\Mango\NEW\Blog\Hexo-blog\blog-mango\source\images\article\算法\hs-图的m着色数据结构设计.png" alt="image-20230316230605847" style="zoom: 67%;" />

<p>【解空间树】</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="D:\PersonalData\Mango\NEW\Blog\Hexo-blog\blog-mango\source\images\article\算法\hs-图的m着色-解空间树.png" alt="image-20230316230757911"></p>
<p>【剪枝函数设计】</p>
<p>如何判断是否能够着色？新加入的节点t取某一种颜色i时，依次和上层的每一个节点j(j&lt;t)比较。如果graph[t][j]&#x3D;1并且colors[j]&#x3D;i，那么它是不可着色的。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">check</span><span class="params">(<span class="type">int</span> t,<span class="type">int</span> i)</span> <span class="comment">//剪枝函数</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> j;</span><br><span class="line">	<span class="keyword">for</span>( j=<span class="number">1</span>;j&lt;t;j++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(graph[t][j]&amp;&amp;colors[j]==i)</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="D:\PersonalData\Mango\NEW\Blog\Hexo-blog\blog-mango\source\images\article\算法\hs-图的m着色-搜索函数设计.png" alt="image-20230316231254219" style="zoom:70%;" />

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/******************核心代码********************/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">backtrace</span><span class="params">(<span class="type">int</span> t,<span class="type">int</span> m)</span> <span class="comment">//递归函数</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">	<span class="keyword">if</span>(t&gt;N)<span class="comment">//算法搜索至叶子节点</span></span><br><span class="line">	&#123;</span><br><span class="line">		sum++;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;第%d种方案：\n&quot;</span>,sum);</span><br><span class="line">		<span class="keyword">for</span>( i=<span class="number">1</span>;i&lt;=N;i++)</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,colors[i]);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=m;i++) &#123;</span><br><span class="line">			<span class="keyword">if</span>(check(t,i)) &#123;</span><br><span class="line">				colors[t]=i;</span><br><span class="line">				backtrace(t+<span class="number">1</span>,m);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> <span class="comment">//主函数</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> m;</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;请输入颜色种类：\n&quot;</span>);</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;m);</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=m;i++) <span class="comment">//初始化</span></span><br><span class="line">		colors[i]=<span class="number">0</span>;</span><br><span class="line">	backtrace(<span class="number">1</span>,m);</span><br><span class="line">	<span class="keyword">if</span>(sum==<span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;不是%d可着色的!\n&quot;</span>,m);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>时间复杂度分析</strong></p>
<p>对于算法中的每个顶点可试探<strong>1-m种颜色</strong>，一共有<strong>n个顶点</strong></p>
<p>对应的解空间树是<strong>一颗高为n的m叉树</strong>（子集树）</p>
<p>时间复杂度为：<strong>T(n) &#x3D; O(m$^n$)</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="D:\PersonalData\Mango\NEW\Blog\Hexo-blog\blog-mango\source\images\article\算法\hs-图的m着色-T.png" alt="image-20230316231710993"></p>
<h3 id="0-1背包问题O-n2-n"><a href="#0-1背包问题O-n2-n" class="headerlink" title="0-1背包问题O(n2$^n$)"></a>0-1背包问题O(n2$^n$)</h3><p>0-1背包问题 物品重量可能不是正整数? 背包容量可能不是正整数?</p>
<p>给定n种物品（每种物品只有一件）和一个背包：物品i的重量是w$_i$ ，其价值为v$_i$ ，背包的容量为C。问应如何选择装入背包的物品，使得装入背包中物品的总价值最大?</p>
<p> 对于每种物品，<font color=orange>只有两种选择：拿(1)或者不拿(0)，不允许拿物品的一部分</font></p>
<p> 物品重量和背包容量可为<font color=orange>正整数或小数</font><br>$$<br>\begin{aligned}<br> \left { \begin{aligned}<br>       \sum_{i&#x3D;1}^nw_ix_i \leq C \<br>        x_i \in{0,1},1 \leq i \leq n<br>       \end{aligned}<br> \right .							%加右}<br> \qquad \text max \sum_{i&#x3D;1}^nv_ix_i<br>\end{aligned}<br>$$<br><strong>算法设计</strong>：</p>
<p>解空间：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="D:\PersonalData\Mango\NEW\Blog\Hexo-blog\blog-mango\source_posts\2023\20230304-算法.assets\hs-01背包解空间-子集树.png"></p>
<p>基本思想：</p>
<p>按贪心算法的思路，优先装入<font color=orange>价值&#x2F;重量比</font>大的物品</p>
<p>当剩余容量装不下后续考虑的物品时，再用回溯法修改先前的装入方案</p>
<p>直到求得全局最优解为止</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 核心代码</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*数据结构*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 5 <span class="comment">//物品数目</span></span></span><br><span class="line"><span class="type">int</span> v[]=&#123;<span class="number">6</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">5</span>,<span class="number">4</span>&#125;,w[]=&#123;<span class="number">2</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">5</span>&#125;;</span><br><span class="line"><span class="type">int</span> C=<span class="number">10</span>; <span class="comment">//背包容量</span></span><br><span class="line"><span class="type">int</span> cv; <span class="comment">//当前价值</span></span><br><span class="line"><span class="type">int</span> bestv=<span class="number">0</span>; <span class="comment">//最优价值</span></span><br><span class="line"><span class="type">int</span> x[N]; <span class="comment">//当前解</span></span><br><span class="line"><span class="type">int</span> bestx[N]; <span class="comment">//当前最优解</span></span><br><span class="line"><span class="type">int</span> cw=<span class="number">0</span>; <span class="comment">//当前重量</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//输出</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">display</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout&lt;&lt;<span class="string">&quot;物品放入背包状态为：&quot;</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;N;i++)</span><br><span class="line">		cout&lt;&lt;<span class="built_in">setw</span>(<span class="number">5</span>)&lt;&lt;x[i];</span><br><span class="line">	cout&lt;&lt;<span class="string">&quot;，获得的价值=&quot;</span>&lt;&lt;cv;</span><br><span class="line">	cout&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 搜索函数</span></span><br><span class="line"><span class="comment">//回溯</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">backtrack</span><span class="params">(<span class="type">int</span> t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(t&gt;=N)&#123;</span><br><span class="line">		<span class="keyword">if</span>(bestv&lt;cv) &#123;</span><br><span class="line">			bestv=cv; <span class="comment">//保存最优解</span></span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">0</span>;j&lt;N;j++)</span><br><span class="line">				bestx[j]=x[j];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">display</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">//搜索左枝</span></span><br><span class="line">		<span class="keyword">if</span>(cw+w[t]&lt;=C) &#123;</span><br><span class="line">			x[t]=<span class="number">1</span>; cv+=v[t]; cw+=w[t];</span><br><span class="line">			<span class="built_in">backtrack</span>(t+<span class="number">1</span>); <span class="comment">//继续向下深度搜索</span></span><br><span class="line">			x[t]=<span class="number">0</span>; cv-=v[t]; cw-=w[t]; <span class="comment">//回退</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//搜索右枝</span></span><br><span class="line">		x[t]=<span class="number">0</span>;</span><br><span class="line">		<span class="built_in">backtrack</span>(t+<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//按物品价值重量比排降序（此处省略）</span></span><br><span class="line">	<span class="built_in">backtrack</span>(<span class="number">0</span>);</span><br><span class="line">	cout&lt;&lt;<span class="string">&quot;最优价值:&quot;</span>&lt;&lt;bestv&lt;&lt;<span class="string">&quot;\t&quot;</span>;</span><br><span class="line">	cout&lt;&lt;<span class="string">&quot;此时放入背包物品:&quot;</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;N;j++)</span><br><span class="line">		<span class="keyword">if</span>(bestx[j]==<span class="number">1</span>)</span><br><span class="line">			cout&lt;&lt;j+<span class="number">1</span>&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">	cout&lt;&lt;endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>改进思路：</p>
<p>前述算法完全搜索解空间树：</p>
<p>• <font color=orange>用约束条件确定是否搜索其左子树</font></p>
<p>• <font color=blue>对右子树没有任何判断，一定进入右子树</font> -&gt; 耗时</p>
<p>改进后搜索解空间树策略：</p>
<p>• 只要其左子结点是一个可行结点，搜索就进入其左子树 <strong>— 约束函数</strong> （是否可行解）左子树剪枝</p>
<p>• 当右子树有可能包含最优解时才进入右子树搜索，否则将右子树剪去 <strong>— 限界函数</strong>（是否更优解）右子树剪枝</p>
<p>剪枝方法：</p>
<ul>
<li><p><code>r：当前剩余物品价值总和</code></p>
</li>
<li><p><code>cv：当前获得价值</code></p>
</li>
<li><p><code>bestv：当前最优价值</code></p>
</li>
<li><p><font color=orange>当cv+r &lt;&#x3D; bestv时，可剪去右子树</font> -&gt; <font color=greensky>当前价值与剩余物品价值之和小于等于已求最优价值，即无法得到更优解</font></p>
</li>
</ul>
<p>计算右子树上界的方法【<strong>贪心求得上界</strong>】：</p>
<p>• 将剩余物品依其 <strong>单位重量价值排序，然后依次装入物品</strong>，直至装不下时，再装入该物品的一部分而装满背包。<strong>此时得到的价值是右子树中解的上界</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">bound</span><span class="params">(<span class="type">int</span> i)</span> <span class="comment">//计算当前结点处上界</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> left=C-cw; <span class="comment">//剩余容量</span></span><br><span class="line">	<span class="type">int</span> b=cv; <span class="comment">//cv当前价值</span></span><br><span class="line">	<span class="keyword">while</span>(w[i]&lt;=left &amp;&amp; i&lt;=N)</span><br><span class="line">	&#123;</span><br><span class="line">		b+=v[i];</span><br><span class="line">		left-=w[i];</span><br><span class="line">		i++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/*装满背包*/</span></span><br><span class="line">	<span class="keyword">if</span>(i&lt;=N)</span><br><span class="line">		b+=left*v[i]/w[i];</span><br><span class="line">	<span class="keyword">return</span> b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//回溯</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">backtrack</span><span class="params">(<span class="type">int</span> t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(t&gt;=N)&#123;<span class="comment">//代码省略&#125;</span></span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">//搜索左枝</span></span><br><span class="line">		<span class="keyword">if</span>(cw+w[t]&lt;=C)</span><br><span class="line">		&#123;</span><br><span class="line">			x[t]=<span class="number">1</span>; cv+=v[t]; cw+=w[t];</span><br><span class="line">			<span class="built_in">backtrack</span>(t+<span class="number">1</span>); <span class="comment">//继续向下深度搜索</span></span><br><span class="line">			x[t]=<span class="number">0</span>; cv-=v[t]; cw-=w[t];<span class="comment">//回退</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//搜索右枝</span></span><br><span class="line">		<span class="keyword">if</span>(<span class="built_in">bound</span>(t+<span class="number">1</span>)&gt;bestv)</span><br><span class="line">		&#123;</span><br><span class="line">			x[t]=<span class="number">0</span>;</span><br><span class="line">			<span class="built_in">backtrack</span>(t+<span class="number">1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="D:\PersonalData\Mango\NEW\Blog\Hexo-blog\blog-mango\source\images\article\算法\hs-01背包实例.png" alt="image-20230317011838047"></p>
<p><strong>时间复杂度分析</strong></p>
<p>在最坏情况下，所搜索的结果是一个满二叉树 -&gt; <strong>穷举法</strong></p>
<p>时间复杂度为<strong>O(2$^n$)</strong></p>
<p>计算上界函数bound()需要**O(n)**时间</p>
<p>在最坏情况下有O(2$^n$)个右子结点需要计算上界函数</p>
<p>最坏情况下时间复杂度：<strong>T(n) &#x3D; O(n2$^n$)</strong></p>
<h3 id="TSP旅行售货员问题-O-n"><a href="#TSP旅行售货员问题-O-n" class="headerlink" title="TSP旅行售货员问题 O(n!)"></a>TSP旅行售货员问题 <strong>O(n!)</strong></h3><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="D:\PersonalData\Mango\NEW\Blog\Hexo-blog\blog-mango\source\images\article\算法\hs-旅行售货员-哈密顿图.png" alt="image-20230317012616519"></p>
<p>问题描述：</p>
<p><strong>旅行售货员问题</strong>(Traveling Salesman Problem, <strong>TSP</strong>)：某售货员要到若干城市去推销商品，下图显示了各城市之间的路程，他要选定一条从驻地出发，经过每个城市一遍，最后回到出发地的路线，使总的路程最短。（假设售货员的驻地为1）</p>
<p>&#x3D;&gt; 在图中寻找总权重最小的哈密顿回路，即通过图的每个顶点一次，且仅一次的最小回路</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="D:\PersonalData\Mango\NEW\Blog\Hexo-blog\blog-mango\source\images\article\算法\hs-旅行售货员问题.png" alt="image-20230317012854039" style="zoom:80%;" />

<p><strong>中国邮递员问题</strong>(Chinese Postman Problem, <strong>CPP</strong>)：一个邮递员从邮局出发，到所辖街道投邮件，最后返回邮局，如果他必须走遍所辖的每条街道至少一次，那么他应该如何选择投递路线，使所走的路程最短？</p>
<hr>
<p>给定一个连通图G，每条边e的权重均为非负数，要求找出一条回路经过每条边至少一次，且满足总权重最小 -&gt; &#x3D;&#x3D;欧拉回路&#x3D;&#x3D;</p>
<p><strong>算法设计</strong>：</p>
<p>&#x3D;&#x3D;解空间树&#x3D;&#x3D;</p>
<p>其解空间可以组织成一棵树；从树的根结点到任一结点的路径定义了图G的一条周游路线</p>
<p> 旅行售货员问题的解空间是一棵<font color=orange>排列树</font>，叶节点个数（周游线路）&#x3D;<strong>(n-1)!</strong></p>
<p> 对于排列树的回溯搜索与生成1，2，…，n的全排列的递归算法类似</p>
<p> 开始时x&#x3D;[1,2,…,n]，相应的排列树由x[1:n]的所有排列构成</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="D:\PersonalData\Mango\NEW\Blog\Hexo-blog\blog-mango\source_posts\2023\20230304-算法.assets\hs-TSP解空间树.png"></p>
<p>算法步骤：</p>
<p>在递归过程中，当<code>i=n</code>时，当前的扩展结点是排列树的<strong>叶结点的父结点</strong></p>
<p>• 检测图G<strong>是否存在一条从顶点x[n-1]到顶点x[n]的边和从顶点x[n]到顶点1的边</strong></p>
<p>• 如果这两条边都存在，则找到一条旅行售货员回路</p>
<p>• 此时，还需要<strong>判别这条回路的费用是否优于当前已经找到的最优回路的费用bestc</strong></p>
<p>• 如果是，则必须更新当前的最优值bestc和当前的最优解bestx</p>
<p>在递归过程中，当<code>i&lt;n</code>时，当前的扩展结点位于排列树的第i-1层</p>
<p>• 图G中<strong>存在从顶点x[i-1]到达顶点x[i]的边</strong>时，x[1:i]构成图G中的一条路径，<strong>且当x[1:i]的费用小于当前最优值时算法进入排列树的第i层</strong></p>
<p>• 否则，则剪去相应的子树</p>
<p>• <font color=orange>算法中用变量cc记录当前路径的费用</font></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 数据结构</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NUM 100</span></span><br><span class="line"><span class="type">int</span> n=<span class="number">4</span>; <span class="comment">//图G的顶点个数</span></span><br><span class="line"><span class="type">int</span> graph[NUM][NUM] = &#123;&#123;<span class="number">-1</span>,<span class="number">-1</span>,<span class="number">-1</span>,<span class="number">-1</span>,<span class="number">-1</span>&#125;,&#123;<span class="number">-1</span>,-</span><br><span class="line"><span class="number">1</span>,<span class="number">30</span>,<span class="number">6</span>,<span class="number">4</span>&#125;,&#123;<span class="number">-1</span>,<span class="number">30</span>,<span class="number">-1</span>,<span class="number">5</span>,<span class="number">10</span>&#125;,&#123;<span class="number">-1</span>,<span class="number">6</span>,<span class="number">5</span>,<span class="number">-1</span>,<span class="number">20</span>&#125;,&#123;<span class="number">-1</span>,<span class="number">4</span>,<span class="number">10</span>,<span class="number">20</span>,<span class="number">-1</span>&#125;&#125;; </span><br><span class="line"><span class="comment">//图G的邻接矩阵</span></span><br><span class="line"><span class="type">int</span> x[NUM]; <span class="comment">//当前解</span></span><br><span class="line"><span class="type">int</span> bestx[NUM]; <span class="comment">//最优解</span></span><br><span class="line"><span class="type">int</span> cc=<span class="number">0</span>; <span class="comment">//当前费用</span></span><br><span class="line"><span class="type">int</span> NoEdge=<span class="number">-1</span>; <span class="comment">//无边标记</span></span><br><span class="line"><span class="type">int</span> bestc=<span class="number">-1</span>; <span class="comment">//最优费用</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 搜索+剪枝</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">backtrack</span><span class="params">(<span class="type">int</span> t)</span> <span class="comment">//t从2开始</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//到达第n个节点</span></span><br><span class="line">	<span class="keyword">if</span>(t==n) &#123;</span><br><span class="line">		<span class="keyword">if</span>(graph[x[n<span class="number">-1</span>]][x[n]]!=NoEdge&amp;&amp;(graph[x[n]][<span class="number">1</span>]!=NoEdge)&amp;&amp;(cc+graph[x[n<span class="number">-1</span>]][x[n]]+graph[x[n]][<span class="number">1</span>]&lt;bestc||bestc==<span class="number">-1</span>)) &#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">				bestx[i]=x[i];</span><br><span class="line">			&#125;</span><br><span class="line">			bestc=cc+graph[x[n<span class="number">-1</span>]][x[n]]+graph[x[n]][<span class="number">1</span>];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=t;i&lt;=n;i++) &#123;</span><br><span class="line">			<span class="comment">//如果上一个节点和它此后的节点有边，并且费用低于现有的最优费用，bestc==-1表示第一次计算</span></span><br><span class="line">			<span class="keyword">if</span>(graph[x[t<span class="number">-1</span>]][x[i]]!=NoEdge &amp;&amp; (cc+graph[x[t<span class="number">-1</span>]][x[i]]&lt;bestc ||bestc==<span class="number">-1</span>)) &#123;</span><br><span class="line">				<span class="built_in">swap</span>(x[t],x[i]);</span><br><span class="line">				cc+=graph[x[t<span class="number">-1</span>]][x[t]];</span><br><span class="line">				<span class="built_in">backtrack</span>(t+<span class="number">1</span>);</span><br><span class="line">				cc-=graph[x[t<span class="number">-1</span>]][x[t]];</span><br><span class="line">				<span class="built_in">swap</span>(x[t],x[i]);</span><br><span class="line">			&#125; </span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">		x[i]=i;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">backtrack</span>(<span class="number">2</span>);</span><br><span class="line">	cout&lt;&lt;<span class="string">&quot;最少旅行费用为: &quot;</span>&lt;&lt;bestc&lt;&lt;endl;</span><br><span class="line">	cout&lt;&lt;<span class="string">&quot;旅行路径为:&quot;</span>&lt;&lt;endl;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">		cout&lt;&lt;bestx[i]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	cout&lt;&lt;bestx[<span class="number">1</span>];</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>算法效率：</p>
<p>从第一个城市到第二个城市有n-1种走法，从第二个城市到第三个城市有n-2种走法……因而共有(n-1)!种走法</p>
<p>若考虑v$_1$v$_2$…v$_n$v$_1$和v$_1$v$<em>n$v$</em>{n-1}$…v$_2$v$_1$是同一条回路，共有**(1&#x2F;2)(n-1)!**条不同的哈密顿回路</p>
<p>为了比较权重的大小，对每条哈密顿回路要做n-1次加法，故加法的总数为(1&#x2F;2)(n-1)(n-1)!</p>
<p>使用回溯法求解TSP问题的时间复杂度：<strong>T(n) &#x3D; O(n!)</strong> </p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://www.mangodb.site">Mango Ru</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://www.mangodb.site/posts/b7e144d1.html">https://www.mangodb.site/posts/b7e144d1.html</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://www.mangodb.site" target="_blank">MANGOのBlog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="/images/article/default_bg.png" data-sites="wechat,weibo,qq"></div><link rel="stylesheet" href="https://unpkg.com/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://unpkg.com/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i> 打赏</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/images/pay/wechat.png" target="_blank"><img class="post-qr-code-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/pay/wechat.png" alt="微信"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="/images/pay/alipay.jpg" target="_blank"><img class="post-qr-code-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/pay/alipay.jpg" alt="支付宝"/></a><div class="post-qr-code-desc">支付宝</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="next-post pull-full"><a href="/posts/e013aa32.html" title="【CSS必备】前端页面一键置灰"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/article/top_img/gray-white.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">【CSS必备】前端页面一键置灰</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/avatar/joy.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Mango Ru</div><div class="author-info__description">日出而作，日落而息</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">14</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">8</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">8</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/MangoRu"><i class="fab fa-github"></i><span>前往</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/MangoRu" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="https://blog.csdn.net/qq_40618816?spm=1000.2115.3001.5343" target="_blank" title="CSDN"><i class="fa-sharp fa-solid fa-c"></i></a><a class="social-icon" href="mailto:1596214166@qq.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">即将来临的一天，比过去的一年更为悠长。</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E7%AE%80%E4%BB%8B"><span class="toc-text">算法简介</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E5%A4%8D%E6%9D%82%E6%80%A7%E5%88%86%E6%9E%90"><span class="toc-text">算法复杂性分析</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E9%80%92%E5%BD%92%E7%AE%97%E6%B3%95"><span class="toc-text">算法——递归算法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Ackerman%E5%87%BD%E6%95%B0"><span class="toc-text">Ackerman函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%A8%E6%8E%92%E5%88%97%E9%97%AE%E9%A2%98"><span class="toc-text">全排列问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B4%E6%95%B0%E5%88%92%E5%88%86%E9%97%AE%E9%A2%98"><span class="toc-text">整数划分问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B1%89%E8%AF%BA%E5%A1%94%E9%97%AE%E9%A2%98O-2-n"><span class="toc-text">汉诺塔问题O(2$^n$)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E5%88%86%E6%B2%BB%E7%AE%97%E6%B3%95"><span class="toc-text">算法——分治算法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BEO-logn"><span class="toc-text">*二分查找O(logn)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8FO-nlogn"><span class="toc-text">*归并排序O(nlogn)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8FO-nlogn"><span class="toc-text">*快速排序O(nlogn)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E6%80%A7%E6%97%B6%E9%97%B4%E9%80%89%E6%8B%A9O-n"><span class="toc-text">线性时间选择O(n)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A3%8B%E7%9B%98%E8%A6%86%E7%9B%96"><span class="toc-text">棋盘覆盖</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%A7%E6%95%B4%E6%95%B0%E4%B9%98%E6%B3%95"><span class="toc-text">大整数乘法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Strassen%E7%9F%A9%E9%98%B5%E4%B9%98%E6%B3%95"><span class="toc-text">Strassen矩阵乘法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E3%80%90%E6%9C%80%E4%BC%98%E5%AD%90%E7%BB%93%E6%9E%84-%E9%87%8D%E5%8F%A0%E5%AD%90%E9%97%AE%E9%A2%98%E3%80%91"><span class="toc-text">算法——动态规划【最优子结构+重叠子问题】</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E5%AD%97%E4%B8%89%E8%A7%92%E5%BD%A2"><span class="toc-text">数字三角形</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9F%A9%E9%98%B5%E8%BF%9E%E4%B9%98O-n-3"><span class="toc-text">矩阵连乘O(n$^3$)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#LCS%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E5%BA%8F%E5%88%97O-mn"><span class="toc-text">LCS最长公共子序列O(mn)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%80%E5%A4%A7%E5%AD%90%E6%AE%B5%E5%92%8CO-n"><span class="toc-text">最大子段和O(n)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#LIS%E6%9C%80%E9%95%BF%E9%80%92%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%97"><span class="toc-text">LIS最长递增子序列</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#0-1%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98O-nc"><span class="toc-text">0-1背包问题O(nc)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95"><span class="toc-text">算法——贪心算法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B4%BB%E5%8A%A8%E5%AE%89%E6%8E%92%E9%97%AE%E9%A2%98O-nlogn"><span class="toc-text">活动安排问题O(nlogn)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%83%A8%E5%88%86%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98O-nlogn"><span class="toc-text">部分背包问题O(nlogn)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%80%E4%BC%98%E8%A3%85%E8%BD%BDO-nlogn"><span class="toc-text">最优装载O(nlogn)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#MST%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91"><span class="toc-text">MST最小生成树</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%E2%80%94%E2%80%94Prim%E7%AE%97%E6%B3%95O-V-2"><span class="toc-text">最小生成树——Prim算法O(V$^2$)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%E2%80%94%E2%80%94Kruskal%E7%AE%97%E6%B3%95-O-ElogE"><span class="toc-text">最小生成树——Kruskal算法 O(ElogE)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%E2%80%94%E2%80%94Dijkstra%E7%AE%97%E6%B3%95O-V-2"><span class="toc-text">最小生成树——Dijkstra算法O(V$_2$)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8D%95%E6%BA%90%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E9%97%AE%E9%A2%98"><span class="toc-text">单源最短路径问题</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E5%9B%9E%E6%BA%AF%E6%B3%95%E3%80%90DFS-%E5%89%AA%E6%9E%9D%E3%80%91"><span class="toc-text">算法——回溯法【DFS+剪枝】</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B2%B9%E7%94%B0%E9%97%AE%E9%A2%98"><span class="toc-text">油田问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A9%AC%E7%9A%84%E9%81%8D%E5%8E%86%E9%97%AE%E9%A2%98"><span class="toc-text">马的遍历问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#N%E7%9A%87%E5%90%8E%E9%97%AE%E9%A2%98"><span class="toc-text">N皇后问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%BE%E7%9A%84m%E7%9D%80%E8%89%B2%E9%97%AE%E9%A2%98O-m-n"><span class="toc-text">图的m着色问题O(m$^n$)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#0-1%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98O-n2-n"><span class="toc-text">0-1背包问题O(n2$^n$)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TSP%E6%97%85%E8%A1%8C%E5%94%AE%E8%B4%A7%E5%91%98%E9%97%AE%E9%A2%98-O-n"><span class="toc-text">TSP旅行售货员问题 O(n!)</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/posts/b7e144d1.html" title="算法"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/article/default_bg.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="算法"/></a><div class="content"><a class="title" href="/posts/b7e144d1.html" title="算法">算法</a><time datetime="2023-03-04T11:53:30.000Z" title="发表于 2023-03-04 19:53:30">2023-03-04</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/e013aa32.html" title="【CSS必备】前端页面一键置灰"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/article/top_img/gray-white.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="【CSS必备】前端页面一键置灰"/></a><div class="content"><a class="title" href="/posts/e013aa32.html" title="【CSS必备】前端页面一键置灰">【CSS必备】前端页面一键置灰</a><time datetime="2022-12-02T05:28:57.000Z" title="发表于 2022-12-02 13:28:57">2022-12-02</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/cc1b9611.html" title="JavaScript"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/article/default_bg.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="JavaScript"/></a><div class="content"><a class="title" href="/posts/cc1b9611.html" title="JavaScript">JavaScript</a><time datetime="2022-12-02T05:28:57.000Z" title="发表于 2022-12-02 13:28:57">2022-12-02</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/2fe3da.html" title="使用Hexo+Butterfly+Github+Vercel搭建个人博客"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/article/top_img/hexo-Website.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="使用Hexo+Butterfly+Github+Vercel搭建个人博客"/></a><div class="content"><a class="title" href="/posts/2fe3da.html" title="使用Hexo+Butterfly+Github+Vercel搭建个人博客">使用Hexo+Butterfly+Github+Vercel搭建个人博客</a><time datetime="2021-11-14T15:48:46.000Z" title="发表于 2021-11-14 23:48:46">2021-11-14</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/1e169319.html" title="在地址栏里输入一个 URL，到这个页面呈现出来，中间会发生什么"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/article/default_bg.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="在地址栏里输入一个 URL，到这个页面呈现出来，中间会发生什么"/></a><div class="content"><a class="title" href="/posts/1e169319.html" title="在地址栏里输入一个 URL，到这个页面呈现出来，中间会发生什么">在地址栏里输入一个 URL，到这个页面呈现出来，中间会发生什么</a><time datetime="2021-07-31T16:25:23.000Z" title="发表于 2021-08-01 00:25:23">2021-08-01</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2022 - 2023 By Mango Ru</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">简</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://unpkg.com/medium-zoom/dist/medium-zoom.min.js"></script><script src="https://unpkg.com/vanilla-lazyload/dist/lazyload.iife.min.js"></script><div class="js-pjax"></div><canvas id="universe"></canvas><script src="/js/universe.js"></script><script src="/js/light.js"></script><script defer="defer" id="ribbon" src="https://unpkg.com/butterfly-extsrc/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="false" data-click="true"></script><script src="https://unpkg.com/butterfly-extsrc/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
POWERMODE.mobile = false;
document.body.addEventListener('input', POWERMODE);
</script><script id="click-heart" src="https://unpkg.com/butterfly-extsrc/dist/click-heart.min.js" async="async" mobile="false"></script><script src="https://unpkg.com/pjax/pjax.min.js"></script><script>let pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {

  // removeEventListener scroll 
  window.tocScrollFn && window.removeEventListener('scroll', window.tocScrollFn)
  window.scrollCollect && window.removeEventListener('scroll', scrollCollect)

  document.getElementById('rightside').style.cssText = "opacity: ''; transform: ''"
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')

  typeof disqusjs === 'object' && disqusjs.destroy()
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof chatBtnFn === 'function' && chatBtnFn()
  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()
})

document.addEventListener('pjax:error', (e) => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div><!-- hexo injector body_end start --><script data-pjax>
  function butterfly_footer_beautify_injector_config(){
    var parent_div_git = document.getElementById('footer-wrap');
    var item_html = '<p id="ghbdages"><a class="github-badge" target="_blank" href="https://hexo.io/" style="margin-inline:5px" data-title="博客框架为Hexo_v6.2.0" title=""><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/Frame-Hexo-blue?style=flat&amp;logo=hexo" alt=""/></a><a class="github-badge" target="_blank" href="https://butterfly.js.org/" style="margin-inline:5px" data-title="主题版本Butterfly_v4.3.1" title=""><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/Theme-Butterfly-6513df?style=flat&amp;logo=bitdefender" alt=""/></a><a class="github-badge" target="_blank" href="https://vercel.com/" style="margin-inline:5px" data-title="本站采用多线部署，主线路托管于Vercel" title=""><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/Hosted-Vercel-brightgreen?style=flat&amp;logo=Vercel" alt=""/></a><a class="github-badge" target="_blank" href="https://github.com/" style="margin-inline:5px" data-title="本站项目由Github托管" title=""><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/Source-Github-d021d6?style=flat&amp;logo=GitHub" alt=""/></a></p>';
    console.log('已挂载butterfly_footer_beautify')
    parent_div_git.insertAdjacentHTML("beforeend",item_html)
    }
  var elist = 'null'.split(',');
  var cpage = location.pathname;
  var epage = 'all';
  var flag = 0;

  for (var i=0;i<elist.length;i++){
    if (cpage.includes(elist[i])){
      flag++;
    }
  }

  if ((epage ==='all')&&(flag == 0)){
    butterfly_footer_beautify_injector_config();
  }
  else if (epage === cpage){
    butterfly_footer_beautify_injector_config();
  }
  </script><!-- hexo injector body_end end --><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"/live2dw/assets/koharu.model.json"},"display":{"position":"left","width":150,"height":300},"mobile":{"show":false},"log":false});</script></body></html>